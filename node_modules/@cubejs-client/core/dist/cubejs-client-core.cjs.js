'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
var _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');
var _typeof = require('@babel/runtime/helpers/typeof');
var _classCallCheck = require('@babel/runtime/helpers/classCallCheck');
var _createClass = require('@babel/runtime/helpers/createClass');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var _regeneratorRuntime = require('@babel/runtime/regenerator');
require('core-js/modules/es.array.for-each.js');
require('core-js/modules/es.symbol.js');
require('core-js/modules/es.array.filter.js');
require('core-js/modules/es.array.is-array.js');
require('core-js/modules/es.object.define-properties.js');
require('core-js/modules/es.object.define-property.js');
require('core-js/modules/es.object.get-own-property-descriptor.js');
require('core-js/modules/es.object.get-own-property-descriptors.js');
require('core-js/modules/es.array.map.js');
require('core-js/modules/es.array.reduce.js');
require('core-js/modules/es.number.constructor.js');
require('core-js/modules/es.object.entries.js');
require('core-js/modules/es.object.keys.js');
require('core-js/modules/es.object.to-string.js');
require('core-js/modules/es.promise.js');
require('core-js/modules/web.dom-collections.for-each.js');
require('core-js/modules/web.timers.js');
var uuid = require('uuid');
require('@babel/runtime/helpers/readOnlyError');
var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');
var _toConsumableArray = require('@babel/runtime/helpers/toConsumableArray');
require('core-js/modules/es.array.concat.js');
require('core-js/modules/es.array.find.js');
require('core-js/modules/es.array.from.js');
require('core-js/modules/es.array.includes.js');
require('core-js/modules/es.array.index-of.js');
require('core-js/modules/es.array.iterator.js');
require('core-js/modules/es.array.join.js');
require('core-js/modules/es.date.to-string.js');
require('core-js/modules/es.map.js');
require('core-js/modules/es.number.is-nan.js');
require('core-js/modules/es.number.parse-float.js');
require('core-js/modules/es.object.values.js');
require('core-js/modules/es.regexp.exec.js');
require('core-js/modules/es.regexp.to-string.js');
require('core-js/modules/es.set.js');
require('core-js/modules/es.string.includes.js');
require('core-js/modules/es.string.iterator.js');
require('core-js/modules/es.string.match.js');
require('core-js/modules/es.string.trim.js');
require('core-js/modules/web.dom-collections.iterator.js');
var dayjs = require('dayjs');
var ramda = require('ramda');
require('core-js/modules/es.array.every.js');
require('core-js/modules/es.array.flat-map.js');
require('core-js/modules/es.array.splice.js');
require('core-js/modules/es.array.unscopables.flat-map.js');
require('core-js/modules/es.array.slice.js');
require('core-js/modules/es.parse-int.js');
require('core-js/modules/es.string.ends-with.js');
require('core-js/modules/es.string.split.js');
var quarterOfYear = require('dayjs/plugin/quarterOfYear');
var duration = require('dayjs/plugin/duration');
var isoWeek = require('dayjs/plugin/isoWeek');
var en = require('dayjs/locale/en');
require('core-js/modules/es.array.sort.js');
require('core-js/modules/es.function.name.js');
require('core-js/modules/es.date.to-json.js');
require('core-js/modules/web.url-search-params.js');
var fetch = require('cross-fetch');
require('url-search-params-polyfill');
require('core-js/modules/es.reflect.construct.js');
var _possibleConstructorReturn = require('@babel/runtime/helpers/possibleConstructorReturn');
var _getPrototypeOf = require('@babel/runtime/helpers/getPrototypeOf');
var _inherits = require('@babel/runtime/helpers/inherits');
var _wrapNativeSuper = require('@babel/runtime/helpers/wrapNativeSuper');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);
var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);
var _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);
var _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);
var _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);
var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);
var _objectWithoutProperties__default = /*#__PURE__*/_interopDefaultLegacy(_objectWithoutProperties);
var _toConsumableArray__default = /*#__PURE__*/_interopDefaultLegacy(_toConsumableArray);
var dayjs__default = /*#__PURE__*/_interopDefaultLegacy(dayjs);
var quarterOfYear__default = /*#__PURE__*/_interopDefaultLegacy(quarterOfYear);
var duration__default = /*#__PURE__*/_interopDefaultLegacy(duration);
var isoWeek__default = /*#__PURE__*/_interopDefaultLegacy(isoWeek);
var en__default = /*#__PURE__*/_interopDefaultLegacy(en);
var fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch);
var _possibleConstructorReturn__default = /*#__PURE__*/_interopDefaultLegacy(_possibleConstructorReturn);
var _getPrototypeOf__default = /*#__PURE__*/_interopDefaultLegacy(_getPrototypeOf);
var _inherits__default = /*#__PURE__*/_interopDefaultLegacy(_inherits);
var _wrapNativeSuper__default = /*#__PURE__*/_interopDefaultLegacy(_wrapNativeSuper);

function ownKeys$4(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$4(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$4(Object(t), !0).forEach(function (r) { _defineProperty__default['default'](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
dayjs__default['default'].extend(quarterOfYear__default['default']);
dayjs__default['default'].extend(duration__default['default']);
dayjs__default['default'].extend(isoWeek__default['default']);

// TODO: Define a better type as unitOfTime.DurationConstructor in moment.js

var GRANULARITIES = [{
  name: undefined,
  title: 'w/o grouping'
}, {
  name: 'second',
  title: 'Second'
}, {
  name: 'minute',
  title: 'Minute'
}, {
  name: 'hour',
  title: 'Hour'
}, {
  name: 'day',
  title: 'Day'
}, {
  name: 'week',
  title: 'Week'
}, {
  name: 'month',
  title: 'Month'
}, {
  name: 'quarter',
  title: 'Quarter'
}, {
  name: 'year',
  title: 'Year'
}];
var DEFAULT_GRANULARITY = 'day';

// When granularity is week, weekStart Value must be 1. However, since the client can change it globally
// (https://day.js.org/docs/en/i18n/changing-locale) So the function below has been added.
var internalDayjs = function internalDayjs() {
  return dayjs__default['default'].apply(void 0, arguments).locale(_objectSpread$4(_objectSpread$4({}, en__default['default']), {}, {
    weekStart: 1
  }));
};
var TIME_SERIES = {
  day: function day(range) {
    return range.by('d').map(function (d) {
      return d.format('YYYY-MM-DDT00:00:00.000');
    });
  },
  month: function month(range) {
    return range.snapTo('month').by('M').map(function (d) {
      return d.format('YYYY-MM-01T00:00:00.000');
    });
  },
  year: function year(range) {
    return range.snapTo('year').by('y').map(function (d) {
      return d.format('YYYY-01-01T00:00:00.000');
    });
  },
  hour: function hour(range) {
    return range.by('h').map(function (d) {
      return d.format('YYYY-MM-DDTHH:00:00.000');
    });
  },
  minute: function minute(range) {
    return range.by('m').map(function (d) {
      return d.format('YYYY-MM-DDTHH:mm:00.000');
    });
  },
  second: function second(range) {
    return range.by('s').map(function (d) {
      return d.format('YYYY-MM-DDTHH:mm:ss.000');
    });
  },
  week: function week(range) {
    return range.snapTo('week').by('w').map(function (d) {
      return d.startOf('week').format('YYYY-MM-DDT00:00:00.000');
    });
  },
  quarter: function quarter(range) {
    return range.snapTo('quarter').by('quarter').map(function (d) {
      return d.startOf('quarter').format('YYYY-MM-DDT00:00:00.000');
    });
  }
};
var isPredefinedGranularity = function isPredefinedGranularity(granularity) {
  return !!TIME_SERIES[granularity];
};
var DateRegex = /^\d\d\d\d-\d\d-\d\d$/;
var LocalDateRegex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z?$/;
var _dayRange = function dayRange(from, to) {
  return {
    by: function by(value) {
      var results = [];
      var start = internalDayjs(from);
      var end = internalDayjs(to);
      while (start.isBefore(end) || start.isSame(end)) {
        results.push(start);
        start = start.add(1, value);
      }
      return results;
    },
    snapTo: function snapTo(value) {
      return _dayRange(internalDayjs(from).startOf(value), internalDayjs(to).endOf(value));
    },
    start: internalDayjs(from),
    end: internalDayjs(to)
  };
};
function parseSqlInterval(intervalStr) {
  var interval = {};
  var parts = intervalStr.split(/\s+/);
  for (var i = 0; i < parts.length; i += 2) {
    var value = parseInt(parts[i], 10);
    var unit = parts[i + 1];

    // Remove ending 's' (e.g., 'days' -> 'day')
    var singularUnit = unit.endsWith('s') ? unit.slice(0, -1) : unit;
    interval[singularUnit] = value;
  }
  return interval;
}

/**
 * Adds interval to provided date.
 * TODO: It's copy/paste of addInterval from @cubejs-backend/shared [time.ts]
 * but operates with dayjs instead of moment.js
 * @param {dayjs} date
 * @param interval
 * @returns {dayjs}
 */
function addInterval(date, interval) {
  var res = date.clone();
  Object.entries(interval).forEach(function (_ref) {
    var _ref2 = _slicedToArray__default['default'](_ref, 2),
      key = _ref2[0],
      value = _ref2[1];
    res = res.add(value, key);
  });
  return res;
}

/**
 * Adds interval to provided date.
 * TODO: It's copy/paste of subtractInterval from @cubejs-backend/shared [time.ts]
 * but operates with dayjs instead of moment.js
 * @param {dayjs} date
 * @param interval
 * @returns {dayjs}
 */
function subtractInterval(date, interval) {
  var res = date.clone();
  Object.entries(interval).forEach(function (_ref3) {
    var _ref4 = _slicedToArray__default['default'](_ref3, 2),
      key = _ref4[0],
      value = _ref4[1];
    res = res.subtract(value, key);
  });
  return res;
}

/**
 * Returns the closest date prior to date parameter aligned with the origin point
 * TODO: It's copy/paste of alignToOrigin from @cubejs-backend/shared [time.ts]
 * but operates with dayjs instead of moment.js
 */
function alignToOrigin(startDate, interval, origin) {
  var alignedDate = startDate.clone();
  var intervalOp;
  var isIntervalNegative = false;
  var offsetDate = addInterval(origin, interval);

  // The easiest way to check the interval sign
  if (offsetDate.isBefore(origin)) {
    isIntervalNegative = true;
  }
  offsetDate = origin.clone();
  if (startDate.isBefore(origin)) {
    intervalOp = isIntervalNegative ? addInterval : subtractInterval;
    while (offsetDate.isAfter(startDate)) {
      offsetDate = intervalOp(offsetDate, interval);
    }
    alignedDate = offsetDate;
  } else {
    intervalOp = isIntervalNegative ? subtractInterval : addInterval;
    while (offsetDate.isBefore(startDate)) {
      alignedDate = offsetDate.clone();
      offsetDate = intervalOp(offsetDate, interval);
    }
    if (offsetDate.isSame(startDate)) {
      alignedDate = offsetDate;
    }
  }
  return alignedDate;
}

/**
 * Returns the time series points for the custom interval
 * TODO: It's almost a copy/paste of timeSeriesFromCustomInterval from
 * @cubejs-backend/shared [time.ts] but operates with dayjs instead of moment.js
 */
var timeSeriesFromCustomInterval = function timeSeriesFromCustomInterval(from, to, granularity) {
  var intervalParsed = parseSqlInterval(granularity.interval);
  var start = internalDayjs(from);
  var end = internalDayjs(to);
  var origin = granularity.origin ? internalDayjs(granularity.origin) : internalDayjs().startOf('year');
  if (granularity.offset) {
    origin = addInterval(origin, parseSqlInterval(granularity.offset));
  }
  var alignedStart = alignToOrigin(start, intervalParsed, origin);
  var dates = [];
  while (alignedStart.isBefore(end) || alignedStart.isSame(end)) {
    dates.push(alignedStart.format('YYYY-MM-DDTHH:mm:ss.000'));
    alignedStart = addInterval(alignedStart, intervalParsed);
  }
  return dates;
};

/**
 * Returns the lowest time unit for the interval
 */
var diffTimeUnitForInterval = function diffTimeUnitForInterval(interval) {
  if (/second/i.test(interval)) {
    return 'second';
  } else if (/minute/i.test(interval)) {
    return 'minute';
  } else if (/hour/i.test(interval)) {
    return 'hour';
  } else if (/day/i.test(interval)) {
    return 'day';
  } else if (/week/i.test(interval)) {
    return 'day';
  } else if (/month/i.test(interval)) {
    return 'month';
  } else if (/quarter/i.test(interval)) {
    return 'month';
  } else /* if (/year/i.test(interval)) */{
      return 'year';
    }
};
var granularityOrder = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second'];
var minGranularityForIntervals = function minGranularityForIntervals(i1, i2) {
  var g1 = diffTimeUnitForInterval(i1);
  var g2 = diffTimeUnitForInterval(i2);
  var g1pos = granularityOrder.indexOf(g1);
  var g2pos = granularityOrder.indexOf(g2);
  if (g1pos > g2pos) {
    return g1;
  }
  return g2;
};
var granularityFor = function granularityFor(dateStr) {
  var dayjsDate = internalDayjs(dateStr);
  var month = dayjsDate.month();
  var date = dayjsDate.date();
  var hours = dayjsDate.hour();
  var minutes = dayjsDate.minute();
  var seconds = dayjsDate.second();
  var milliseconds = dayjsDate.millisecond();
  var weekDay = dayjsDate.isoWeekday();
  if (month === 0 && date === 1 && hours === 0 && minutes === 0 && seconds === 0 && milliseconds === 0) {
    return 'year';
  } else if (date === 1 && hours === 0 && minutes === 0 && seconds === 0 && milliseconds === 0) {
    return 'month';
  } else if (weekDay === 1 && hours === 0 && minutes === 0 && seconds === 0 && milliseconds === 0) {
    return 'week';
  } else if (hours === 0 && minutes === 0 && seconds === 0 && milliseconds === 0) {
    return 'day';
  } else if (minutes === 0 && seconds === 0 && milliseconds === 0) {
    return 'hour';
  } else if (seconds === 0 && milliseconds === 0) {
    return 'minute';
  } else if (milliseconds === 0) {
    return 'second';
  }
  return 'second'; // TODO return 'millisecond';
};

var _excluded$2 = ["query"];
function ownKeys$3(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$3(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$3(Object(t), !0).forEach(function (r) { _defineProperty__default['default'](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function removeEmptyQueryFields(_query) {
  var query = _query || {};
  return ramda.fromPairs(ramda.toPairs(query).flatMap(function (_ref) {
    var _ref2 = _slicedToArray__default['default'](_ref, 2),
      key = _ref2[0],
      value = _ref2[1];
    if (['measures', 'dimensions', 'segments', 'timeDimensions', 'filters'].includes(key)) {
      if (Array.isArray(value) && value.length === 0) {
        return [];
      }
    }
    if (key === 'order' && value) {
      if (Array.isArray(value) && value.length === 0) {
        return [];
      } else if (!Object.keys(value).length) {
        return [];
      }
    }
    return [[key, value]];
  }));
}
function validateQuery(_query) {
  var query = _query || {};
  return removeEmptyQueryFields(_objectSpread$3(_objectSpread$3({}, query), {}, {
    filters: (query.filters || []).filter(function (f) {
      return 'operator' in f;
    }),
    timeDimensions: (query.timeDimensions || []).filter(function (td) {
      return !(!td.dateRange && !td.granularity);
    })
  }));
}
function areQueriesEqual(query1, query2) {
  return ramda.equals(Object.entries((query1 === null || query1 === void 0 ? void 0 : query1.order) || {}), Object.entries((query2 === null || query2 === void 0 ? void 0 : query2.order) || {})) && ramda.equals(query1, query2);
}
function defaultOrder(query) {
  var granularity = (query.timeDimensions || []).find(function (d) {
    return d.granularity;
  });
  if (granularity) {
    return _defineProperty__default['default']({}, granularity.dimension, 'asc');
  } else if ((query.measures || []).length > 0 && (query.dimensions || []).length > 0) {
    return _defineProperty__default['default']({}, query.measures[0], 'desc');
  } else if ((query.dimensions || []).length > 0) {
    return _defineProperty__default['default']({}, query.dimensions[0], 'asc');
  }
  return {};
}
function defaultHeuristics(newState, oldQuery, options) {
  var _clone = ramda.clone(newState),
    query = _clone.query,
    props = _objectWithoutProperties__default['default'](_clone, _excluded$2);
  var meta = options.meta,
    sessionGranularity = options.sessionGranularity;
  var granularity = sessionGranularity || DEFAULT_GRANULARITY;
  var state = _objectSpread$3({
    shouldApplyHeuristicOrder: false,
    pivotConfig: null,
    query: query
  }, props);
  var newQuery = null;
  if (!areQueriesEqual(query, oldQuery)) {
    newQuery = query;
  }
  if (Array.isArray(newQuery) || Array.isArray(oldQuery)) {
    return _objectSpread$3({
      shouldApplyHeuristicOrder: false,
      pivotConfig: null
    }, newState);
  }
  if (newQuery) {
    if ((oldQuery.timeDimensions || []).length === 1 && (newQuery.timeDimensions || []).length === 1 && newQuery.timeDimensions[0].granularity && oldQuery.timeDimensions[0].granularity !== newQuery.timeDimensions[0].granularity) {
      state = _objectSpread$3(_objectSpread$3({}, state), {}, {
        sessionGranularity: newQuery.timeDimensions[0].granularity
      });
    }
    if ((oldQuery.measures || []).length === 0 && (newQuery.measures || []).length > 0 || (oldQuery.measures || []).length === 1 && (newQuery.measures || []).length === 1 && oldQuery.measures[0] !== newQuery.measures[0]) {
      var _ref6 = newQuery.timeDimensions || [],
        _ref7 = _slicedToArray__default['default'](_ref6, 1),
        td = _ref7[0];
      var defaultTimeDimension = meta.defaultTimeDimensionNameFor(newQuery.measures[0]);
      newQuery = _objectSpread$3(_objectSpread$3({}, newQuery), {}, {
        timeDimensions: defaultTimeDimension ? [{
          dimension: defaultTimeDimension,
          granularity: (td === null || td === void 0 ? void 0 : td.granularity) || granularity,
          dateRange: td === null || td === void 0 ? void 0 : td.dateRange
        }] : []
      });
      return _objectSpread$3(_objectSpread$3({}, state), {}, {
        pivotConfig: null,
        shouldApplyHeuristicOrder: true,
        query: newQuery,
        chartType: defaultTimeDimension ? 'line' : 'number'
      });
    }
    if ((oldQuery.dimensions || []).length === 0 && (newQuery.dimensions || []).length > 0) {
      newQuery = _objectSpread$3(_objectSpread$3({}, newQuery), {}, {
        timeDimensions: (newQuery.timeDimensions || []).map(function (td) {
          return _objectSpread$3(_objectSpread$3({}, td), {}, {
            granularity: undefined
          });
        })
      });
      return _objectSpread$3(_objectSpread$3({}, state), {}, {
        pivotConfig: null,
        shouldApplyHeuristicOrder: true,
        query: newQuery,
        chartType: 'table'
      });
    }
    if ((oldQuery.dimensions || []).length > 0 && (newQuery.dimensions || []).length === 0) {
      newQuery = _objectSpread$3(_objectSpread$3({}, newQuery), {}, {
        timeDimensions: (newQuery.timeDimensions || []).map(function (td) {
          return _objectSpread$3(_objectSpread$3({}, td), {}, {
            granularity: td.granularity || granularity
          });
        })
      });
      return _objectSpread$3(_objectSpread$3({}, state), {}, {
        pivotConfig: null,
        shouldApplyHeuristicOrder: true,
        query: newQuery,
        chartType: (newQuery.timeDimensions || []).length ? 'line' : 'number'
      });
    }
    if (((oldQuery.dimensions || []).length > 0 || (oldQuery.measures || []).length > 0) && (newQuery.dimensions || []).length === 0 && (newQuery.measures || []).length === 0) {
      newQuery = _objectSpread$3(_objectSpread$3({}, newQuery), {}, {
        timeDimensions: [],
        filters: []
      });
      return _objectSpread$3(_objectSpread$3({}, state), {}, {
        pivotConfig: null,
        shouldApplyHeuristicOrder: true,
        query: newQuery,
        sessionGranularity: null
      });
    }
    return state;
  }
  if (state.chartType) {
    var newChartType = state.chartType;
    if ((newChartType === 'line' || newChartType === 'area') && (oldQuery.timeDimensions || []).length === 1 && !oldQuery.timeDimensions[0].granularity) {
      var _ref8 = oldQuery.timeDimensions,
        _ref9 = _slicedToArray__default['default'](_ref8, 1),
        _td = _ref9[0];
      return _objectSpread$3(_objectSpread$3({}, state), {}, {
        pivotConfig: null,
        query: _objectSpread$3(_objectSpread$3({}, oldQuery), {}, {
          timeDimensions: [_objectSpread$3(_objectSpread$3({}, _td), {}, {
            granularity: granularity
          })]
        })
      });
    }
    if ((newChartType === 'pie' || newChartType === 'table' || newChartType === 'number') && (oldQuery.timeDimensions || []).length === 1 && oldQuery.timeDimensions[0].granularity) {
      var _ref10 = oldQuery.timeDimensions,
        _ref11 = _slicedToArray__default['default'](_ref10, 1),
        _td2 = _ref11[0];
      return _objectSpread$3(_objectSpread$3({}, state), {}, {
        pivotConfig: null,
        shouldApplyHeuristicOrder: true,
        query: _objectSpread$3(_objectSpread$3({}, oldQuery), {}, {
          timeDimensions: [_objectSpread$3(_objectSpread$3({}, _td2), {}, {
            granularity: undefined
          })]
        })
      });
    }
  }
  return state;
}
function isQueryPresent(query) {
  if (!query) {
    return false;
  }
  return (Array.isArray(query) ? query : [query]).every(function (q) {
    var _q$measures, _q$dimensions, _q$timeDimensions;
    return ((_q$measures = q.measures) === null || _q$measures === void 0 ? void 0 : _q$measures.length) || ((_q$dimensions = q.dimensions) === null || _q$dimensions === void 0 ? void 0 : _q$dimensions.length) || ((_q$timeDimensions = q.timeDimensions) === null || _q$timeDimensions === void 0 ? void 0 : _q$timeDimensions.length);
  });
}
function movePivotItem(pivotConfig, sourceIndex, destinationIndex, sourceAxis, destinationAxis) {
  var nextPivotConfig = _objectSpread$3(_objectSpread$3({}, pivotConfig), {}, {
    x: _toConsumableArray__default['default'](pivotConfig.x || []),
    y: _toConsumableArray__default['default'](pivotConfig.y || [])
  });
  var id = pivotConfig[sourceAxis][sourceIndex];
  var lastIndex = nextPivotConfig[destinationAxis].length - 1;
  if (id === 'measures') {
    destinationIndex = lastIndex + 1;
  } else if (sourceAxis === destinationAxis && destinationIndex >= lastIndex && nextPivotConfig[destinationAxis][lastIndex] === 'measures') {
    destinationIndex = lastIndex - 1;
  } else if (sourceAxis !== destinationAxis && destinationIndex > lastIndex && nextPivotConfig[destinationAxis][lastIndex] === 'measures') {
    destinationIndex = lastIndex;
  }
  nextPivotConfig[sourceAxis].splice(sourceIndex, 1);
  nextPivotConfig[destinationAxis].splice(destinationIndex, 0, id);
  return nextPivotConfig;
}
function moveItemInArray(list, sourceIndex, destinationIndex) {
  var result = _toConsumableArray__default['default'](list);
  var _result$splice = result.splice(sourceIndex, 1),
    _result$splice2 = _slicedToArray__default['default'](_result$splice, 1),
    removed = _result$splice2[0];
  result.splice(destinationIndex, 0, removed);
  return result;
}
function flattenFilters() {
  var filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return filters.reduce(function (memo, filter) {
    if ('or' in filter) {
      return [].concat(_toConsumableArray__default['default'](memo), _toConsumableArray__default['default'](flattenFilters(filter.or)));
    }
    if ('and' in filter) {
      return [].concat(_toConsumableArray__default['default'](memo), _toConsumableArray__default['default'](flattenFilters(filter.and)));
    }
    return [].concat(_toConsumableArray__default['default'](memo), [filter]);
  }, []);
}
function getQueryMembers() {
  var query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var keys = ['measures', 'dimensions', 'segments'];
  var members = new Set();
  keys.forEach(function (key) {
    return (query[key] || []).forEach(function (member) {
      return members.add(member);
    });
  });
  (query.timeDimensions || []).forEach(function (td) {
    return members.add(td.dimension);
  });
  var filters = flattenFilters(query.filters);
  filters.forEach(function (filter) {
    var member = filter.dimension || filter.member;
    if (typeof member === 'string') {
      members.add(member);
    }
  });
  return _toConsumableArray__default['default'](members);
}
function getOrderMembersFromOrder(orderMembers, order) {
  var ids = new Set();
  var indexedOrderMembers = ramda.indexBy(ramda.prop('id'), orderMembers);
  var entries = Array.isArray(order) ? order : Object.entries(order || {});
  var nextOrderMembers = [];
  entries.forEach(function (_ref12) {
    var _ref13 = _slicedToArray__default['default'](_ref12, 2),
      memberId = _ref13[0],
      currentOrder = _ref13[1];
    if (currentOrder !== 'none' && indexedOrderMembers[memberId]) {
      ids.add(memberId);
      nextOrderMembers.push(_objectSpread$3(_objectSpread$3({}, indexedOrderMembers[memberId]), {}, {
        order: currentOrder
      }));
    }
  });
  orderMembers.forEach(function (member) {
    if (!ids.has(member.id)) {
      nextOrderMembers.push(_objectSpread$3(_objectSpread$3({}, member), {}, {
        order: member.order || 'none'
      }));
    }
  });
  return nextOrderMembers;
}
function aliasSeries(values, index, pivotConfig) {
  var _pivotConfig$aliasSer;
  var duplicateMeasures = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Set();
  var nonNullValues = values.filter(function (value) {
    return value != null;
  });
  if (pivotConfig !== null && pivotConfig !== void 0 && (_pivotConfig$aliasSer = pivotConfig.aliasSeries) !== null && _pivotConfig$aliasSer !== void 0 && _pivotConfig$aliasSer[index]) {
    return [pivotConfig.aliasSeries[index]].concat(_toConsumableArray__default['default'](nonNullValues));
  } else if (duplicateMeasures.has(nonNullValues[0])) {
    return [index].concat(_toConsumableArray__default['default'](nonNullValues));
  }
  return nonNullValues;
}

var _excluded$1 = ["x"],
  _excluded2 = ["key"],
  _excluded3 = ["title", "shortTitle"];
function ownKeys$2(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$2(Object(t), !0).forEach(function (r) { _defineProperty__default['default'](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var groupByToPairs = function groupByToPairsImpl(keyFn) {
  var acc = new Map();
  return function (data) {
    data.forEach(function (row) {
      var key = keyFn(row);
      if (!acc.has(key)) {
        acc.set(key, []);
      }
      acc.get(key).push(row);
    });
    return Array.from(acc.entries());
  };
};
var unnest = function unnest(arr) {
  var res = [];
  arr.forEach(function (subArr) {
    subArr.forEach(function (element) {
      return res.push(element);
    });
  });
  return res;
};
var QUERY_TYPE = {
  REGULAR_QUERY: 'regularQuery',
  COMPARE_DATE_RANGE_QUERY: 'compareDateRangeQuery',
  BLENDING_QUERY: 'blendingQuery'
};
/**
 * Provides a convenient interface for data manipulation.
 */
var ResultSet = /*#__PURE__*/function () {
  function ResultSet(loadResponse) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck__default['default'](this, ResultSet);
    _defineProperty__default['default'](this, "loadResponse", void 0);
    _defineProperty__default['default'](this, "loadResponses", void 0);
    _defineProperty__default['default'](this, "queryType", void 0);
    _defineProperty__default['default'](this, "parseDateMeasures", void 0);
    _defineProperty__default['default'](this, "options", void 0);
    _defineProperty__default['default'](this, "backwardCompatibleData", void 0);
    if ('queryType' in loadResponse && loadResponse.queryType != null) {
      this.loadResponse = loadResponse;
      this.queryType = loadResponse.queryType;
      this.loadResponses = loadResponse.results;
    } else {
      this.queryType = QUERY_TYPE.REGULAR_QUERY;
      this.loadResponse = _objectSpread$2(_objectSpread$2({}, loadResponse), {}, {
        pivotQuery: _objectSpread$2(_objectSpread$2({}, loadResponse.query), {}, {
          queryType: this.queryType
        })
      });
      this.loadResponses = [loadResponse];
    }
    if (!Object.values(QUERY_TYPE).includes(this.queryType)) {
      throw new Error('Unknown query type');
    }
    this.parseDateMeasures = options.parseDateMeasures;
    this.options = options;
    this.backwardCompatibleData = [];
  }

  /**
   * Returns a measure drill down query.
   *
   * Provided you have a measure with the defined `drillMembers` on the `Orders` cube
   * ```js
   * measures: {
   *   count: {
   *     type: `count`,
   *     drillMembers: [Orders.status, Users.city, count],
   *   },
   *   // ...
   * }
   * ```
   *
   * Then you can use the `drillDown` method to see the rows that contribute to that metric
   * ```js
   * resultSet.drillDown(
   *   {
   *     xValues,
   *     yValues,
   *   },
   *   // you should pass the `pivotConfig` if you have used it for axes manipulation
   *   pivotConfig
   * )
   * ```
   *
   * the result will be a query with the required filters applied and the dimensions/measures filled out
   * ```js
   * {
   *   measures: ['Orders.count'],
   *   dimensions: ['Orders.status', 'Users.city'],
   *   filters: [
   *     // dimension and measure filters
   *   ],
   *   timeDimensions: [
   *     //...
   *   ]
   * }
   * ```
   *
   * In case when you want to add `order` or `limit` to the query, you can simply spread it
   *
   * ```js
   * // An example for React
   * const drillDownResponse = useCubeQuery(
   *    {
   *      ...drillDownQuery,
   *      limit: 30,
   *      order: {
   *        'Orders.ts': 'desc'
   *      }
   *    },
   *    {
   *      skip: !drillDownQuery
   *    }
   *  );
   * ```
   * @returns Drill down query
   */
  return _createClass__default['default'](ResultSet, [{
    key: "drillDown",
    value: function drillDown(drillDownLocator, pivotConfig) {
      var _drillDownLocator$xVa, _drillDownLocator$yVa, _measures$measureName, _measures$measureName2;
      if (this.queryType === QUERY_TYPE.COMPARE_DATE_RANGE_QUERY) {
        throw new Error('compareDateRange drillDown query is not currently supported');
      }
      if (this.queryType === QUERY_TYPE.BLENDING_QUERY) {
        throw new Error('Data blending drillDown query is not currently supported');
      }
      var query = this.loadResponses[0].query;
      var xValues = (_drillDownLocator$xVa = drillDownLocator === null || drillDownLocator === void 0 ? void 0 : drillDownLocator.xValues) !== null && _drillDownLocator$xVa !== void 0 ? _drillDownLocator$xVa : [];
      var yValues = (_drillDownLocator$yVa = drillDownLocator === null || drillDownLocator === void 0 ? void 0 : drillDownLocator.yValues) !== null && _drillDownLocator$yVa !== void 0 ? _drillDownLocator$yVa : [];
      var normalizedPivotConfig = this.normalizePivotConfig(pivotConfig);
      var values = [];
      normalizedPivotConfig === null || normalizedPivotConfig === void 0 || normalizedPivotConfig.x.forEach(function (member, currentIndex) {
        return values.push([member, xValues[currentIndex]]);
      });
      normalizedPivotConfig === null || normalizedPivotConfig === void 0 || normalizedPivotConfig.y.forEach(function (member, currentIndex) {
        return values.push([member, yValues[currentIndex]]);
      });
      var _this$query = this.query(),
        _this$query$filters = _this$query.filters,
        parentFilters = _this$query$filters === void 0 ? [] : _this$query$filters,
        _this$query$segments = _this$query.segments,
        segments = _this$query$segments === void 0 ? [] : _this$query$segments;
      var measures = this.loadResponses[0].annotation.measures;
      var _ref = values.find(function (_ref3) {
          var _ref4 = _slicedToArray__default['default'](_ref3, 1),
            member = _ref4[0];
          return member === 'measures';
        }) || [],
        _ref2 = _slicedToArray__default['default'](_ref, 2),
        measureName = _ref2[1];
      if (measureName === undefined) {
        var _Object$keys = Object.keys(measures);
        var _Object$keys2 = _slicedToArray__default['default'](_Object$keys, 1);
        measureName = _Object$keys2[0];
      }
      if (!((_measures$measureName = (_measures$measureName2 = measures[measureName]) === null || _measures$measureName2 === void 0 || (_measures$measureName2 = _measures$measureName2.drillMembers) === null || _measures$measureName2 === void 0 ? void 0 : _measures$measureName2.length) !== null && _measures$measureName !== void 0 ? _measures$measureName : 0)) {
        return null;
      }
      var filters = [{
        member: measureName,
        operator: 'measureFilter'
      }].concat(_toConsumableArray__default['default'](parentFilters));
      var timeDimensions = [];
      values.filter(function (_ref5) {
        var _ref6 = _slicedToArray__default['default'](_ref5, 1),
          member = _ref6[0];
        return member !== 'measures';
      }).forEach(function (_ref7) {
        var _ref8 = _slicedToArray__default['default'](_ref7, 2),
          member = _ref8[0],
          value = _ref8[1];
        var _member$split = member.split('.'),
          _member$split2 = _slicedToArray__default['default'](_member$split, 3),
          cubeName = _member$split2[0],
          dimension = _member$split2[1],
          granularity = _member$split2[2];
        if (granularity !== undefined) {
          var _query$timeDimensions;
          var range = _dayRange(value, value).snapTo(granularity);
          var originalTimeDimension = (_query$timeDimensions = query.timeDimensions) === null || _query$timeDimensions === void 0 ? void 0 : _query$timeDimensions.find(function (td) {
            return td.dimension;
          });
          var dateRange = [range.start, range.end];
          if (originalTimeDimension !== null && originalTimeDimension !== void 0 && originalTimeDimension.dateRange) {
            var _originalTimeDimensio = _slicedToArray__default['default'](originalTimeDimension.dateRange, 2),
              originalStart = _originalTimeDimensio[0],
              originalEnd = _originalTimeDimensio[1];
            dateRange = [dayjs__default['default'](originalStart) > range.start ? dayjs__default['default'](originalStart) : range.start, dayjs__default['default'](originalEnd) < range.end ? dayjs__default['default'](originalEnd) : range.end];
          }
          timeDimensions.push({
            dimension: [cubeName, dimension].join('.'),
            dateRange: dateRange.map(function (dt) {
              return dt.format('YYYY-MM-DDTHH:mm:ss.SSS');
            })
          });
        } else if (value == null) {
          filters.push({
            member: member,
            operator: 'notSet'
          });
        } else {
          filters.push({
            member: member,
            operator: 'equals',
            values: [value.toString()]
          });
        }
      });
      if (timeDimensions.length === 0 && Array.isArray(query.timeDimensions) && query.timeDimensions.length > 0 && query.timeDimensions[0].granularity == null) {
        timeDimensions.push(query.timeDimensions[0]);
      }
      return _objectSpread$2(_objectSpread$2(_objectSpread$2({}, measures[measureName].drillMembersGrouped), {}, {
        filters: filters
      }, segments.length > 0 ? {
        segments: segments
      } : {}), {}, {
        timeDimensions: timeDimensions,
        segments: segments,
        timezone: query.timezone
      });
    }

    /**
     * Returns an array of series with key, title and series data.
     * ```js
     * // For the query
     * {
     *   measures: ['Stories.count'],
     *   timeDimensions: [{
     *     dimension: 'Stories.time',
     *     dateRange: ['2015-01-01', '2015-12-31'],
     *     granularity: 'month'
     *   }]
     * }
     *
     * // ResultSet.series() will return
     * [
     *   {
     *     key: 'Stories.count',
     *     title: 'Stories Count',
     *     shortTitle: 'Count',
     *     series: [
     *       { x: '2015-01-01T00:00:00', value: 27120 },
     *       { x: '2015-02-01T00:00:00', value: 25861 },
     *       { x: '2015-03-01T00:00:00', value: 29661 },
     *       //...
     *     ],
     *   },
     * ]
     * ```
     */
  }, {
    key: "series",
    value: function series(pivotConfig) {
      var _this = this;
      return this.seriesNames(pivotConfig).map(function (_ref9) {
        var title = _ref9.title,
          shortTitle = _ref9.shortTitle,
          key = _ref9.key;
        return {
          title: title,
          shortTitle: shortTitle,
          key: key,
          series: _this.chartPivot(pivotConfig).map(function (_ref10) {
            var x = _ref10.x,
              obj = _objectWithoutProperties__default['default'](_ref10, _excluded$1);
            return {
              value: obj[key],
              x: x
            };
          })
        };
      });
    }
  }, {
    key: "axisValues",
    value: function axisValues(axis) {
      var resultIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var query = this.loadResponses[resultIndex].query;
      return function (row) {
        var value = function value(measure) {
          return axis.filter(function (d) {
            return d !== 'measures';
          }).map(function (d) {
            var val = row[d];
            return val != null ? val : null;
          }).concat(measure ? [measure] : []);
        };
        if (axis.find(function (d) {
          return d === 'measures';
        }) && (query.measures || []).length) {
          return (query.measures || []).map(value);
        }
        return [value()];
      };
    }
  }, {
    key: "axisValuesString",
    value: function axisValuesString(axisValues) {
      var delimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ', ';
      var formatValue = function formatValue(v) {
        if (v == null) {
          return 'âˆ…';
        } else if (v === '') {
          return '[Empty string]';
        } else {
          return v;
        }
      };
      return axisValues.map(formatValue).join(delimiter);
    }
  }, {
    key: "normalizePivotConfig",
    value: function normalizePivotConfig(pivotConfig) {
      return ResultSet.getNormalizedPivotConfig(this.loadResponse.pivotQuery, pivotConfig);
    }
  }, {
    key: "timeSeries",
    value: function timeSeries(timeDimension, resultIndex, annotations) {
      if (!timeDimension.granularity) {
        return null;
      }
      var dateRange;
      dateRange = timeDimension.dateRange;
      if (!dateRange) {
        var member = ResultSet.timeDimensionMember(timeDimension);
        var rawRows = this.timeDimensionBackwardCompatibleData(resultIndex || 0);
        var dates = rawRows.map(function (row) {
          var value = row[member];
          return value ? internalDayjs(value) : null;
        }).filter(function (d) {
          return Boolean(d);
        });
        dateRange = dates.length && [ramda.reduce(ramda.minBy(function (d) {
          return d.toDate();
        }), dates[0], dates).toString(), ramda.reduce(ramda.maxBy(function (d) {
          return d.toDate();
        }), dates[0], dates).toString()] || null;
      }
      if (!dateRange) {
        return null;
      }
      var padToDay = timeDimension.dateRange ? timeDimension.dateRange.find(function (d) {
        return d.match(DateRegex);
      }) : !['hour', 'minute', 'second'].includes(timeDimension.granularity);
      var _dateRange = dateRange,
        _dateRange2 = _slicedToArray__default['default'](_dateRange, 2),
        start = _dateRange2[0],
        end = _dateRange2[1];
      var range = _dayRange(start, end);
      if (isPredefinedGranularity(timeDimension.granularity)) {
        return TIME_SERIES[timeDimension.granularity](padToDay ? range.snapTo('d') : range);
      }
      if (!(annotations !== null && annotations !== void 0 && annotations["".concat(timeDimension.dimension, ".").concat(timeDimension.granularity)])) {
        throw new Error("Granularity \"".concat(timeDimension.granularity, "\" not found in time dimension \"").concat(timeDimension.dimension, "\""));
      }
      return timeSeriesFromCustomInterval(start, end, annotations["".concat(timeDimension.dimension, ".").concat(timeDimension.granularity)].granularity);
    }

    /**
     * Base method for pivoting [ResultSet](#result-set) data.
     * Most of the time shouldn't be used directly and [chartPivot](#result-set-chart-pivot)
     * or [tablePivot](#table-pivot) should be used instead.
     *
     * You can find the examples of using the `pivotConfig` [here](#types-pivot-config)
     * ```js
     * // For query
     * {
     *   measures: ['Stories.count'],
     *   timeDimensions: [{
     *     dimension: 'Stories.time',
     *     dateRange: ['2015-01-01', '2015-03-31'],
     *     granularity: 'month'
     *   }]
     * }
     *
     * // ResultSet.pivot({ x: ['Stories.time'], y: ['measures'] }) will return
     * [
     *   {
     *     xValues: ["2015-01-01T00:00:00"],
     *     yValuesArray: [
     *       [['Stories.count'], 27120]
     *     ]
     *   },
     *   {
     *     xValues: ["2015-02-01T00:00:00"],
     *     yValuesArray: [
     *       [['Stories.count'], 25861]
     *     ]
     *   },
     *   {
     *     xValues: ["2015-03-01T00:00:00"],
     *     yValuesArray: [
     *       [['Stories.count'], 29661]
     *     ]
     *   }
     * ]
     * ```
     * @returns An array of pivoted rows.
     */
  }, {
    key: "pivot",
    value: function pivot(pivotConfig) {
      var _this2 = this;
      var normalizedPivotConfig = this.normalizePivotConfig(pivotConfig);
      var query = this.loadResponse.pivotQuery;
      var pivotImpl = function pivotImpl() {
        var resultIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var groupByXAxis = groupByToPairs(function (_ref11) {
          var xValues = _ref11.xValues;
          return _this2.axisValuesString(xValues);
        });
        var measureValue = function measureValue(row, measure) {
          return row[measure] || normalizedPivotConfig.fillWithValue || 0;
        };
        if (normalizedPivotConfig.fillMissingDates && normalizedPivotConfig.x.length === 1 && ramda.equals(normalizedPivotConfig.x, (query.timeDimensions || []).filter(function (td) {
          return Boolean(td.granularity);
        }).map(function (td) {
          return ResultSet.timeDimensionMember(td);
        }))) {
          var series = _this2.loadResponses.map(function (loadResponse) {
            return _this2.timeSeries(loadResponse.query.timeDimensions[0], resultIndex, loadResponse.annotation.timeDimensions);
          });
          if (series[0]) {
            groupByXAxis = function groupByXAxis(rows) {
              var _series$resultIndex$m, _series$resultIndex;
              var byXValues = ramda.groupBy(function (_ref12) {
                var xValues = _ref12.xValues;
                return xValues[0];
              }, rows);
              return (_series$resultIndex$m = (_series$resultIndex = series[resultIndex]) === null || _series$resultIndex === void 0 ? void 0 : _series$resultIndex.map(function (d) {
                return [d, byXValues[d] || [{
                  xValues: [d],
                  row: {}
                }]];
              })) !== null && _series$resultIndex$m !== void 0 ? _series$resultIndex$m : [];
            };
          }
        }
        var xGrouped = ramda.pipe(ramda.map(function (row) {
          return _this2.axisValues(normalizedPivotConfig.x, resultIndex)(row).map(function (xValues) {
            return {
              xValues: xValues,
              row: row
            };
          });
        }), unnest, groupByXAxis)(_this2.timeDimensionBackwardCompatibleData(resultIndex));
        var yValuesMap = {};
        xGrouped.forEach(function (_ref13) {
          var _ref14 = _slicedToArray__default['default'](_ref13, 2),
            rows = _ref14[1];
          rows.forEach(function (_ref15) {
            var row = _ref15.row;
            _this2.axisValues(normalizedPivotConfig.y, resultIndex)(row).forEach(function (values) {
              if (Object.keys(row).length > 0) {
                yValuesMap[values.join()] = values;
              }
            });
          });
        });
        var allYValues = Object.values(yValuesMap);
        var measureOnX = Boolean(normalizedPivotConfig.x.find(function (d) {
          return d === 'measures';
        }));
        return xGrouped.map(function (_ref16) {
          var _ref17 = _slicedToArray__default['default'](_ref16, 2),
            rows = _ref17[1];
          var xValues = rows[0].xValues;
          var yGrouped = {};
          rows.forEach(function (_ref18) {
            var row = _ref18.row;
            var arr = _this2.axisValues(normalizedPivotConfig.y, resultIndex)(row).map(function (yValues) {
              return {
                yValues: yValues,
                row: row
              };
            });
            arr.forEach(function (res) {
              yGrouped[_this2.axisValuesString(res.yValues)] = res;
            });
          });
          return {
            xValues: xValues,
            yValuesArray: unnest(allYValues.map(function (yValues) {
              var measure = measureOnX ? ResultSet.measureFromAxis(xValues) : ResultSet.measureFromAxis(yValues);
              return [[yValues, measureValue((yGrouped[_this2.axisValuesString(yValues)] || {
                row: {}
              }).row, measure)]];
            }))
          };
        });
      };
      var pivots = this.loadResponses.length > 1 ? this.loadResponses.map(function (_, index) {
        return pivotImpl(index);
      }) : [];
      return pivots.length ? this.mergePivots(pivots, normalizedPivotConfig.joinDateRange || false) : pivotImpl();
    }
  }, {
    key: "mergePivots",
    value: function mergePivots(pivots, joinDateRange) {
      var minLengthPivot = pivots.reduce(function (memo, current) {
        return memo != null && current.length >= memo.length ? memo : current;
      }, null) || [];
      return minLengthPivot.map(function (_, index) {
        var xValues = joinDateRange ? [pivots.map(function (pivot) {
          var _pivot$index;
          return ((_pivot$index = pivot[index]) === null || _pivot$index === void 0 ? void 0 : _pivot$index.xValues) || [];
        }).join(', ')] : minLengthPivot[index].xValues;
        return {
          xValues: xValues,
          yValuesArray: unnest(pivots.map(function (pivot) {
            return pivot[index].yValuesArray;
          }))
        };
      });
    }

    /**
     * Returns normalized query result data in the following format.
     *
     * You can find the examples of using the `pivotConfig` [here](#types-pivot-config)
     * ```js
     * // For the query
     * {
     *   measures: ['Stories.count'],
     *   timeDimensions: [{
     *     dimension: 'Stories.time',
     *     dateRange: ['2015-01-01', '2015-12-31'],
     *     granularity: 'month'
     *   }]
     * }
     *
     * // ResultSet.chartPivot() will return
     * [
     *   { "x":"2015-01-01T00:00:00", "Stories.count": 27120, "xValues": ["2015-01-01T00:00:00"] },
     *   { "x":"2015-02-01T00:00:00", "Stories.count": 25861, "xValues": ["2015-02-01T00:00:00"]  },
     *   { "x":"2015-03-01T00:00:00", "Stories.count": 29661, "xValues": ["2015-03-01T00:00:00"]  },
     *   //...
     * ]
     *
     * ```
     * When using `chartPivot()` or `seriesNames()`, you can pass `aliasSeries` in the [pivotConfig](#types-pivot-config)
     * to give each series a unique prefix. This is useful for `blending queries` which use the same measure multiple times.
     *
     * ```js
     * // For the queries
     * {
     *   measures: ['Stories.count'],
     *   timeDimensions: [
     *     {
     *       dimension: 'Stories.time',
     *       dateRange: ['2015-01-01', '2015-12-31'],
     *       granularity: 'month',
     *     },
     *   ],
     * },
     * {
     *   measures: ['Stories.count'],
     *   timeDimensions: [
     *     {
     *       dimension: 'Stories.time',
     *       dateRange: ['2015-01-01', '2015-12-31'],
     *       granularity: 'month',
     *     },
     *   ],
     *   filters: [
     *     {
     *       member: 'Stores.read',
     *       operator: 'equals',
     *       value: ['true'],
     *     },
     *   ],
     * },
     *
     * // ResultSet.chartPivot({ aliasSeries: ['one', 'two'] }) will return
     * [
     *   {
     *     x: '2015-01-01T00:00:00',
     *     'one,Stories.count': 27120,
     *     'two,Stories.count': 8933,
     *     xValues: ['2015-01-01T00:00:00'],
     *   },
     *   {
     *     x: '2015-02-01T00:00:00',
     *     'one,Stories.count': 25861,
     *     'two,Stories.count': 8344,
     *     xValues: ['2015-02-01T00:00:00'],
     *   },
     *   {
     *     x: '2015-03-01T00:00:00',
     *     'one,Stories.count': 29661,
     *     'two,Stories.count': 9023,
     *     xValues: ['2015-03-01T00:00:00'],
     *   },
     *   //...
     * ]
     * ```
     */
  }, {
    key: "chartPivot",
    value: function chartPivot(pivotConfig) {
      var _this3 = this;
      var validate = function validate(value) {
        if (_this3.parseDateMeasures && LocalDateRegex.test(value)) {
          return new Date(value);
        } else if (!Number.isNaN(Number.parseFloat(value))) {
          return Number.parseFloat(value);
        }
        return value;
      };
      var duplicateMeasures = new Set();
      if (this.queryType === QUERY_TYPE.BLENDING_QUERY) {
        var allMeasures = ramda.flatten(this.loadResponses.map(function (_ref19) {
          var _query$measures;
          var query = _ref19.query;
          return (_query$measures = query.measures) !== null && _query$measures !== void 0 ? _query$measures : [];
        }));
        allMeasures.filter(function (e, i, a) {
          return a.indexOf(e) !== i;
        }).forEach(function (m) {
          return duplicateMeasures.add(m);
        });
      }
      return this.pivot(pivotConfig).map(function (_ref20) {
        var xValues = _ref20.xValues,
          yValuesArray = _ref20.yValuesArray;
        var yValuesMap = {};
        yValuesArray.forEach(function (_ref21, i) {
          var _ref22 = _slicedToArray__default['default'](_ref21, 2),
            yValues = _ref22[0],
            m = _ref22[1];
          yValuesMap[_this3.axisValuesString(aliasSeries(yValues, i, pivotConfig, duplicateMeasures), ',')] = m && validate(m);
        });
        return _objectSpread$2({
          x: _this3.axisValuesString(xValues, ','),
          xValues: xValues
        }, yValuesMap);
      });
    }

    /**
     * Returns normalized query result data prepared for visualization in the table format.
     *
     * You can find the examples of using the `pivotConfig` [here](#types-pivot-config)
     *
     * For example:
     * ```js
     * // For the query
     * {
     *   measures: ['Stories.count'],
     *   timeDimensions: [{
     *     dimension: 'Stories.time',
     *     dateRange: ['2015-01-01', '2015-12-31'],
     *     granularity: 'month'
     *   }]
     * }
     *
     * // ResultSet.tablePivot() will return
     * [
     *   { "Stories.time": "2015-01-01T00:00:00", "Stories.count": 27120 },
     *   { "Stories.time": "2015-02-01T00:00:00", "Stories.count": 25861 },
     *   { "Stories.time": "2015-03-01T00:00:00", "Stories.count": 29661 },
     *   //...
     * ]
     * ```
     * @returns An array of pivoted rows
     */
  }, {
    key: "tablePivot",
    value: function tablePivot(pivotConfig) {
      var normalizedPivotConfig = this.normalizePivotConfig(pivotConfig || {});
      var isMeasuresPresent = normalizedPivotConfig.x.concat(normalizedPivotConfig.y).includes('measures');
      return this.pivot(normalizedPivotConfig).map(function (_ref23) {
        var xValues = _ref23.xValues,
          yValuesArray = _ref23.yValuesArray;
        return ramda.fromPairs([].concat(_toConsumableArray__default['default'](normalizedPivotConfig.x.map(function (key, index) {
          var _xValues$index;
          return [key, (_xValues$index = xValues[index]) !== null && _xValues$index !== void 0 ? _xValues$index : ''];
        })), _toConsumableArray__default['default'](isMeasuresPresent ? yValuesArray.map(function (_ref24) {
          var _ref25 = _slicedToArray__default['default'](_ref24, 2),
            yValues = _ref25[0],
            measure = _ref25[1];
          return [yValues.length ? yValues.join() : 'value', measure];
        }) : [])));
      });
    }

    /**
     * Returns an array of column definitions for `tablePivot`.
     *
     * For example:
     * ```js
     * // For the query
     * {
     *   measures: ['Stories.count'],
     *   timeDimensions: [{
     *     dimension: 'Stories.time',
     *     dateRange: ['2015-01-01', '2015-12-31'],
     *     granularity: 'month'
     *   }]
     * }
     *
     * // ResultSet.tableColumns() will return
     * [
     *   {
     *     key: 'Stories.time',
     *     dataIndex: 'Stories.time',
     *     title: 'Stories Time',
     *     shortTitle: 'Time',
     *     type: 'time',
     *     format: undefined,
     *   },
     *   {
     *     key: 'Stories.count',
     *     dataIndex: 'Stories.count',
     *     title: 'Stories Count',
     *     shortTitle: 'Count',
     *     type: 'count',
     *     format: undefined,
     *   },
     *   //...
     * ]
     * ```
     *
     * In case we want to pivot the table axes
     * ```js
     * // Let's take this query as an example
     * {
     *   measures: ['Orders.count'],
     *   dimensions: ['Users.country', 'Users.gender']
     * }
     *
     * // and put the dimensions on `y` axis
     * resultSet.tableColumns({
     *   x: [],
     *   y: ['Users.country', 'Users.gender', 'measures']
     * })
     * ```
     *
     * then `tableColumns` will group the table head and return
     * ```js
     * {
     *   key: 'Germany',
     *   type: 'string',
     *   title: 'Users Country Germany',
     *   shortTitle: 'Germany',
     *   meta: undefined,
     *   format: undefined,
     *   children: [
     *     {
     *       key: 'male',
     *       type: 'string',
     *       title: 'Users Gender male',
     *       shortTitle: 'male',
     *       meta: undefined,
     *       format: undefined,
     *       children: [
     *         {
     *           // ...
     *           dataIndex: 'Germany.male.Orders.count',
     *           shortTitle: 'Count',
     *         },
     *       ],
     *     },
     *     {
     *       // ...
     *       shortTitle: 'female',
     *       children: [
     *         {
     *           // ...
     *           dataIndex: 'Germany.female.Orders.count',
     *           shortTitle: 'Count',
     *         },
     *       ],
     *     },
     *   ],
     * },
     * // ...
     * ```
     * @returns An array of columns
     */
  }, {
    key: "tableColumns",
    value: function tableColumns(pivotConfig) {
      var _pivot$;
      var normalizedPivotConfig = this.normalizePivotConfig(pivotConfig || {});
      var annotations = this.loadResponses.map(function (r) {
        return r.annotation;
      }).reduce(function (acc, annotation) {
        return ramda.mergeDeepLeft(acc, annotation);
      }, {
        dimensions: {},
        measures: {},
        timeDimensions: {},
        segments: {}
      });
      var flatMeta = Object.values(annotations).reduce(function (a, b) {
        return _objectSpread$2(_objectSpread$2({}, a), b);
      }, {});
      var schema = {};
      var extractFields = function extractFields(key) {
        var _ref26 = flatMeta[key] || {},
          title = _ref26.title,
          shortTitle = _ref26.shortTitle,
          type = _ref26.type,
          format = _ref26.format,
          meta = _ref26.meta;
        return {
          key: key,
          title: title,
          shortTitle: shortTitle,
          type: type,
          format: format,
          meta: meta
        };
      };
      var pivot = this.pivot(normalizedPivotConfig);
      (((_pivot$ = pivot[0]) === null || _pivot$ === void 0 ? void 0 : _pivot$.yValuesArray) || []).forEach(function (_ref27) {
        var _ref28 = _slicedToArray__default['default'](_ref27, 1),
          yValues = _ref28[0];
        if (yValues.length > 0) {
          var currentItem = schema;
          yValues.forEach(function (value, index) {
            var _currentItem;
            currentItem["_".concat(value)] = {
              key: value,
              memberId: normalizedPivotConfig.y[index] === 'measures' ? value : normalizedPivotConfig.y[index],
              children: ((_currentItem = currentItem["_".concat(value)]) === null || _currentItem === void 0 ? void 0 : _currentItem.children) || {}
            };
            currentItem = currentItem["_".concat(value)].children;
          });
        }
      });
      var _toColumns = function toColumns() {
        var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        if (Object.keys(item).length === 0) {
          return [];
        }
        return Object.values(item).map(function (_ref29) {
          var key = _ref29.key,
            currentItem = _objectWithoutProperties__default['default'](_ref29, _excluded2);
          var children = _toColumns(currentItem.children, [].concat(_toConsumableArray__default['default'](path), [key]));
          var _extractFields = extractFields(currentItem.memberId),
            title = _extractFields.title,
            shortTitle = _extractFields.shortTitle,
            fields = _objectWithoutProperties__default['default'](_extractFields, _excluded3);
          var dimensionValue = key !== currentItem.memberId || title == null ? key : '';
          if (!children.length) {
            return _objectSpread$2(_objectSpread$2({}, fields), {}, {
              key: key,
              dataIndex: [].concat(_toConsumableArray__default['default'](path), [key]).join(),
              title: [title, dimensionValue].join(' ').trim(),
              shortTitle: dimensionValue || shortTitle
            });
          }
          return _objectSpread$2(_objectSpread$2({}, fields), {}, {
            key: key,
            title: [title, dimensionValue].join(' ').trim(),
            shortTitle: dimensionValue || shortTitle,
            children: children
          });
        });
      };
      var otherColumns = [];
      if (!pivot.length && normalizedPivotConfig.y.includes('measures')) {
        otherColumns = (this.loadResponses[0].query.measures || []).map(function (key) {
          return _objectSpread$2(_objectSpread$2({}, extractFields(key)), {}, {
            dataIndex: key
          });
        });
      }

      // Synthetic column to display the measure value
      if (!normalizedPivotConfig.y.length && normalizedPivotConfig.x.includes('measures')) {
        otherColumns.push({
          key: 'value',
          dataIndex: 'value',
          title: 'Value',
          shortTitle: 'Value',
          type: 'string'
        });
      }
      return normalizedPivotConfig.x.map(function (key) {
        if (key === 'measures') {
          return {
            key: 'measures',
            dataIndex: 'measures',
            title: 'Measures',
            shortTitle: 'Measures',
            type: 'string'
          };
        }
        return _objectSpread$2(_objectSpread$2({}, extractFields(key)), {}, {
          dataIndex: key
        });
      }).concat(_toColumns(schema)).concat(otherColumns);
    }
  }, {
    key: "totalRow",
    value: function totalRow(pivotConfig) {
      return this.chartPivot(pivotConfig)[0];
    }
  }, {
    key: "categories",
    value: function categories(pivotConfig) {
      return this.chartPivot(pivotConfig);
    }

    /**
     * Returns an array of series objects, containing `key` and `title` parameters.
     * ```js
     * // For query
     * {
     *   measures: ['Stories.count'],
     *   timeDimensions: [{
     *     dimension: 'Stories.time',
     *     dateRange: ['2015-01-01', '2015-12-31'],
     *     granularity: 'month'
     *   }]
     * }
     *
     * // ResultSet.seriesNames() will return
     * [
     *   {
     *     key: 'Stories.count',
     *     title: 'Stories Count',
     *     shortTitle: 'Count',
     *     yValues: ['Stories.count'],
     *   },
     * ]
     * ```
     * @returns An array of series names
     */
  }, {
    key: "seriesNames",
    value: function seriesNames(pivotConfig) {
      var _this4 = this;
      var normalizedPivotConfig = this.normalizePivotConfig(pivotConfig);
      var measures = this.loadResponses.map(function (r) {
        return r.annotation.measures;
      }).reduce(function (acc, m) {
        return _objectSpread$2(_objectSpread$2({}, acc), m);
      }, {});
      var seriesNames = unnest(this.loadResponses.map(function (_, index) {
        return ramda.pipe(ramda.map(_this4.axisValues(normalizedPivotConfig.y, index)), unnest, ramda.uniq)(_this4.timeDimensionBackwardCompatibleData(index));
      }));
      var duplicateMeasures = new Set();
      if (this.queryType === QUERY_TYPE.BLENDING_QUERY) {
        var allMeasures = ramda.flatten(this.loadResponses.map(function (_ref30) {
          var _query$measures2;
          var query = _ref30.query;
          return (_query$measures2 = query.measures) !== null && _query$measures2 !== void 0 ? _query$measures2 : [];
        }));
        allMeasures.filter(function (e, i, a) {
          return a.indexOf(e) !== i;
        }).forEach(function (m) {
          return duplicateMeasures.add(m);
        });
      }
      return seriesNames.map(function (axisValues, i) {
        var aliasedAxis = aliasSeries(axisValues, i, normalizedPivotConfig, duplicateMeasures);
        return {
          title: _this4.axisValuesString(normalizedPivotConfig.y.find(function (d) {
            return d === 'measures';
          }) ? ramda.dropLast(1, aliasedAxis).concat(measures[ResultSet.measureFromAxis(axisValues)].title) : aliasedAxis, ', '),
          shortTitle: _this4.axisValuesString(normalizedPivotConfig.y.find(function (d) {
            return d === 'measures';
          }) ? ramda.dropLast(1, aliasedAxis).concat(measures[ResultSet.measureFromAxis(axisValues)].shortTitle) : aliasedAxis, ', '),
          key: _this4.axisValuesString(aliasedAxis, ','),
          yValues: axisValues
        };
      });
    }
  }, {
    key: "query",
    value: function query() {
      if (this.queryType !== QUERY_TYPE.REGULAR_QUERY) {
        throw new Error("Method is not supported for a '".concat(this.queryType, "' query type. Please use decompose"));
      }
      return this.loadResponses[0].query;
    }
  }, {
    key: "pivotQuery",
    value: function pivotQuery() {
      return this.loadResponse.pivotQuery || null;
    }

    /**
     * @return the total number of rows if the `total` option was set, when sending the query
     */
  }, {
    key: "totalRows",
    value: function totalRows() {
      return this.loadResponses[0].total;
    }
  }, {
    key: "rawData",
    value: function rawData() {
      if (this.queryType !== QUERY_TYPE.REGULAR_QUERY) {
        throw new Error("Method is not supported for a '".concat(this.queryType, "' query type. Please use decompose"));
      }
      return this.loadResponses[0].data;
    }
  }, {
    key: "annotation",
    value: function annotation() {
      if (this.queryType !== QUERY_TYPE.REGULAR_QUERY) {
        throw new Error("Method is not supported for a '".concat(this.queryType, "' query type. Please use decompose"));
      }
      return this.loadResponses[0].annotation;
    }
  }, {
    key: "timeDimensionBackwardCompatibleData",
    value: function timeDimensionBackwardCompatibleData(resultIndex) {
      if (resultIndex === undefined) {
        throw new Error('resultIndex is required');
      }
      if (!this.backwardCompatibleData[resultIndex]) {
        var _this$loadResponses$r = this.loadResponses[resultIndex],
          data = _this$loadResponses$r.data,
          query = _this$loadResponses$r.query;
        var timeDimensions = (query.timeDimensions || []).filter(function (td) {
          return Boolean(td.granularity);
        });
        this.backwardCompatibleData[resultIndex] = data.map(function (row) {
          return _objectSpread$2(_objectSpread$2({}, row), ramda.fromPairs(Object.keys(row).filter(function (field) {
            var foundTd = timeDimensions.find(function (d) {
              return d.dimension === field;
            });
            return foundTd && !row[ResultSet.timeDimensionMember(foundTd)];
          }).map(function (field) {
            return [ResultSet.timeDimensionMember(timeDimensions.find(function (d) {
              return d.dimension === field;
            })), row[field]];
          })));
        });
      }
      return this.backwardCompatibleData[resultIndex];
    }

    /**
     * Can be used when you need access to the methods that can't be used with some query types (eg `compareDateRangeQuery` or `blendingQuery`)
     * ```js
     * resultSet.decompose().forEach((currentResultSet) => {
     *   console.log(currentResultSet.rawData());
     * });
     * ```
     */
  }, {
    key: "decompose",
    value: function decompose() {
      var _this5 = this;
      return this.loadResponses.map(function (result) {
        return new ResultSet({
          queryType: QUERY_TYPE.REGULAR_QUERY,
          pivotQuery: _objectSpread$2(_objectSpread$2({}, result.query), {}, {
            queryType: QUERY_TYPE.REGULAR_QUERY
          }),
          results: [result]
        }, _this5.options);
      });
    }

    /**
     * Can be used to stash the `ResultSet` in a storage and restored later with [deserialize](#result-set-deserialize)
     */
  }, {
    key: "serialize",
    value: function serialize() {
      return {
        loadResponse: ramda.clone(this.loadResponse)
      };
    }
  }], [{
    key: "measureFromAxis",
    value: function measureFromAxis(axisValues) {
      return axisValues[axisValues.length - 1];
    }
  }, {
    key: "timeDimensionMember",
    value: function timeDimensionMember(td) {
      return "".concat(td.dimension, ".").concat(td.granularity);
    }

    /**
     * ```js
     * import { ResultSet } from '@cubejs-client/core';
     *
     * const resultSet = await cubeApi.load(query);
     * // You can store the result somewhere
     * const tmp = resultSet.serialize();
     *
     * // and restore it later
     * const resultSet = ResultSet.deserialize(tmp);
     * ```
     * @param data the result of [serialize](#result-set-serialize)
     * @param options
     */
  }, {
    key: "deserialize",
    value: function deserialize(data, options) {
      return new ResultSet(data.loadResponse, options);
    }
  }, {
    key: "getNormalizedPivotConfig",
    value: function getNormalizedPivotConfig(query, pivotConfig) {
      var defaultPivotConfig = {
        x: [],
        y: [],
        fillMissingDates: true,
        joinDateRange: false
      };
      var _ref31 = query || {},
        _ref31$measures = _ref31.measures,
        measures = _ref31$measures === void 0 ? [] : _ref31$measures,
        _ref31$dimensions = _ref31.dimensions,
        dimensions = _ref31$dimensions === void 0 ? [] : _ref31$dimensions;
      var timeDimensions = ((query === null || query === void 0 ? void 0 : query.timeDimensions) || []).filter(function (td) {
        return !!td.granularity;
      });
      pivotConfig = pivotConfig || (timeDimensions.length ? {
        x: timeDimensions.map(function (td) {
          return ResultSet.timeDimensionMember(td);
        }),
        y: dimensions
      } : {
        x: dimensions,
        y: []
      });
      var normalizedPivotConfig = ramda.mergeDeepLeft(pivotConfig, defaultPivotConfig);
      var substituteTimeDimensionMembers = function substituteTimeDimensionMembers(axis) {
        return axis.map(function (subDim) {
          return timeDimensions.find(function (td) {
            return td.dimension === subDim;
          }) && !dimensions.find(function (d) {
            return d === subDim;
          }) ? ResultSet.timeDimensionMember(((query === null || query === void 0 ? void 0 : query.timeDimensions) || []).find(function (td) {
            return td.dimension === subDim;
          })) : subDim;
        });
      };
      normalizedPivotConfig.x = substituteTimeDimensionMembers(normalizedPivotConfig.x);
      normalizedPivotConfig.y = substituteTimeDimensionMembers(normalizedPivotConfig.y);
      var allIncludedDimensions = normalizedPivotConfig.x.concat(normalizedPivotConfig.y);
      var allDimensions = timeDimensions.map(function (td) {
        return ResultSet.timeDimensionMember(td);
      }).concat(dimensions);
      var dimensionFilter = function dimensionFilter(key) {
        return allDimensions.includes(key) || key === 'measures';
      };
      normalizedPivotConfig.x = normalizedPivotConfig.x.concat(allDimensions.filter(function (d) {
        return !allIncludedDimensions.includes(d) && d !== 'compareDateRange';
      })).filter(dimensionFilter);
      normalizedPivotConfig.y = normalizedPivotConfig.y.filter(dimensionFilter);
      if (!normalizedPivotConfig.x.concat(normalizedPivotConfig.y).find(function (d) {
        return d === 'measures';
      })) {
        normalizedPivotConfig.y.push('measures');
      }
      if (dimensions.includes('compareDateRange') && !normalizedPivotConfig.y.concat(normalizedPivotConfig.x).includes('compareDateRange')) {
        normalizedPivotConfig.y.unshift('compareDateRange');
      }
      if (!measures.length) {
        normalizedPivotConfig.x = normalizedPivotConfig.x.filter(function (d) {
          return d !== 'measures';
        });
        normalizedPivotConfig.y = normalizedPivotConfig.y.filter(function (d) {
          return d !== 'measures';
        });
      }
      return normalizedPivotConfig;
    }
  }]);
}();

var SqlQuery = /*#__PURE__*/function () {
  function SqlQuery(sqlQuery) {
    _classCallCheck__default['default'](this, SqlQuery);
    _defineProperty__default['default'](this, "sqlQuery", void 0);
    this.sqlQuery = sqlQuery;
  }
  return _createClass__default['default'](SqlQuery, [{
    key: "rawQuery",
    value: function rawQuery() {
      return this.sqlQuery.sql;
    }
  }, {
    key: "sql",
    value: function sql() {
      return this.rawQuery().sql[0];
    }
  }]);
}();

var memberMap = function memberMap(memberArray) {
  return ramda.fromPairs(memberArray.map(function (m) {
    return [m.name, m];
  }));
};
var operators = {
  string: [{
    name: 'contains',
    title: 'contains'
  }, {
    name: 'notContains',
    title: 'does not contain'
  }, {
    name: 'equals',
    title: 'equals'
  }, {
    name: 'notEquals',
    title: 'does not equal'
  }, {
    name: 'set',
    title: 'is set'
  }, {
    name: 'notSet',
    title: 'is not set'
  }, {
    name: 'startsWith',
    title: 'starts with'
  }, {
    name: 'notStartsWith',
    title: 'does not start with'
  }, {
    name: 'endsWith',
    title: 'ends with'
  }, {
    name: 'notEndsWith',
    title: 'does not end with'
  }],
  number: [{
    name: 'equals',
    title: 'equals'
  }, {
    name: 'notEquals',
    title: 'does not equal'
  }, {
    name: 'set',
    title: 'is set'
  }, {
    name: 'notSet',
    title: 'is not set'
  }, {
    name: 'gt',
    title: '>'
  }, {
    name: 'gte',
    title: '>='
  }, {
    name: 'lt',
    title: '<'
  }, {
    name: 'lte',
    title: '<='
  }],
  time: [{
    name: 'equals',
    title: 'equals'
  }, {
    name: 'notEquals',
    title: 'does not equal'
  }, {
    name: 'inDateRange',
    title: 'in date range'
  }, {
    name: 'notInDateRange',
    title: 'not in date range'
  }, {
    name: 'afterDate',
    title: 'after date'
  }, {
    name: 'afterOrOnDate',
    title: 'after or on date'
  }, {
    name: 'beforeDate',
    title: 'before date'
  }, {
    name: 'beforeOrOnDate',
    title: 'before or on date'
  }]
};

/**
 * Contains information about available cubes and it's members.
 */
var Meta = /*#__PURE__*/function () {
  function Meta(metaResponse) {
    _classCallCheck__default['default'](this, Meta);
    /**
     * Raw meta response
     */
    _defineProperty__default['default'](this, "meta", void 0);
    /**
     * An array of all available cubes with their members
     */
    _defineProperty__default['default'](this, "cubes", void 0);
    /**
     * A map of all cubes where the key is a cube name
     */
    _defineProperty__default['default'](this, "cubesMap", void 0);
    this.meta = metaResponse;
    var cubes = this.meta.cubes;
    this.cubes = cubes;
    this.cubesMap = ramda.fromPairs(cubes.map(function (c) {
      return [c.name, {
        measures: memberMap(c.measures),
        dimensions: memberMap(c.dimensions),
        segments: memberMap(c.segments)
      }];
    }));
  }

  /**
   * Get all members of a specific type for a given query.
   * If empty query is provided no filtering is done based on query context and all available members are retrieved.
   * @param _query - context query to provide filtering of members available to add to this query
   * @param memberType
   */
  return _createClass__default['default'](Meta, [{
    key: "membersForQuery",
    value: function membersForQuery(_query, memberType) {
      return ramda.unnest(this.cubes.map(function (c) {
        return c[memberType];
      })).sort(function (a, b) {
        return a.title > b.title ? 1 : -1;
      });
    }
  }, {
    key: "membersGroupedByCube",
    value: function membersGroupedByCube() {
      var memberKeys = ['measures', 'dimensions', 'segments', 'timeDimensions'];
      return this.cubes.reduce(function (memo, cube) {
        memberKeys.forEach(function (key) {
          var members = [];

          // eslint-disable-next-line default-case
          switch (key) {
            case 'measures':
              members = cube.measures || [];
              break;
            case 'dimensions':
              members = cube.dimensions || [];
              break;
            case 'segments':
              members = cube.segments || [];
              break;
            case 'timeDimensions':
              members = cube.dimensions.filter(function (m) {
                return m.type === 'time';
              }) || [];
              break;
          }

          // TODO: Convince TS this is working
          // @ts-ignore
          memo[key].push({
            cubeName: cube.name,
            cubeTitle: cube.title,
            type: cube.type,
            "public": cube["public"],
            members: members
          });
        });
        return memo;
      }, {
        measures: [],
        dimensions: [],
        segments: [],
        timeDimensions: []
      });
    }

    /**
     * Get meta information for a cube member
     * meta information contains:
     * ```javascript
     * {
     *   name,
     *   title,
     *   shortTitle,
     *   type,
     *   description,
     *   format
     * }
     * ```
     * @param memberName - Fully qualified member name in a form `Cube.memberName`
     * @param memberType
     * @return An object containing meta information about member
     */
  }, {
    key: "resolveMember",
    value: function resolveMember(memberName, memberType) {
      var _this = this;
      var _memberName$split = memberName.split('.'),
        _memberName$split2 = _slicedToArray__default['default'](_memberName$split, 1),
        cube = _memberName$split2[0];
      if (!this.cubesMap[cube]) {
        return {
          title: memberName,
          error: "Cube not found ".concat(cube, " for path '").concat(memberName, "'")
        };
      }
      var memberTypes = Array.isArray(memberType) ? memberType : [memberType];
      var member = memberTypes.map(function (type) {
        return _this.cubesMap[cube][type] && _this.cubesMap[cube][type][memberName];
      }).find(function (m) {
        return m;
      });
      if (!member) {
        return {
          title: memberName,
          error: "Path not found '".concat(memberName, "'")
        };
      }
      return member;
    }
  }, {
    key: "defaultTimeDimensionNameFor",
    value: function defaultTimeDimensionNameFor(memberName) {
      var _this2 = this;
      var _memberName$split3 = memberName.split('.'),
        _memberName$split4 = _slicedToArray__default['default'](_memberName$split3, 1),
        cube = _memberName$split4[0];
      if (!this.cubesMap[cube]) {
        return null;
      }
      return Object.keys(this.cubesMap[cube].dimensions || {}).find(function (d) {
        return _this2.cubesMap[cube].dimensions[d].type === 'time';
      });
    }
  }, {
    key: "filterOperatorsForMember",
    value: function filterOperatorsForMember(memberName, memberType) {
      var member = this.resolveMember(memberName, memberType);
      if ('error' in member || !('type' in member) || member.type === 'boolean') {
        return operators.string;
      }
      return operators[member.type] || operators.string;
    }
  }]);
}();

var ProgressResult = /*#__PURE__*/function () {
  function ProgressResult(progressResponse) {
    _classCallCheck__default['default'](this, ProgressResult);
    _defineProperty__default['default'](this, "progressResponse", void 0);
    this.progressResponse = progressResponse;
  }
  return _createClass__default['default'](ProgressResult, [{
    key: "stage",
    value: function stage() {
      return this.progressResponse.stage;
    }
  }, {
    key: "timeElapsed",
    value: function timeElapsed() {
      return this.progressResponse.timeElapsed;
    }
  }]);
}();

var _excluded = ["baseRequestId", "signal"];
function ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty__default['default'](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/**
 * Default transport implementation.
 */
var HttpTransport = /*#__PURE__*/function () {
  function HttpTransport(_ref) {
    var authorization = _ref.authorization,
      apiUrl = _ref.apiUrl,
      method = _ref.method,
      _ref$headers = _ref.headers,
      headers = _ref$headers === void 0 ? {} : _ref$headers,
      credentials = _ref.credentials,
      fetchTimeout = _ref.fetchTimeout,
      signal = _ref.signal;
    _classCallCheck__default['default'](this, HttpTransport);
    _defineProperty__default['default'](this, "authorization", void 0);
    _defineProperty__default['default'](this, "apiUrl", void 0);
    _defineProperty__default['default'](this, "method", void 0);
    _defineProperty__default['default'](this, "headers", void 0);
    _defineProperty__default['default'](this, "credentials", void 0);
    _defineProperty__default['default'](this, "fetchTimeout", void 0);
    _defineProperty__default['default'](this, "signal", void 0);
    this.authorization = authorization;
    this.apiUrl = apiUrl;
    this.method = method;
    this.headers = headers;
    this.credentials = credentials;
    this.fetchTimeout = fetchTimeout;
    this.signal = signal;
  }
  return _createClass__default['default'](HttpTransport, [{
    key: "request",
    value: function request(method, _ref2) {
      var _this = this;
      var baseRequestId = _ref2.baseRequestId,
        signal = _ref2.signal,
        params = _objectWithoutProperties__default['default'](_ref2, _excluded);
      var spanCounter = 1;
      var searchParams = new URLSearchParams(params && Object.keys(params).map(function (k) {
        return _defineProperty__default['default']({}, k, _typeof__default['default'](params[k]) === 'object' ? JSON.stringify(params[k]) : params[k]);
      }).reduce(function (a, b) {
        return _objectSpread$1(_objectSpread$1({}, a), b);
      }, {}));
      var url = "".concat(this.apiUrl, "/").concat(method).concat(searchParams.toString().length ? "?".concat(searchParams) : '');
      var requestMethod = this.method || (url.length < 2000 ? 'GET' : 'POST');
      if (requestMethod === 'POST') {
        url = "".concat(this.apiUrl, "/").concat(method);
        this.headers['Content-Type'] = 'application/json';
      }

      // Currently, all methods make GET requests. If a method makes a request with a body payload,
      // remember to add {'Content-Type': 'application/json'} to the header.
      var runRequest = function runRequest() {
        return fetch__default['default'](url, {
          method: requestMethod,
          headers: _objectSpread$1({
            Authorization: _this.authorization,
            'x-request-id': baseRequestId && "".concat(baseRequestId, "-span-").concat(spanCounter++)
          }, _this.headers),
          credentials: _this.credentials,
          body: requestMethod === 'POST' ? JSON.stringify(params) : null,
          signal: signal || _this.signal || (_this.fetchTimeout ? AbortSignal.timeout(_this.fetchTimeout) : undefined)
        });
      };
      return {
        /* eslint no-unsafe-finally: off */subscribe: function subscribe(callback) {
          var _this2 = this;
          return _asyncToGenerator__default['default'](/*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {
            var result, _result;
            return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  _context.next = 3;
                  return runRequest();
                case 3:
                  result = _context.sent;
                  return _context.abrupt("return", callback(result, function () {
                    return _this2.subscribe(callback);
                  }));
                case 7:
                  _context.prev = 7;
                  _context.t0 = _context["catch"](0);
                  _result = {
                    error: 'network Error'
                  };
                  return _context.abrupt("return", callback(_result, function () {
                    return _this2.subscribe(callback);
                  }));
                case 11:
                case "end":
                  return _context.stop();
              }
            }, _callee, null, [[0, 7]]);
          }))();
        }
      };
    }
  }]);
}();

function _callSuper(t, o, e) { return o = _getPrototypeOf__default['default'](o), _possibleConstructorReturn__default['default'](t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf__default['default'](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
var RequestError = /*#__PURE__*/function (_Error) {
  function RequestError(message, response, status) {
    var _this;
    _classCallCheck__default['default'](this, RequestError);
    _this = _callSuper(this, RequestError, [message]);
    _defineProperty__default['default'](_this, "response", void 0);
    _defineProperty__default['default'](_this, "status", void 0);
    _this.response = response;
    _this.status = status;
    return _this;
  }
  _inherits__default['default'](RequestError, _Error);
  return _createClass__default['default'](RequestError);
}(/*#__PURE__*/_wrapNativeSuper__default['default'](Error));

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty__default['default'](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }

// If we can't infer any members at all, then return any.

/**
 * @deprecated use DryRunResponse
 */

var mutexCounter = 0;
var MUTEX_ERROR = 'Mutex has been changed';
function mutexPromise(promise) {
  return promise.then(function (result) {
    return result;
  })["catch"](function (error) {
    if (error !== MUTEX_ERROR) {
      throw error;
    }
  });
}
/**
 * Main class for accessing Cube API
 */
var CubeApi = /*#__PURE__*/function () {
  /**
   * Creates an instance of the `CubeApi`. The API entry point.
   *
   * ```js
   * import cube from '@cubejs-client/core';
   * const cubeApi = cube(
   *   'CUBE-API-TOKEN',
   *   { apiUrl: 'http://localhost:4000/cubejs-api/v1' }
   * );
   * ```
   *
   * You can also pass an async function or a promise that will resolve to the API token
   *
   * ```js
   * import cube from '@cubejs-client/core';
   * const cubeApi = cube(
   *   async () => await Auth.getJwtToken(),
   *   { apiUrl: 'http://localhost:4000/cubejs-api/v1' }
   * );
   * ```
   */
  function CubeApi(apiToken, options) {
    _classCallCheck__default['default'](this, CubeApi);
    _defineProperty__default['default'](this, "apiToken", void 0);
    _defineProperty__default['default'](this, "apiUrl", void 0);
    _defineProperty__default['default'](this, "method", void 0);
    _defineProperty__default['default'](this, "headers", void 0);
    _defineProperty__default['default'](this, "credentials", void 0);
    _defineProperty__default['default'](this, "transport", void 0);
    _defineProperty__default['default'](this, "pollInterval", void 0);
    _defineProperty__default['default'](this, "parseDateMeasures", void 0);
    _defineProperty__default['default'](this, "castNumerics", void 0);
    _defineProperty__default['default'](this, "networkErrorRetries", void 0);
    _defineProperty__default['default'](this, "updateAuthorizationPromise", void 0);
    if (apiToken && !Array.isArray(apiToken) && _typeof__default['default'](apiToken) === 'object') {
      options = apiToken;
      apiToken = undefined;
    }
    if (!options || !options.transport && !options.apiUrl) {
      throw new Error('The `apiUrl` option is required');
    }
    this.apiToken = apiToken;
    this.apiUrl = options.apiUrl;
    this.method = options.method;
    this.headers = options.headers || {};
    this.credentials = options.credentials;
    this.transport = options.transport || new HttpTransport({
      authorization: typeof apiToken === 'string' ? apiToken : undefined,
      apiUrl: this.apiUrl,
      method: this.method,
      headers: this.headers,
      credentials: this.credentials,
      fetchTimeout: options.fetchTimeout,
      signal: options.signal
    });
    this.pollInterval = options.pollInterval || 5;
    this.parseDateMeasures = options.parseDateMeasures;
    this.castNumerics = typeof options.castNumerics === 'boolean' ? options.castNumerics : false;
    this.networkErrorRetries = options.networkErrorRetries || 0;
    this.updateAuthorizationPromise = null;
  }
  return _createClass__default['default'](CubeApi, [{
    key: "request",
    value: function request(method, params) {
      return this.transport.request(method, _objectSpread({
        baseRequestId: uuid.v4()
      }, params));
    }
  }, {
    key: "loadMethod",
    value: function loadMethod(request, toResult, options, callback) {
      var _this = this;
      var mutexValue = ++mutexCounter;
      if (typeof options === 'function' && !callback) {
        callback = options;
        options = undefined;
      }
      options = options || {};
      var mutexKey = options.mutexKey || 'default';
      if (options.mutexObj) {
        options.mutexObj[mutexKey] = mutexValue;
      }
      var requestPromise = this.updateTransportAuthorization().then(function () {
        return request();
      });
      var skipAuthorizationUpdate = true;
      var unsubscribed = false;
      var checkMutex = /*#__PURE__*/function () {
        var _ref = _asyncToGenerator__default['default'](/*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {
          var requestInstance;
          return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return requestPromise;
              case 2:
                requestInstance = _context.sent;
                if (!(options && options.mutexObj && options.mutexObj[mutexKey] !== mutexValue)) {
                  _context.next = 9;
                  break;
                }
                unsubscribed = true;
                if (!requestInstance.unsubscribe) {
                  _context.next = 8;
                  break;
                }
                _context.next = 8;
                return requestInstance.unsubscribe();
              case 8:
                throw MUTEX_ERROR;
              case 9:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        return function checkMutex() {
          return _ref.apply(this, arguments);
        };
      }();
      var networkRetries = this.networkErrorRetries;
      var loadImpl = /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator__default['default'](/*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4(response, next) {
          var _options2, _response$error, _options5;
          var requestInstance, subscribeNext, continueWait, body, text, _options3, _options4, _error, result;
          return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return requestPromise;
              case 2:
                requestInstance = _context4.sent;
                subscribeNext = /*#__PURE__*/function () {
                  var _ref3 = _asyncToGenerator__default['default'](/*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {
                    var _options;
                    return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
                      while (1) switch (_context2.prev = _context2.next) {
                        case 0:
                          if (!((_options = options) !== null && _options !== void 0 && _options.subscribe && !unsubscribed)) {
                            _context2.next = 8;
                            break;
                          }
                          if (!requestInstance.unsubscribe) {
                            _context2.next = 5;
                            break;
                          }
                          return _context2.abrupt("return", next());
                        case 5:
                          _context2.next = 7;
                          return new Promise(function (resolve) {
                            return setTimeout(function () {
                              return resolve();
                            }, _this.pollInterval * 1000);
                          });
                        case 7:
                          return _context2.abrupt("return", next());
                        case 8:
                          return _context2.abrupt("return", null);
                        case 9:
                        case "end":
                          return _context2.stop();
                      }
                    }, _callee2);
                  }));
                  return function subscribeNext() {
                    return _ref3.apply(this, arguments);
                  };
                }();
                continueWait = /*#__PURE__*/function () {
                  var _ref4 = _asyncToGenerator__default['default'](/*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3() {
                    var wait,
                      _args3 = arguments;
                    return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {
                      while (1) switch (_context3.prev = _context3.next) {
                        case 0:
                          wait = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : false;
                          if (unsubscribed) {
                            _context3.next = 6;
                            break;
                          }
                          if (!wait) {
                            _context3.next = 5;
                            break;
                          }
                          _context3.next = 5;
                          return new Promise(function (resolve) {
                            return setTimeout(function () {
                              return resolve();
                            }, _this.pollInterval * 1000);
                          });
                        case 5:
                          return _context3.abrupt("return", next());
                        case 6:
                          return _context3.abrupt("return", null);
                        case 7:
                        case "end":
                          return _context3.stop();
                      }
                    }, _callee3);
                  }));
                  return function continueWait() {
                    return _ref4.apply(this, arguments);
                  };
                }();
                if (!((_options2 = options) !== null && _options2 !== void 0 && _options2.subscribe && !skipAuthorizationUpdate)) {
                  _context4.next = 8;
                  break;
                }
                _context4.next = 8;
                return _this.updateTransportAuthorization();
              case 8:
                skipAuthorizationUpdate = false;
                if (!('status' in response && response.status === 502 || 'error' in response && ((_response$error = response.error) === null || _response$error === void 0 ? void 0 : _response$error.toLowerCase()) === 'network error' && --networkRetries >= 0)) {
                  _context4.next = 13;
                  break;
                }
                _context4.next = 12;
                return checkMutex();
              case 12:
                return _context4.abrupt("return", continueWait(true));
              case 13:
                // From here we're sure that response is only fetch Response
                response = response;
                body = {};
                text = '';
                _context4.prev = 16;
                _context4.next = 19;
                return response.text();
              case 19:
                text = _context4.sent;
                body = JSON.parse(text);
                _context4.next = 26;
                break;
              case 23:
                _context4.prev = 23;
                _context4.t0 = _context4["catch"](16);
                body.error = text;
              case 26:
                if (!(body.error === 'Continue wait')) {
                  _context4.next = 31;
                  break;
                }
                _context4.next = 29;
                return checkMutex();
              case 29:
                if ((_options3 = options) !== null && _options3 !== void 0 && _options3.progressCallback) {
                  options.progressCallback(new ProgressResult(body));
                }
                return _context4.abrupt("return", continueWait());
              case 31:
                if (!(response.status !== 200)) {
                  _context4.next = 44;
                  break;
                }
                _context4.next = 34;
                return checkMutex();
              case 34:
                if (!(!((_options4 = options) !== null && _options4 !== void 0 && _options4.subscribe) && requestInstance.unsubscribe)) {
                  _context4.next = 37;
                  break;
                }
                _context4.next = 37;
                return requestInstance.unsubscribe();
              case 37:
                _error = new RequestError(body.error || '', body, response.status);
                if (!callback) {
                  _context4.next = 42;
                  break;
                }
                callback(_error);
                _context4.next = 43;
                break;
              case 42:
                throw _error;
              case 43:
                return _context4.abrupt("return", subscribeNext());
              case 44:
                _context4.next = 46;
                return checkMutex();
              case 46:
                if (!(!((_options5 = options) !== null && _options5 !== void 0 && _options5.subscribe) && requestInstance.unsubscribe)) {
                  _context4.next = 49;
                  break;
                }
                _context4.next = 49;
                return requestInstance.unsubscribe();
              case 49:
                result = toResult(body);
                if (!callback) {
                  _context4.next = 54;
                  break;
                }
                callback(null, result);
                _context4.next = 55;
                break;
              case 54:
                return _context4.abrupt("return", result);
              case 55:
                return _context4.abrupt("return", subscribeNext());
              case 56:
              case "end":
                return _context4.stop();
            }
          }, _callee4, null, [[16, 23]]);
        }));
        return function loadImpl(_x, _x2) {
          return _ref2.apply(this, arguments);
        };
      }();
      var promise = requestPromise.then(function (requestInstance) {
        return mutexPromise(requestInstance.subscribe(loadImpl));
      });
      if (callback) {
        return {
          unsubscribe: function () {
            var _unsubscribe = _asyncToGenerator__default['default'](/*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee5() {
              var requestInstance;
              return _regeneratorRuntime__default['default'].wrap(function _callee5$(_context5) {
                while (1) switch (_context5.prev = _context5.next) {
                  case 0:
                    _context5.next = 2;
                    return requestPromise;
                  case 2:
                    requestInstance = _context5.sent;
                    unsubscribed = true;
                    if (!requestInstance.unsubscribe) {
                      _context5.next = 6;
                      break;
                    }
                    return _context5.abrupt("return", requestInstance.unsubscribe());
                  case 6:
                    return _context5.abrupt("return", null);
                  case 7:
                  case "end":
                    return _context5.stop();
                }
              }, _callee5);
            }));
            function unsubscribe() {
              return _unsubscribe.apply(this, arguments);
            }
            return unsubscribe;
          }()
        };
      } else {
        return promise;
      }
    }
  }, {
    key: "updateTransportAuthorization",
    value: function () {
      var _updateTransportAuthorization = _asyncToGenerator__default['default'](/*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee7() {
        var _this2 = this;
        var tokenFetcher, promise;
        return _regeneratorRuntime__default['default'].wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              if (!this.updateAuthorizationPromise) {
                _context7.next = 4;
                break;
              }
              _context7.next = 3;
              return this.updateAuthorizationPromise;
            case 3:
              return _context7.abrupt("return");
            case 4:
              tokenFetcher = this.apiToken;
              if (!(typeof tokenFetcher === 'function')) {
                _context7.next = 10;
                break;
              }
              promise = _asyncToGenerator__default['default'](/*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee6() {
                var token;
                return _regeneratorRuntime__default['default'].wrap(function _callee6$(_context6) {
                  while (1) switch (_context6.prev = _context6.next) {
                    case 0:
                      _context6.prev = 0;
                      _context6.next = 3;
                      return tokenFetcher();
                    case 3:
                      token = _context6.sent;
                      if (_this2.transport.authorization !== token) {
                        _this2.transport.authorization = token;
                      }
                    case 5:
                      _context6.prev = 5;
                      _this2.updateAuthorizationPromise = null;
                      return _context6.finish(5);
                    case 8:
                    case "end":
                      return _context6.stop();
                  }
                }, _callee6, null, [[0,, 5, 8]]);
              }))();
              this.updateAuthorizationPromise = promise;
              _context7.next = 10;
              return promise;
            case 10:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function updateTransportAuthorization() {
        return _updateTransportAuthorization.apply(this, arguments);
      }
      return updateTransportAuthorization;
    }()
    /**
     * Add system properties to a query object.
     */
  }, {
    key: "patchQueryInternal",
    value: function patchQueryInternal(query, responseFormat) {
      if (responseFormat === 'compact' && query.responseFormat !== 'compact') {
        return _objectSpread(_objectSpread({}, query), {}, {
          responseFormat: 'compact'
        });
      } else {
        return query;
      }
    }

    /**
     * Process result fetched from the gateway#load method according
     * to the network protocol.
     */
  }, {
    key: "loadResponseInternal",
    value: function loadResponseInternal(response) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (response.results.length) {
        if (options !== null && options !== void 0 && options.castNumerics) {
          response.results.forEach(function (result) {
            var numericMembers = Object.entries(_objectSpread(_objectSpread({}, result.annotation.measures), result.annotation.dimensions)).reduce(function (acc, _ref6) {
              var _ref7 = _slicedToArray__default['default'](_ref6, 2),
                k = _ref7[0],
                v = _ref7[1];
              if (v.type === 'number') {
                acc.push(k);
              }
              return acc;
            }, []);
            result.data = result.data.map(function (row) {
              numericMembers.forEach(function (key) {
                if (row[key] != null) {
                  row[key] = Number(row[key]);
                }
              });
              return row;
            });
          });
        }
        if (response.results[0].query.responseFormat && response.results[0].query.responseFormat === 'compact') {
          response.results.forEach(function (result, j) {
            var data = [];
            var _ref8 = result.data,
              dataset = _ref8.dataset,
              members = _ref8.members;
            dataset.forEach(function (r) {
              var row = {};
              members.forEach(function (m, i) {
                row[m] = r[i];
              });
              data.push(row);
            });
            response.results[j].data = data;
          });
        }
      }
      return new ResultSet(response, {
        parseDateMeasures: this.parseDateMeasures
      });
    }
  }, {
    key: "load",
    value:
    /**
     * Fetch data for the passed `query`.
     *
     * ```js
     * import cube from '@cubejs-client/core';
     * import Chart from 'chart.js';
     * import chartjsConfig from './toChartjsData';
     *
     * const cubeApi = cube('CUBEJS_TOKEN');
     *
     * const resultSet = await cubeApi.load({
     *  measures: ['Stories.count'],
     *  timeDimensions: [{
     *    dimension: 'Stories.time',
     *    dateRange: ['2015-01-01', '2015-12-31'],
     *    granularity: 'month'
     *   }]
     * });
     *
     * const context = document.getElementById('myChart');
     * new Chart(context, chartjsConfig(resultSet));
     * ```
     * @param query - [Query object](/product/apis-integrations/rest-api/query-format)
     * @param options
     * @param callback
     * @param responseFormat
     */
    function load(query, options, callback) {
      var _this3 = this;
      var responseFormat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'default';
      var _this$prepareQueryOpt = this.prepareQueryOptions(query, options, responseFormat);
      var _this$prepareQueryOpt2 = _slicedToArray__default['default'](_this$prepareQueryOpt, 2);
      query = _this$prepareQueryOpt2[0];
      options = _this$prepareQueryOpt2[1];
      return this.loadMethod(function () {
        var _options6;
        return _this3.request('load', {
          query: query,
          queryType: 'multi',
          signal: (_options6 = options) === null || _options6 === void 0 ? void 0 : _options6.signal
        });
      }, function (response) {
        return _this3.loadResponseInternal(response, options);
      }, options, callback);
    }
  }, {
    key: "prepareQueryOptions",
    value: function prepareQueryOptions(query, options) {
      var _this4 = this;
      var responseFormat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'default';
      options = _objectSpread({
        castNumerics: this.castNumerics
      }, options);
      if (responseFormat === 'compact') {
        if (Array.isArray(query)) {
          var patched = query.map(function (q) {
            return _this4.patchQueryInternal(q, 'compact');
          });
          return [patched, options];
        } else {
          var _patched = this.patchQueryInternal(query, 'compact');
          return [_patched, options];
        }
      }
      return [query, options];
    }

    /**
     * Allows you to fetch data and receive updates over time. See [Real-Time Data Fetch](/product/apis-integrations/rest-api/real-time-data-fetch)
     *
     * ```js
     * // Subscribe to a query's updates
     * const subscription = await cubeApi.subscribe(
     *   {
     *     measures: ['Logs.count'],
     *     timeDimensions: [
     *       {
     *         dimension: 'Logs.time',
     *         granularity: 'hour',
     *         dateRange: 'last 1440 minutes',
     *       },
     *     ],
     *   },
     *   options,
     *   (error, resultSet) => {
     *     if (!error) {
     *       // handle the update
     *     }
     *   }
     * );
     *
     * // Unsubscribe from a query's updates
     * subscription.unsubscribe();
     * ```
     */
  }, {
    key: "subscribe",
    value: function subscribe(query, options, callback) {
      var _this5 = this;
      var responseFormat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'default';
      var _this$prepareQueryOpt3 = this.prepareQueryOptions(query, options, responseFormat);
      var _this$prepareQueryOpt4 = _slicedToArray__default['default'](_this$prepareQueryOpt3, 2);
      query = _this$prepareQueryOpt4[0];
      options = _this$prepareQueryOpt4[1];
      return this.loadMethod(function () {
        var _options7;
        return _this5.request('subscribe', {
          query: query,
          queryType: 'multi',
          signal: (_options7 = options) === null || _options7 === void 0 ? void 0 : _options7.signal
        });
      }, function (response) {
        return _this5.loadResponseInternal(response, options);
      }, _objectSpread(_objectSpread({}, options), {}, {
        subscribe: true
      }), callback);
    }
  }, {
    key: "sql",
    value:
    /**
     * Get generated SQL string for the given `query`.
     */
    function sql(query, options, callback) {
      var _this6 = this;
      return this.loadMethod(function () {
        return _this6.request('sql', {
          query: query,
          signal: options === null || options === void 0 ? void 0 : options.signal
        });
      }, function (response) {
        return Array.isArray(response) ? response.map(function (body) {
          return new SqlQuery(body);
        }) : new SqlQuery(response);
      }, options, callback);
    }
  }, {
    key: "meta",
    value:
    /**
     * Get meta description of cubes available for querying.
     */
    function meta(options, callback) {
      var _this7 = this;
      return this.loadMethod(function () {
        return _this7.request('meta', {
          signal: options === null || options === void 0 ? void 0 : options.signal
        });
      }, function (body) {
        return new Meta(body);
      }, options, callback);
    }
  }, {
    key: "dryRun",
    value:
    /**
     * Get query related meta without query execution
     */
    function dryRun(query, options, callback) {
      var _this8 = this;
      return this.loadMethod(function () {
        return _this8.request('dry-run', {
          query: query,
          signal: options === null || options === void 0 ? void 0 : options.signal
        });
      }, function (response) {
        return response;
      }, options, callback);
    }
  }]);
}();
var index = (function (apiToken, options) {
  return new CubeApi(apiToken, options);
});

exports.CubeApi = CubeApi;
exports.DEFAULT_GRANULARITY = DEFAULT_GRANULARITY;
exports.DateRegex = DateRegex;
exports.GRANULARITIES = GRANULARITIES;
exports.HttpTransport = HttpTransport;
exports.LocalDateRegex = LocalDateRegex;
exports.Meta = Meta;
exports.ProgressResult = ProgressResult;
exports.RequestError = RequestError;
exports.ResultSet = ResultSet;
exports.SqlQuery = SqlQuery;
exports.TIME_SERIES = TIME_SERIES;
exports.addInterval = addInterval;
exports.aliasSeries = aliasSeries;
exports.areQueriesEqual = areQueriesEqual;
exports.dayRange = _dayRange;
exports.default = index;
exports.defaultHeuristics = defaultHeuristics;
exports.defaultOrder = defaultOrder;
exports.diffTimeUnitForInterval = diffTimeUnitForInterval;
exports.flattenFilters = flattenFilters;
exports.getOrderMembersFromOrder = getOrderMembersFromOrder;
exports.getQueryMembers = getQueryMembers;
exports.granularityFor = granularityFor;
exports.internalDayjs = internalDayjs;
exports.isPredefinedGranularity = isPredefinedGranularity;
exports.isQueryPresent = isQueryPresent;
exports.minGranularityForIntervals = minGranularityForIntervals;
exports.moveItemInArray = moveItemInArray;
exports.movePivotItem = movePivotItem;
exports.parseSqlInterval = parseSqlInterval;
exports.removeEmptyQueryFields = removeEmptyQueryFields;
exports.subtractInterval = subtractInterval;
exports.timeSeriesFromCustomInterval = timeSeriesFromCustomInterval;
exports.validateQuery = validateQuery;
//# sourceMappingURL=cubejs-client-core.cjs.js.map
