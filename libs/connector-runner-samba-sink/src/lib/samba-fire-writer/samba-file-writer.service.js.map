{
  "version": 3,
  "sources": ["../../../../../../../../libs/connector-runner-samba-sink/src/lib/samba-fire-writer/samba-file-writer.service.ts"],
  "sourcesContent": ["import { SambaClient, SambaConfig } from '@xip-online-data/samba-client';\nimport { XodBaseMessageType } from '@xip-online-data/types';\nimport * as fs from 'fs';\nimport { Logger } from '@transai/logger';\n\nexport interface SambaFileWriterResponse {\n  success: boolean;\n  message: string;\n}\n\nexport class SambaFileWriterService {\n  private sambaClient: SambaClient;\n\n  constructor(private readonly sambaConfig: SambaConfig) {\n    this.sambaClient = new SambaClient(sambaConfig);\n  }\n\n  async write(\n    message: XodBaseMessageType,\n    path: string,\n    content: string,\n  ): Promise<SambaFileWriterResponse> {\n    const tmpFileLoc = `${this.sambaConfig.tmpDirectory}/${message.eventId}.tmp`;\n\n    let success = await this.writeToFileSystem(tmpFileLoc, content);\n\n    if (!success) {\n      return {\n        success: false,\n        message: 'Error while writing file to local temporary location',\n      };\n    }\n\n    try {\n      Logger.getInstance().debug(\n        `Handle message ${message.eventId}, writing file ${content} to samba server`,\n      );\n      await this.sambaClient.sendFile(tmpFileLoc, path);\n    } catch (error: unknown) {\n      Logger.getInstance().error(\n        `${message.eventId} Error while sending file to samba server`,\n        error,\n      );\n\n      let errorMessage = 'unknown error';\n      const keys = Object.keys(error as object);\n      if (keys.includes('stdout')) {\n        errorMessage = (error as { stdout: string }).stdout || 'unknown error';\n      }\n\n      return {\n        success: false,\n        message: `Error while sending file to samba server: ${errorMessage}`,\n      };\n    } finally {\n      success = await this.removeTempFileFromFileSystem(tmpFileLoc);\n    }\n\n    if (!success) {\n      return {\n        success: false,\n        message: 'Error while removing file from local temporary location',\n      };\n    }\n\n    return {\n      success: true,\n      message: 'Message processed successfully',\n    };\n  }\n\n  private writeToFileSystem(\n    tmpFileLoc: string,\n    content: string,\n  ): Promise<boolean> {\n    return new Promise<boolean>((resolve) => {\n      fs.writeFile(tmpFileLoc, content, (err) => {\n        // eslint-disable-next-line eqeqeq\n        resolve(err == undefined);\n      });\n    });\n  }\n\n  private removeTempFileFromFileSystem(tmpFileLoc: string): Promise<boolean> {\n    return new Promise((resolve) => {\n      fs.unlink(tmpFileLoc, (err) => {\n        // eslint-disable-next-line eqeqeq\n        resolve(err == undefined);\n      });\n    });\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,0BAAyC;AAEzC,SAAoB;AACpB,oBAAuB;AAOhB,MAAM,uBAAuB;AAAA,EAGlC,YAA6B,aAA0B;AAA1B;AAC3B,SAAK,cAAc,IAAI,gCAAY,WAAW;AAAA,EAChD;AAAA,EAEA,MAAM,MACJ,SACA,MACA,SACkC;AAClC,UAAM,aAAa,GAAG,KAAK,YAAY,YAAY,IAAI,QAAQ,OAAO;AAEtE,QAAI,UAAU,MAAM,KAAK,kBAAkB,YAAY,OAAO;AAE9D,QAAI,CAAC,SAAS;AACZ,aAAO;AAAA,QACL,SAAS;AAAA,QACT,SAAS;AAAA,MACX;AAAA,IACF;AAEA,QAAI;AACF,2BAAO,YAAY,EAAE;AAAA,QACnB,kBAAkB,QAAQ,OAAO,kBAAkB,OAAO;AAAA,MAC5D;AACA,YAAM,KAAK,YAAY,SAAS,YAAY,IAAI;AAAA,IAClD,SAAS,OAAgB;AACvB,2BAAO,YAAY,EAAE;AAAA,QACnB,GAAG,QAAQ,OAAO;AAAA,QAClB;AAAA,MACF;AAEA,UAAI,eAAe;AACnB,YAAM,OAAO,OAAO,KAAK,KAAe;AACxC,UAAI,KAAK,SAAS,QAAQ,GAAG;AAC3B,uBAAgB,MAA6B,UAAU;AAAA,MACzD;AAEA,aAAO;AAAA,QACL,SAAS;AAAA,QACT,SAAS,6CAA6C,YAAY;AAAA,MACpE;AAAA,IACF,UAAE;AACA,gBAAU,MAAM,KAAK,6BAA6B,UAAU;AAAA,IAC9D;AAEA,QAAI,CAAC,SAAS;AACZ,aAAO;AAAA,QACL,SAAS;AAAA,QACT,SAAS;AAAA,MACX;AAAA,IACF;AAEA,WAAO;AAAA,MACL,SAAS;AAAA,MACT,SAAS;AAAA,IACX;AAAA,EACF;AAAA,EAEQ,kBACN,YACA,SACkB;AAClB,WAAO,IAAI,QAAiB,CAAC,YAAY;AACvC,SAAG,UAAU,YAAY,SAAS,CAAC,QAAQ;AAEzC,gBAAQ,OAAO,MAAS;AAAA,MAC1B,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEQ,6BAA6B,YAAsC;AACzE,WAAO,IAAI,QAAQ,CAAC,YAAY;AAC9B,SAAG,OAAO,YAAY,CAAC,QAAQ;AAE7B,gBAAQ,OAAO,MAAS;AAAA,MAC1B,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AACF;",
  "names": []
}
