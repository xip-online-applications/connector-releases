{
  "version": 3,
  "sources": ["../../../../../../../../../libs/datasource/src/lib/driver/my-sql/my-sql.query-runner.ts"],
  "sourcesContent": ["import { QueryRunnerInterface } from '../query-runner.interface';\nimport { DatasourceService } from '../../datasource.service';\nimport { MySqlConnectionDriver } from './my-sql-connection.driver';\nimport { QueryResult } from '../query-result';\nimport { QueryFailedError } from '../error/QueryFailedError';\n\nexport class MySqlQueryRunner implements QueryRunnerInterface {\n  readonly driver: MySqlConnectionDriver;\n\n  readonly connection: DatasourceService;\n\n  isReleased: boolean;\n\n  isTransactionActive: boolean;\n\n  /**\n   * Real database connection from a connection pool used to perform queries.\n   */\n  protected databaseConnection: any;\n\n  /**\n   * Promise used to obtain a database connection from a pool for a first time.\n   */\n  protected databaseConnectionPromise: Promise<any> | undefined;\n\n  constructor(driver: MySqlConnectionDriver) {\n    this.driver = driver;\n    this.connection = driver.connection;\n    this.isReleased = false;\n    this.isTransactionActive = false;\n  }\n\n  connect(): Promise<any> {\n    if (this.databaseConnection)\n      return Promise.resolve(this.databaseConnection);\n\n    if (this.databaseConnectionPromise) return this.databaseConnectionPromise;\n\n    this.databaseConnectionPromise = this.driver\n      .obtainConnection()\n      .then((connection) => {\n        this.databaseConnection = connection;\n        return this.databaseConnection;\n      });\n\n    return this.databaseConnectionPromise;\n  }\n\n  async query(query: string, parameters?: Array<any>): Promise<QueryResult> {\n    const databaseConnection = await this.connect();\n    const queryStartTime = +new Date();\n    try {\n      const [raw] = await databaseConnection.query(query, parameters);\n      const queryEndTime = +new Date();\n      const queryExecutionTime = queryEndTime - queryStartTime;\n      const result = new QueryResult();\n\n      result.raw = raw;\n      result.executionTime = queryExecutionTime;\n\n      try {\n        result.records = Array.from(raw);\n      } catch {\n        // Do nothing.\n      }\n\n      if (raw?.hasOwnProperty('affectedRows')) {\n        result.affected = raw.affectedRows;\n      } else {\n        result.affected = raw.length;\n      }\n\n      return result;\n    } catch (error: any) {\n      throw new QueryFailedError(query, parameters, error);\n    }\n  }\n\n  release(): Promise<void> {\n    this.isReleased = true;\n    if (this.databaseConnection) this.databaseConnection.release();\n    return Promise.resolve();\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,0BAA4B;AAC5B,8BAAiC;AAE1B,MAAM,iBAAiD;AAAA,EAmB5D,YAAY,QAA+B;AACzC,SAAK,SAAS;AACd,SAAK,aAAa,OAAO;AACzB,SAAK,aAAa;AAClB,SAAK,sBAAsB;AAAA,EAC7B;AAAA,EAEA,UAAwB;AACtB,QAAI,KAAK;AACP,aAAO,QAAQ,QAAQ,KAAK,kBAAkB;AAEhD,QAAI,KAAK;AAA2B,aAAO,KAAK;AAEhD,SAAK,4BAA4B,KAAK,OACnC,iBAAiB,EACjB,KAAK,CAAC,eAAe;AACpB,WAAK,qBAAqB;AAC1B,aAAO,KAAK;AAAA,IACd,CAAC;AAEH,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,MAAM,OAAe,YAA+C;AACxE,UAAM,qBAAqB,MAAM,KAAK,QAAQ;AAC9C,UAAM,iBAAiB,CAAC,oBAAI,KAAK;AACjC,QAAI;AACF,YAAM,CAAC,GAAG,IAAI,MAAM,mBAAmB,MAAM,OAAO,UAAU;AAC9D,YAAM,eAAe,CAAC,oBAAI,KAAK;AAC/B,YAAM,qBAAqB,eAAe;AAC1C,YAAM,SAAS,IAAI,gCAAY;AAE/B,aAAO,MAAM;AACb,aAAO,gBAAgB;AAEvB,UAAI;AACF,eAAO,UAAU,MAAM,KAAK,GAAG;AAAA,MACjC,QAAQ;AAAA,MAER;AAEA,UAAI,KAAK,eAAe,cAAc,GAAG;AACvC,eAAO,WAAW,IAAI;AAAA,MACxB,OAAO;AACL,eAAO,WAAW,IAAI;AAAA,MACxB;AAEA,aAAO;AAAA,IACT,SAAS,OAAY;AACnB,YAAM,IAAI,yCAAiB,OAAO,YAAY,KAAK;AAAA,IACrD;AAAA,EACF;AAAA,EAEA,UAAyB;AACvB,SAAK,aAAa;AAClB,QAAI,KAAK;AAAoB,WAAK,mBAAmB,QAAQ;AAC7D,WAAO,QAAQ,QAAQ;AAAA,EACzB;AACF;",
  "names": []
}
