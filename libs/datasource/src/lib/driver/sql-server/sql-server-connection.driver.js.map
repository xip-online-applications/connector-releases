{
  "version": 3,
  "sources": ["../../../../../../../../../libs/datasource/src/lib/driver/sql-server/sql-server-connection.driver.ts"],
  "sourcesContent": ["import * as msSql from 'mssql';\nimport { Logger } from '@transai/logger';\nimport { Driver } from '../driver';\nimport { DatasourceService } from '../../datasource.service';\nimport { SqlServerConnectionOptions } from './sql-server-connection.options';\nimport { QueryRunnerInterface } from '../query-runner.interface';\nimport { SqlServerQueryRunner } from './sql-server.query-runner';\nimport { SqlServerConnectionCredentialsOptions } from './sql-server-connection-credentials.options';\n\nexport class SqlServerConnectionDriver implements Driver {\n  database: string = '';\n\n  options: SqlServerConnectionOptions;\n\n  mssql: any;\n\n  connection: DatasourceService;\n\n  /**\n   * Pool for master database.\n   */\n  master: any;\n\n  /**\n   * Version of Postgres. Requires a SQL query to the DB, so it is not always set\n   */\n  version?: string;\n\n  /**\n   * We store all created query runners because we need to release them.\n   */\n  connectedQueryRunners: Array<QueryRunnerInterface> = [];\n\n  constructor(connection: DatasourceService) {\n    this.connection = connection;\n    this.options = connection.options as SqlServerConnectionOptions;\n\n    // load mssql package\n    this.loadDependencies();\n  }\n\n  protected loadDependencies(): void {\n    try {\n      this.mssql = msSql;\n    } catch (e) {\n      throw new Error('SQL Server mssql not loaded');\n    }\n  }\n\n  async connect(): Promise<void> {\n    this.master = await this.createPool(this.options, this.options);\n    const queryRunner = this.createQueryRunner();\n\n    await queryRunner.release();\n  }\n\n  async afterConnect(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  disconnect(): Promise<void> {\n    return Promise.resolve(undefined);\n  }\n\n  createQueryRunner(): QueryRunnerInterface {\n    return new SqlServerQueryRunner(this);\n  }\n\n  /**\n   * Obtains a new database connection to a master server.\n   * Used for replication.\n   * If replication is not setup then returns default connection's database connection.\n   */\n  async obtainMasterConnection(): Promise<[any, Function]> {\n    if (!this.master) {\n      return Promise.reject(new Error('Driver not Connected'));\n    }\n\n    return Promise.resolve(this.master);\n  }\n\n  /**\n   * Creates a new connection pool for a given database credentials.\n   */\n  private createPool(\n    options: SqlServerConnectionOptions,\n    credentials: SqlServerConnectionCredentialsOptions,\n  ): Promise<any> {\n    const connectionOptions = {\n      connectionTimeout: this.options.connectionTimeout,\n      requestTimeout: this.options.requestTimeout,\n      stream: this.options.stream,\n      pool: this.options.pool,\n      options: this.options.options,\n      server: credentials.host,\n      database: credentials.database,\n      port: credentials.port,\n      user: credentials.username,\n      password: credentials.password,\n      authentication: credentials.authentication,\n    };\n\n    // set default useUTC option if it hasn't been set\n    if (!connectionOptions.options) {\n      connectionOptions.options = { useUTC: false };\n    } else if (!connectionOptions.options.useUTC) {\n      Object.assign(connectionOptions.options, { useUTC: false });\n    }\n\n    // Match the next release of tedious for configuration options\n    // Also prevents warning messages.\n    Object.assign(connectionOptions.options, { enableArithAbort: true });\n\n    // pooling is enabled either when its set explicitly to true,\n    // either when its not defined at all (e.g. enabled by default)\n    return new Promise<void>((ok, fail) => {\n      const pool = new this.mssql.ConnectionPool(connectionOptions);\n\n      const poolErrorHandler =\n        (options.pool && options.pool.errorHandler) ||\n        ((error: any) =>\n          Logger.getInstance().warn(`MSSQL pool raised an error. ${error}`));\n      /**\n       * Attaching an error handler to pool errors is essential, as, otherwise, errors raised will go unhandled and\n       * cause the hosting app to crash.\n       */\n      pool.on('error', poolErrorHandler);\n\n      const connection = pool.connect((err: any) => {\n        if (err) return fail(err);\n        ok(connection);\n      });\n    });\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAAuB;AACvB,oBAAuB;AAKvB,wBAAqC;AAG9B,MAAM,0BAA4C;AAAA,EAwBvD,YAAY,YAA+B;AAvB3C,oBAAmB;AAqBnB;AAAA;AAAA;AAAA,iCAAqD,CAAC;AAGpD,SAAK,aAAa;AAClB,SAAK,UAAU,WAAW;AAG1B,SAAK,iBAAiB;AAAA,EACxB;AAAA,EAEU,mBAAyB;AACjC,QAAI;AACF,WAAK,QAAQ;AAAA,IACf,SAAS,GAAG;AACV,YAAM,IAAI,MAAM,6BAA6B;AAAA,IAC/C;AAAA,EACF;AAAA,EAEA,MAAM,UAAyB;AAC7B,SAAK,SAAS,MAAM,KAAK,WAAW,KAAK,SAAS,KAAK,OAAO;AAC9D,UAAM,cAAc,KAAK,kBAAkB;AAE3C,UAAM,YAAY,QAAQ;AAAA,EAC5B;AAAA,EAEA,MAAM,eAA8B;AAClC,WAAO,QAAQ,QAAQ;AAAA,EACzB;AAAA,EAEA,aAA4B;AAC1B,WAAO,QAAQ,QAAQ,MAAS;AAAA,EAClC;AAAA,EAEA,oBAA0C;AACxC,WAAO,IAAI,uCAAqB,IAAI;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,yBAAmD;AACvD,QAAI,CAAC,KAAK,QAAQ;AAChB,aAAO,QAAQ,OAAO,IAAI,MAAM,sBAAsB,CAAC;AAAA,IACzD;AAEA,WAAO,QAAQ,QAAQ,KAAK,MAAM;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA,EAKQ,WACN,SACA,aACc;AACd,UAAM,oBAAoB;AAAA,MACxB,mBAAmB,KAAK,QAAQ;AAAA,MAChC,gBAAgB,KAAK,QAAQ;AAAA,MAC7B,QAAQ,KAAK,QAAQ;AAAA,MACrB,MAAM,KAAK,QAAQ;AAAA,MACnB,SAAS,KAAK,QAAQ;AAAA,MACtB,QAAQ,YAAY;AAAA,MACpB,UAAU,YAAY;AAAA,MACtB,MAAM,YAAY;AAAA,MAClB,MAAM,YAAY;AAAA,MAClB,UAAU,YAAY;AAAA,MACtB,gBAAgB,YAAY;AAAA,IAC9B;AAGA,QAAI,CAAC,kBAAkB,SAAS;AAC9B,wBAAkB,UAAU,EAAE,QAAQ,MAAM;AAAA,IAC9C,WAAW,CAAC,kBAAkB,QAAQ,QAAQ;AAC5C,aAAO,OAAO,kBAAkB,SAAS,EAAE,QAAQ,MAAM,CAAC;AAAA,IAC5D;AAIA,WAAO,OAAO,kBAAkB,SAAS,EAAE,kBAAkB,KAAK,CAAC;AAInE,WAAO,IAAI,QAAc,CAAC,IAAI,SAAS;AACrC,YAAM,OAAO,IAAI,KAAK,MAAM,eAAe,iBAAiB;AAE5D,YAAM,mBACH,QAAQ,QAAQ,QAAQ,KAAK,iBAC7B,CAAC,UACA,qBAAO,YAAY,EAAE,KAAK,+BAA+B,KAAK,EAAE;AAKpE,WAAK,GAAG,SAAS,gBAAgB;AAEjC,YAAM,aAAa,KAAK,QAAQ,CAAC,QAAa;AAC5C,YAAI;AAAK,iBAAO,KAAK,GAAG;AACxB,WAAG,UAAU;AAAA,MACf,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AACF;",
  "names": []
}
