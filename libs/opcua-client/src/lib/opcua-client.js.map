{
  "version": 3,
  "sources": ["../../../../../../../libs/opcua-client/src/lib/opcua-client.ts"],
  "sourcesContent": ["import { Logger } from '@transai/logger';\nimport {\n  AttributeIds,\n  BrowseDirection,\n  CallMethodRequestOptions,\n  CallMethodResult,\n  ClientSession,\n  ClientSubscription,\n  DataType,\n  DataValue,\n  NodeClass,\n  NodeIdLike,\n  OPCUAClient,\n  StatusCodes,\n  TimestampsToReturn,\n  Variant,\n  VariantLike,\n} from 'node-opcua';\n\nimport { OpcuaInterface } from './opcua-client.interface';\nimport { OpcUaConfig } from './types';\n\nexport class OpcuaClient implements OpcuaInterface {\n  readonly #OPCUA_NAMESPACE_NODE_ID = 'i=2255';\n\n  readonly #opcuaConfig: OpcUaConfig;\n\n  readonly #logger: Logger;\n\n  readonly #client: OPCUAClient;\n\n  #clientSession?: ClientSession;\n\n  #namespaceIndex?: number;\n\n  #nodeSubscriptions: { [nodeId: string]: ClientSubscription } = {};\n\n  constructor(\n    opcuaConfig: OpcUaConfig,\n    logger = Logger.getInstance(),\n    client: OPCUAClient | undefined = undefined,\n  ) {\n    this.#logger = logger;\n    this.#opcuaConfig = opcuaConfig;\n    this.#client =\n      client ??\n      OPCUAClient.create({\n        endpointMustExist: false,\n        securityMode: this.#opcuaConfig.securityMode,\n        securityPolicy: this.#opcuaConfig.securityPolicy,\n      });\n  }\n\n  public async init(): Promise<void> {\n    try {\n      this.#logger.info(\n        `Connecting to OPC UA server ${this.#opcuaConfig.endpointUrl}...`,\n      );\n\n      // Connect with the client and start the session first.\n      await this.#client.connect(this.#opcuaConfig.endpointUrl);\n      this.#clientSession = await this.#client.createSession();\n\n      // Retrieve and save the namespace index as a way of testing the OPC UA\n      // connection.\n      if (this.#opcuaConfig.namespace) {\n        this.#namespaceIndex = await this.#resolveNamespaceIndex(\n          this.#opcuaConfig.namespace,\n        );\n      }\n\n      this.#logger.info(\n        `Connected to OPC UA server ${this.#opcuaConfig.endpointUrl}.`,\n      );\n    } catch (error) {\n      this.#logger.error(\n        `Failed to connect to OPC UA server ${this.#opcuaConfig.endpointUrl}:`,\n        error,\n      );\n\n      // Something went wrong, ensure we clean up.\n      await this.disconnect();\n      throw error;\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    await Promise.all(\n      Object.keys(this.#nodeSubscriptions).map((nodeId) =>\n        this.unsubscribeFromNode(nodeId),\n      ),\n    );\n    this.#nodeSubscriptions = {};\n\n    await this.#clientSession?.close();\n    this.#clientSession = undefined;\n\n    if ('disconnect' in this.#client) {\n      await this.#client.disconnect();\n    }\n\n    this.#logger.info(\n      `Disconnected from OPC UA server ${this.#opcuaConfig.endpointUrl}.`,\n    );\n  }\n\n  get #getClientSession(): ClientSession {\n    if (!this.#clientSession) {\n      throw new Error('No active session.');\n    }\n\n    return this.#clientSession;\n  }\n\n  async readValue<T>(nodeId: string): Promise<T | undefined> {\n    let dataValue: DataValue;\n\n    try {\n      dataValue = await this.#getClientSession.read({\n        nodeId,\n        attributeId: AttributeIds.Value,\n      });\n    } catch (error) {\n      this.#logger.error('Read error:', error);\n      throw error;\n    }\n\n    if (dataValue.statusCode === StatusCodes.BadNodeIdUnknown) {\n      this.#logger.error(`NodeId ${nodeId} is unknown.`);\n      return undefined;\n    }\n\n    this.#logger.debug(`Read value from ${nodeId}: ${dataValue.toString()}`);\n\n    return dataValue.value.value;\n  }\n\n  async callMethod<T>(\n    nodeId: string,\n    methodName: string,\n    args?: Array<VariantLike>,\n  ): Promise<Array<T>> {\n    const result = await this.#getClientSession.call({\n      objectId: `ns=${this.#namespaceIndex};s=${nodeId}`,\n      methodId: `ns=${this.#namespaceIndex};s=${nodeId}.${methodName}`,\n      inputArguments: args,\n    } as CallMethodRequestOptions);\n\n    if (!result.outputArguments) {\n      return [];\n    }\n\n    return result.outputArguments.map((arg) => arg.value as T);\n  }\n\n  async callFromDsl<T>(dsl: string): Promise<Array<T>> {\n    const parsed = this.#parseDslWithNamespaceUri(dsl);\n    this.#logger.debug(parsed);\n\n    const nsIndex = await this.#resolveNamespaceIndex(parsed.namespaceUri);\n    this.#logger.debug('Resolved namespace index:', nsIndex);\n\n    // Replace \"ns=0\" with actual namespace index\n    const objectId = parsed.objectNodeId?.replace('ns=0', `ns=${nsIndex}`);\n    const methodId = parsed.methodNodeId?.replace('ns=0', `ns=${nsIndex}`);\n\n    this.#logger.debug(\n      `Resolved objectId ${objectId} and methodId ${methodId}`,\n    );\n\n    return new Promise((resolve, reject) => {\n      this.#getClientSession.call(\n        {\n          objectId,\n          methodId,\n          inputArguments: parsed.inputArguments,\n        },\n        (err: Error | null, result?: CallMethodResult) => {\n          if (err) {\n            this.#logger.error('Call failed:', err.message);\n            reject(new Error(`Call failed: ${err.message}`));\n            return;\n          }\n\n          if (!result) {\n            this.#logger.warn('No result returned.');\n            reject(new Error('No result returned.'));\n            return;\n          }\n\n          if (result.statusCode !== StatusCodes.Good) {\n            this.#logger.error(`Call failed: ${result.statusCode.name}`);\n            reject(new Error(`Call failed: ${result.statusCode.name}`));\n            return;\n          }\n\n          this.#logger.debug('Call succeeded:', result);\n          resolve(result.outputArguments?.map((arg): T => arg.value) ?? []);\n        },\n      );\n    });\n  }\n\n  async subscribeToNode<T>(\n    nodeId: string,\n    callback: (nodeId: string, value: T) => void,\n  ): Promise<void> {\n    const subscription = ClientSubscription.create(this.#getClientSession, {\n      requestedPublishingInterval: 1000,\n      requestedLifetimeCount: 10,\n      requestedMaxKeepAliveCount: 5,\n      maxNotificationsPerPublish: 10,\n      publishingEnabled: true,\n      priority: 10,\n    });\n\n    const monitoredItem = await subscription.monitor(\n      { nodeId, attributeId: AttributeIds.Value },\n      { samplingInterval: 1000, discardOldest: true, queueSize: 10 },\n      TimestampsToReturn.Both,\n    );\n\n    monitoredItem.on('changed', (dataValue: DataValue) => {\n      const { value, statusCode } = dataValue;\n\n      if (statusCode === StatusCodes.BadNodeIdUnknown) {\n        throw new Error('NodeId is unknown.');\n      }\n\n      this.#logger.debug(\n        `Subscription update from ${nodeId}: ${value.toString()}`,\n      );\n\n      callback(nodeId, value.value);\n    });\n\n    this.#logger.info(`Subscribed to ${nodeId}`);\n  }\n\n  async unsubscribeFromNode(nodeId: string): Promise<void> {\n    // eslint-disable-next-line security/detect-object-injection\n    const subscription = this.#nodeSubscriptions[nodeId];\n    if (!subscription) {\n      return;\n    }\n\n    await subscription.terminate();\n    // eslint-disable-next-line security/detect-object-injection\n    delete this.#nodeSubscriptions[nodeId];\n    this.#logger.debug(`Unsubscribed from ${nodeId}`);\n  }\n\n  async browseNode(nodeId: NodeIdLike, depth = 0): Promise<void> {\n    const indentation = ' '.repeat(depth * 2);\n\n    try {\n      // Read standard attributes\n      const nodeToRead = [\n        { nodeId, attributeId: AttributeIds.BrowseName },\n        { nodeId, attributeId: AttributeIds.DisplayName },\n        { nodeId, attributeId: AttributeIds.Description },\n        { nodeId, attributeId: AttributeIds.NodeClass },\n        { nodeId, attributeId: AttributeIds.DataType },\n        { nodeId, attributeId: AttributeIds.Value },\n      ];\n\n      const dataValues: Array<DataValue> =\n        await this.#getClientSession.read(nodeToRead);\n\n      const browseName = dataValues[0]?.value?.value ?? 'N/A';\n      const displayName = dataValues[1]?.value?.value ?? 'N/A';\n      const description = dataValues[2]?.value?.value ?? '';\n      const nodeClass = NodeClass[dataValues[3]?.value?.value] ?? 'Unknown';\n      const dataType = dataValues[4]?.value?.value ?? 'N/A';\n      const value = dataValues[5]?.value?.value ?? 'N/A';\n\n      this.#logger.debug(`${indentation}${browseName} | NodeId: ${nodeId}`);\n      this.#logger.debug(`${indentation}  DisplayName : ${displayName}`);\n      this.#logger.debug(`${indentation}  Description : ${description}`);\n      this.#logger.debug(`${indentation}  NodeClass   : ${nodeClass}`);\n      this.#logger.debug(`${indentation}  DataType    : ${dataType}`);\n      this.#logger.debug(\n        `${indentation}  Value       : ${JSON.stringify(value)}`,\n      );\n\n      // Browse children\n      const browseResult = await this.#getClientSession.browse({\n        nodeId,\n        referenceTypeId: null,\n        includeSubtypes: true,\n        browseDirection: BrowseDirection.Forward,\n        resultMask: 0x3f, // all\n      });\n\n      if (browseResult.references?.length === 0 && depth === 0) {\n        this.#logger.warn(`${indentation}  No child nodes found.`);\n      }\n\n      await Promise.all(\n        (browseResult.references ?? []).map((ref) =>\n          this.browseNode(ref.nodeId.toString(), depth + 1),\n        ),\n      );\n    } catch (error) {\n      this.#logger.error(\n        `${indentation}Failed to browse node ${nodeId}:`,\n        error,\n      );\n    }\n  }\n\n  /**\n   * Parse DSL like:\n   * call nsu=http://bystronic.com/ByVisionCutting/;s=History -> GetRunPartHistory(\"...\", \"...\", 0, 100)\n   */\n  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n  #parseDslWithNamespaceUri(dsl: string) {\n    const callRegex =\n      /^call\\s+nsu=([^;]+);(s|i)=([^ ]+)\\s*->\\s*(s|i)=([^(\\s]+)\\((.*)\\)$/;\n    const readRegex = /^read\\s+nsu=([^;]+);(s|i)=([^ ]+)$/;\n\n    const callMatch = dsl.match(callRegex);\n    if (callMatch) {\n      const [\n        ,\n        namespaceUri,\n        objectIdType,\n        objectIdValue,\n        methodIdType,\n        methodIdValue,\n        argStr,\n      ] = callMatch;\n\n      const objectNodeId = `ns=0;${objectIdType}=${objectIdValue}`;\n      const methodNodeId = `ns=0;${methodIdType}=${methodIdValue}`;\n\n      const args = argStr.length\n        ? argStr.split(',').map(this.#parseArgument)\n        : [];\n\n      return {\n        type: 'call',\n        namespaceUri,\n        objectNodeId,\n        methodNodeId,\n        inputArguments: args,\n      };\n    }\n\n    const readMatch = dsl.match(readRegex);\n    if (readMatch) {\n      const [, namespaceUri, nodeIdType, nodeIdValue] = readMatch;\n\n      const nodeId = `ns=0;${nodeIdType}=${nodeIdValue}`;\n\n      return {\n        type: 'read',\n        namespaceUri,\n        nodeId,\n      };\n    }\n\n    throw new Error('Invalid DSL format');\n  }\n\n  /**\n   * Infer the correct OPC UA Variant from a literal string\n   */\n  #parseArgument(raw: string): Variant {\n    const str = raw.trim();\n\n    // GUID pattern\n    // eslint-disable-next-line security/detect-unsafe-regex\n    const guidRegex = /^[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$/;\n\n    // Quoted strings (check for DateTime or Guid pattern inside)\n    if (/^\".+\"$/.test(str)) {\n      const val = str.slice(1, -1);\n\n      if (guidRegex.test(val)) {\n        return new Variant({\n          dataType: DataType.Guid,\n          value: val,\n        });\n      }\n\n      if (/\\d{4}-\\d{2}-\\d{2}T/.test(val)) {\n        return new Variant({\n          dataType: DataType.DateTime,\n          value: new Date(val),\n        });\n      }\n\n      return new Variant({\n        dataType: DataType.String,\n        value: val,\n      });\n    }\n\n    if (/^\\d+$/.test(str)) {\n      return new Variant({\n        dataType: DataType.Int32,\n        value: parseInt(str, 10),\n      });\n    }\n\n    if (/^\\d+\\.\\d+$/.test(str)) {\n      return new Variant({\n        dataType: DataType.Double,\n        value: parseFloat(str),\n      });\n    }\n\n    if (str === 'true' || str === 'false') {\n      return new Variant({\n        dataType: DataType.Boolean,\n        value: str === 'true',\n      });\n    }\n\n    throw new Error(`Unrecognized argument: ${str}`);\n  }\n\n  async #resolveNamespaceIndex(namespaceUri: string): Promise<number> {\n    const namespaces = await this.readValue<Array<string>>(\n      this.#opcuaConfig.namespaceNodeId ?? this.#OPCUA_NAMESPACE_NODE_ID,\n    );\n    this.#logger.debug('Retrieved namespaces:', namespaces);\n\n    const index = namespaces?.indexOf(namespaceUri);\n    if (index === undefined || index === -1) {\n      this.#logger.error('Namespace URI not found:', namespaceUri, namespaces);\n      throw new Error('Namespace index not found');\n    }\n\n    return index;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
