{
  "version": 3,
  "sources": ["../../../../../../../libs/microsoft-office365-mail-client/src/lib/office365-mail-parser.ts"],
  "sourcesContent": ["import { Readable } from 'node:stream';\n\nimport pdf2md from '@opendocsg/pdf2md';\nimport { htmlToText } from 'html-to-text';\nimport { AddressObject, Attachment, ParsedMail } from 'mailparser';\n\nimport { Office365Mail } from './office365-types';\nimport { MailAttachment, MailMessage } from './types';\n\nexport class Office365MailParser {\n  async parsedToMailMessage(\n    mail: Office365Mail,\n    parsed: ParsedMail,\n    receivedFallback: Date,\n  ): Promise<MailMessage> {\n    const date = parsed.date ?? receivedFallback;\n\n    const headers: Array<{ key: string; header: string }> = [];\n    const headerLines: Array<{ key: string; line: string }> = [];\n\n    // mailparser exposes both structured and raw-ish headerLines\n    parsed.headers.forEach((value, key) => {\n      headers.push({\n        key: String(key),\n        header: Array.isArray(value) ? value.join(', ') : String(value),\n      });\n    });\n    parsed.headerLines.forEach(({ key, line }) => {\n      headerLines.push({ key, line });\n    });\n\n    const to = this.#extractAddrList(parsed.to);\n    const cc = this.#extractAddrList(parsed.cc);\n    const bcc = this.#extractAddrList(parsed.bcc);\n    const from = this.#extractAddrList(parsed.from);\n    const replyTo = this.#extractAddrList(parsed.replyTo);\n\n    // Prefer HTML if present, but also supply text via htmlToText for consistency with Graph behavior.\n    const html = typeof parsed.html === 'string' ? parsed.html : undefined;\n    const text = parsed.text || (html ? htmlToText(html) : '');\n\n    return {\n      deltaTimestamp: receivedFallback.getTime(),\n      deltaId: mail.id,\n      id: mail.id,\n      originalMessageId: mail.internetMessageId,\n      attachmentsCount: (parsed.attachments ?? []).length,\n      attachments: await this.#parseAttachments(parsed.attachments ?? []),\n      headers,\n      headerLines,\n      subject: parsed.subject || undefined,\n      references: parsed.references || undefined,\n      date,\n      to,\n      from,\n      cc,\n      bcc,\n      replyTo,\n      text: (text || '').trim(),\n      html,\n      messageId: parsed.messageId || undefined,\n      inReplyTo: parsed.inReplyTo || undefined,\n    } as MailMessage;\n  }\n\n  formatMailReplyBody(orig: Office365Mail, body: string): string {\n    // Format Outlook-style separator and metadata\n    const origFrom = orig.from?.emailAddress?.address || '';\n    const origTo =\n      orig.toRecipients\n        ?.map((r) => r.emailAddress?.address)\n        .filter(Boolean)\n        .join('; ') || '';\n    const origSubject = orig.subject || '';\n    const origDate = orig.sentDateTime\n      ? new Date(orig.sentDateTime).toLocaleString()\n      : '';\n    const separator =\n      `<br><hr style=\"border:none;border-top:solid #b1b1b1 1px;height:1px;margin:16px 0 8px 0;\" /><br>` +\n      `From: ${origFrom}<br>` +\n      `Sent: ${origDate}<br>` +\n      `To: ${origTo}<br>` +\n      `Subject: ${origSubject}<br><br>`;\n    const origBody = orig.body?.content || '';\n\n    return `${body}${separator}${origBody}`;\n  }\n\n  #extractAddrList(\n    field?: AddressObject | Array<AddressObject>,\n  ): Array<string> | undefined {\n    if (!field) {\n      return undefined;\n    }\n\n    const pluck = (x: any): Array<string> | undefined => {\n      if (!x || typeof x !== 'object') {\n        return [];\n      }\n\n      // address object: { address?: string }\n      if ('address' in x && typeof x.address === 'string' && x.address) {\n        return [x.address];\n      }\n      // group object: { group?: AddressObject[] }\n      if ('group' in x && Array.isArray((x as any).group)) {\n        return (x as any).group.flatMap(pluck);\n      }\n      return [];\n    };\n\n    // mailparser v3 style: { value: AddressObject[] }\n    if ('value' in field && Array.isArray(field.value)) {\n      const out = field.value.flatMap(pluck).filter(Boolean);\n      return out.length ? out : undefined;\n    }\n\n    // mailparser v2 style: AddressObject | AddressObject[]\n    if (Array.isArray(field)) {\n      const out = field.flatMap(pluck).filter(Boolean);\n      return out.length ? out : undefined;\n    }\n\n    const out = pluck(field).filter(Boolean);\n    return out.length ? out : undefined;\n  }\n\n  async #parseAttachments(\n    attachments: Array<Attachment>,\n  ): Promise<Array<MailAttachment>> {\n    return (\n      await Promise.all(\n        attachments.map(async (att): Promise<MailAttachment | undefined> => {\n          const isJson =\n            att.contentType?.toLowerCase().includes('application/json') ||\n            att.filename?.toLowerCase().endsWith('.json');\n\n          const parsedPdfToJson = await this.#addPdfJsonAttachment(att);\n          if (!parsedPdfToJson && !isJson) {\n            return undefined;\n          }\n\n          // eslint-disable-next-line no-param-reassign\n          att = parsedPdfToJson ?? att;\n\n          const buf = Buffer.isBuffer(att.content)\n            ? att.content\n            : await new Promise<Buffer>((resolve, reject) => {\n                const chunks: Array<Buffer> = [];\n                (att.content as any)?.on?.('data', (c: Buffer) =>\n                  chunks.push(c),\n                );\n                (att.content as any)?.once?.('end', () =>\n                  resolve(\n                    Buffer.concat(\n                      chunks as unknown as ReadonlyArray<Uint8Array>,\n                    ),\n                  ),\n                );\n                (att.content as any)?.once?.('error', reject);\n              });\n\n          return {\n            id: att.cid,\n            filename: att.filename || 'attachment.json',\n            contentType: 'application/json',\n            content: buf.toString('utf-8'),\n          };\n        }),\n      )\n    ).filter((att) => !!att);\n  }\n\n  async #addPdfJsonAttachment(\n    attachment: Attachment,\n  ): Promise<Attachment | null> {\n    const isPdf =\n      attachment.contentType?.toLowerCase().includes('application/pdf') ||\n      attachment.filename?.toLowerCase().endsWith('.pdf');\n\n    if (!isPdf) {\n      return null;\n    }\n\n    const buf = await this.#streamToBuffer(attachment.content);\n    const pdfParsed = await pdf2md(buf);\n\n    const filename = `${attachment.filename?.replace(/\\.pdf$/i, '') || 'attachment'}.json`;\n\n    return {\n      ...attachment,\n      filename,\n      contentType: 'application/json',\n      content: Buffer.from(pdfParsed),\n    } as Attachment;\n  }\n\n  async #streamToBuffer(stream: Buffer | Readable): Promise<Buffer> {\n    if (Buffer.isBuffer(stream)) {\n      return stream;\n    }\n\n    return new Promise((resolve, reject) => {\n      const chunks: Array<Buffer> = [];\n      stream.on('data', (c: Buffer) => chunks.push(c));\n      stream.once('end', () =>\n        resolve(Buffer.concat(chunks as unknown as ReadonlyArray<Uint8Array>)),\n      );\n      stream.once('error', reject);\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["out", "pdf2md"]
}
