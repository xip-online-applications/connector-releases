{
  "version": 3,
  "sources": ["../../../../../../../libs/microsoft-office365-mail-client/src/lib/office365-client.ts"],
  "sourcesContent": ["import https from 'node:https';\nimport * as querystring from 'node:querystring';\nimport { Readable } from 'node:stream';\n\nimport pdf2md from '@opendocsg/pdf2md';\nimport { Attachment, ParsedMail, simpleParser } from 'mailparser';\n\nimport {\n  EMAIL_SELECTABLE_FIELD,\n  Office365Folder,\n  Office365FolderList,\n  Office365Mail,\n  Office365MailAttachment,\n  Office365MailAttachmentList,\n  Office365MailCategories,\n  Office365MailList,\n  WELL_KNOWN_EMAIL_BOXES,\n} from './office365-types';\n\nexport class Office365Client {\n  /**\n   * The base URL in the MS Graph API for the user.\n   *\n   * @example https://graph.microsoft.com/v1.0/users/{user}\n   */\n  readonly #base: string;\n\n  readonly #emlTestMode: boolean = false;\n\n  #token: string | undefined;\n\n  constructor(userPrincipalName: string, emlTestMode = false) {\n    this.#base = `https://graph.microsoft.com/v1.0/users/${encodeURIComponent(\n      userPrincipalName,\n    )}`;\n    this.#emlTestMode = emlTestMode;\n  }\n\n  async init(\n    tenantId: string,\n    clientId: string,\n    clientSecret: string,\n  ): Promise<void> {\n    this.#token = await this.#getAccessToken(tenantId, clientId, clientSecret);\n  }\n\n  async getFolder(\n    displayName: string,\n    topMailboxes = 100,\n  ): Promise<Office365Folder | null> {\n    const loweredDisplayName = displayName.toLowerCase();\n\n    // Try well-known names directly: /mailFolders/{displayName}\n    if (WELL_KNOWN_EMAIL_BOXES.includes(loweredDisplayName)) {\n      const data = await this.#graphRequest<Office365Folder>(\n        `${this.#base}/mailFolders/${encodeURIComponent(displayName)}`,\n      );\n\n      if (data?.id) {\n        return data;\n      }\n    }\n\n    // Otherwise list top folders and match by displayName\n    const data = await this.#graphRequest<Office365FolderList>(\n      `${this.#base}/mailFolders?$top=${topMailboxes}`,\n    );\n\n    return (\n      data?.value?.find(\n        (folder) => folder.displayName?.toLowerCase() === loweredDisplayName,\n      ) ?? null\n    );\n  }\n\n  async getMail(messageId: string): Promise<Office365Mail | null> {\n    const params = new URLSearchParams();\n    params.set('$filter', `internetMessageId eq '${messageId}'`);\n\n    const searchResult = await this.#graphRequest<Office365MailList>(\n      `${this.#base}/messages?${params.toString()}`,\n    );\n\n    return searchResult.value?.[0] ?? null;\n  }\n\n  async getMails(\n    folderId: string,\n    limit = 100,\n    fromEpochMs = 0,\n  ): Promise<Array<Office365Mail>> {\n    // Use lastModifiedDateTime to capture moves/edits\n    const iso = new Date(fromEpochMs).toISOString();\n\n    const params = new URLSearchParams();\n    params.set('$select', EMAIL_SELECTABLE_FIELD.join(','));\n    params.set('$orderby', 'lastModifiedDateTime asc');\n    params.set('$filter', `lastModifiedDateTime ge ${iso}`);\n    params.set('$top', limit.toString());\n\n    const out: Array<Office365Mail> = [];\n\n    let url = `${this.#base}/mailFolders/${folderId}/messages?${params.toString()}`;\n    while (url && url !== '') {\n      // eslint-disable-next-line no-await-in-loop\n      const page = await this.#graphRequest<Office365MailList>(url);\n\n      if (page?.value?.length) {\n        out.push(...page.value);\n      }\n\n      url = page?.['@odata.nextLink'] || null;\n    }\n\n    return out;\n  }\n\n  async getFullMail(folderId: string, mailId: string): Promise<ParsedMail> {\n    // always build a ParsedMail first (IMAP-compatible processing)\n    let mimeBuf: Buffer | null = null;\n\n    if (this.#emlTestMode !== false) {\n      // test mode: prefer attached .eml if present\n      mimeBuf = await this.#tryGetEmlBuffer(folderId, mailId);\n    }\n\n    if (!mimeBuf) {\n      // fallback (and production): raw MIME of the message itself\n      mimeBuf = await this.#downloadMessageMime(folderId, mailId);\n    }\n\n    const parsed = await simpleParser(mimeBuf);\n\n    // run the same attachment pipeline as IMAP (adds *.json virtual atts for PDFs)\n    parsed.attachments = await this.#addPdfJsonAttachments(parsed);\n\n    return parsed;\n  }\n\n  getMailCategories(messageId: string): Promise<Office365MailCategories> {\n    return this.#graphRequest<Office365MailCategories | undefined>(\n      `${this.#base}/messages/${encodeURIComponent(\n        messageId,\n      )}?$select=categories`,\n      'GET',\n      undefined,\n      {\n        Prefer: 'outlook.body-content-type=\"text\"',\n      },\n    );\n  }\n\n  async updateMailCategories(\n    messageId: string,\n    categories: Office365MailCategories,\n  ): Promise<void> {\n    await this.#graphRequest(\n      `${this.#base}/messages/${encodeURIComponent(messageId)}`,\n      'PATCH',\n      categories,\n    );\n  }\n\n  async createReply(\n    messageId: string,\n    body?: string,\n    from?: string,\n  ): Promise<Office365Mail> {\n    const draft = await this.#graphRequest<Office365Mail>(\n      `${this.#base}/messages/${encodeURIComponent(messageId)}/createReply`,\n      'POST',\n    );\n\n    if (!body && !from) {\n      return draft;\n    }\n\n    await this.#graphRequest(\n      `${this.#base}/messages/${encodeURIComponent(messageId)}`,\n      'PATCH',\n      {\n        body: body\n          ? {\n              contentType: 'html',\n              content: body,\n            }\n          : undefined,\n        from: from ? { emailAddress: { address: from } } : undefined,\n      },\n    );\n\n    return draft;\n  }\n\n  sendMail(messageId: string): Promise<void> {\n    return this.#graphRequest(\n      `${this.#base}/messages/${encodeURIComponent(messageId)}/send`,\n      'POST',\n    );\n  }\n\n  moveMailToFolder(messageId: string, folderId: string): Promise<void> {\n    return this.#graphRequest(\n      `${this.#base}/messages/${encodeURIComponent(messageId)}/move`,\n      'POST',\n      {\n        destinationId: folderId,\n      },\n    );\n  }\n\n  #getAccessToken(\n    tenantId: string,\n    clientId: string,\n    clientSecret: string,\n  ): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const postData = querystring.stringify({\n        client_id: clientId,\n        scope: 'https://graph.microsoft.com/.default',\n        client_secret: clientSecret,\n        grant_type: 'client_credentials',\n      });\n\n      const options = {\n        hostname: 'login.microsoftonline.com',\n        path: `/${tenantId}/oauth2/v2.0/token`,\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'Content-Length': Buffer.byteLength(postData),\n        },\n      };\n\n      const req = https.request(options, (res) => {\n        let data = '';\n\n        res.on('data', (chunk) => {\n          data += chunk;\n        });\n\n        res.on('end', () => {\n          try {\n            const parsed = JSON.parse(data);\n            resolve(parsed.access_token);\n          } catch (err) {\n            reject(err);\n          }\n        });\n      });\n\n      req.on('error', (e) => {\n        reject(e);\n      });\n      req.write(postData);\n      req.end();\n    });\n  }\n\n  async #graphRequest<T = unknown>(\n    urlStr: string,\n    method: 'GET' | 'POST' | 'PATCH' = 'GET',\n    body: unknown | undefined = undefined,\n    extraHeaders: Record<string, string> | undefined = undefined,\n  ): Promise<T | undefined> {\n    if (!this.#token) {\n      throw new Error('Graph token missing (call init())');\n    }\n\n    const url = new URL(urlStr);\n    const payload =\n      body === undefined\n        ? undefined\n        : Buffer.from(JSON.stringify(body), 'utf-8');\n\n    const options: https.RequestOptions = {\n      method,\n      hostname: url.hostname,\n      path: url.pathname + url.search,\n      protocol: url.protocol,\n      port: url.port || 443,\n      headers: {\n        Authorization: `Bearer ${this.#token}`,\n        'Content-Type': 'application/json',\n        Accept: 'application/json',\n        ...(payload ? { 'Content-Length': String(payload.length) } : {}),\n        ...(extraHeaders || {}),\n      },\n    };\n\n    return new Promise<T | undefined>((resolve, reject) => {\n      const req = https.request(options, (res) => {\n        const chunks: Array<Buffer> = [];\n        res.on('data', (d) => chunks.push(Buffer.from(d)));\n        res.on('end', () => {\n          const status = res.statusCode || 0;\n          const raw = Buffer.concat(chunks).toString('utf-8');\n\n          if (status >= 200 && status < 300) {\n            if (!raw) return resolve(undefined);\n            const ct = (res.headers['content-type'] || '')\n              .toString()\n              .split(';')[0]\n              .trim();\n            if (ct === 'application/json') {\n              try {\n                return resolve(JSON.parse(raw));\n              } catch {\n                return resolve(undefined);\n              }\n            } else {\n              // non-JSON success (rare in Graph), just return as-is\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              return resolve(raw as any);\n            }\n          } else if (status === 204) {\n            return resolve(undefined);\n          } else {\n            return reject(\n              new Error(\n                `Graph ${method} ${url.pathname}${url.search} failed: ${status} ${raw}`,\n              ),\n            );\n          }\n        });\n      });\n      req.on('error', reject);\n      if (payload) req.write(payload);\n      req.end();\n    });\n  }\n\n  async #downloadMessageMime(\n    folderId: string,\n    messageId: string,\n  ): Promise<Buffer> {\n    return this.#graphRequest<Buffer>(\n      `${this.#base}/mailFolders/${folderId}/messages/${messageId}/$value`,\n    );\n  }\n\n  async #tryGetEmlBuffer(\n    folderId: string,\n    messageId: string,\n  ): Promise<Buffer | null> {\n    const attachments = await this.#listAttachments(folderId, messageId);\n\n    // 1) fileAttachment with contentType message/rfc822 or name ends with .eml\n    const fileEml = attachments.find(\n      (attachment) =>\n        attachment['@odata.type'] === '#microsoft.graph.fileAttachment' &&\n        ((attachment.contentType || '').toLowerCase() === 'message/rfc822' ||\n          String(attachment.name || attachment.fileName || '')\n            .toLowerCase()\n            .endsWith('.eml')),\n    );\n\n    if (fileEml?.contentBytes) {\n      // @ts-expect-error contentBytes is base64-encoded string\n      return Buffer.from(fileEml.contentBytes, 'base64');\n    }\n\n    if (fileEml?.id) {\n      // Download via $value just in case contentBytes was trimmed\n      return this.#graphRequest<Buffer>(\n        `${this.#base}/mailFolders/${folderId}/messages/${messageId}/attachments/${encodeURIComponent(fileEml.id)}/$value`,\n      );\n    }\n\n    // 2) itemAttachment (embedded message)\n    const item = attachments.find(\n      (a) =>\n        a['@odata.type'] === '#microsoft.graph.itemAttachment' &&\n        (a.item?.['@odata.type'] === '#microsoft.graph.message' ||\n          a.contentType === 'message/rfc822'),\n    );\n\n    if (item?.id) {\n      return this.#graphRequest<Buffer>(\n        `${this.#base}/mailFolders/${folderId}/messages/${messageId}/attachments/${encodeURIComponent(item.id)}/$value`,\n      ); // raw MIME stream\n    }\n\n    return null;\n  }\n\n  async #listAttachments(\n    folderId: string,\n    messageId: string,\n    limit = 50,\n  ): Promise<Array<Office365MailAttachment>> {\n    const data = await this.#graphRequest<Office365MailAttachmentList>(\n      `${this.#base}/mailFolders/${folderId}/messages/${messageId}/attachments?$expand=microsoft.graph.itemAttachment/item&$top=${limit}`,\n      'GET',\n    );\n\n    return data?.value || [];\n  }\n\n  async #addPdfJsonAttachments(parsed: ParsedMail): Promise<Array<Attachment>> {\n    if (!Array.isArray(parsed.attachments) || parsed.attachments.length === 0) {\n      return [];\n    }\n\n    const jsonAtts = await Promise.all(\n      parsed.attachments.map(async (attachment): Promise<Attachment | null> => {\n        const isPdf =\n          attachment.contentType?.toLowerCase().includes('application/pdf') ||\n          attachment.filename?.toLowerCase().endsWith('.pdf');\n\n        if (!isPdf) {\n          return null;\n        }\n\n        const buf = await this.#streamToBuffer(attachment.content);\n        const pdfParsed = await pdf2md(buf);\n\n        const filename = `${attachment.filename?.replace(/\\.pdf$/i, '') || 'attachment'}.json`;\n\n        return {\n          ...attachment,\n          filename,\n          contentType: 'application/json',\n          content: Buffer.from(pdfParsed),\n        } as Attachment;\n      }),\n    );\n\n    return jsonAtts.filter((attachment) => !!attachment);\n  }\n\n  async #streamToBuffer(stream: Buffer | Readable): Promise<Buffer> {\n    if (Buffer.isBuffer(stream)) {\n      return stream;\n    }\n\n    return new Promise((resolve, reject) => {\n      const chunks: Array<Buffer> = [];\n      stream.on('data', (c: Buffer) => chunks.push(c));\n      stream.once('end', () => resolve(Buffer.concat(chunks)));\n      stream.once('error', reject);\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["data", "https", "pdf2md"]
}
