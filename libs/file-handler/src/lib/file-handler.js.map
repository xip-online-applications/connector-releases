{
  "version": 3,
  "sources": ["../../../../../../../libs/file-handler/src/lib/file-handler.ts"],
  "sourcesContent": ["/* eslint-disable class-methods-use-this */\nimport xml2js from 'xml2js';\nimport csvtojson from 'csvtojson';\nimport * as path from 'path';\nimport { Logger } from '@transai/logger';\nimport { Readable } from 'stream';\n\nexport interface ParsedFile {\n  [key: string]: unknown;\n}\n\nexport class FileHandler {\n  readonly #delimiter: string | undefined;\n\n  readonly #logger: Logger;\n\n  constructor(delimiter: string | undefined = undefined) {\n    this.#delimiter = delimiter;\n    this.#logger = Logger.getInstance();\n\n    this.#logger.info(`FileHandler initialized with delimiter: ${delimiter}`);\n  }\n\n  public async handleBuffer(\n    file: string,\n    content: Buffer,\n    optionalHeaders: Array<string>,\n    optionalSettings?: {\n      [key: string]: unknown;\n    },\n  ) {\n    let parsedContent: ParsedFile;\n    const fileType = FileHandler.getExtension(file);\n\n    // check file type\n    switch (fileType) {\n      case '.csv':\n        parsedContent = await this.parseCSV(\n          content,\n          optionalHeaders,\n          optionalSettings,\n        );\n        break;\n      default:\n        return this.handle(\n          file,\n          content.toString(),\n          optionalHeaders,\n          optionalSettings,\n        );\n    }\n\n    return parsedContent;\n  }\n\n  public async handle(\n    file: string,\n    content: string,\n    optionalHeaders: Array<string>,\n    optionalSettings?: {\n      [key: string]: unknown;\n    },\n  ) {\n    let parsedContent: ParsedFile | undefined;\n    const fileType = FileHandler.getExtension(file);\n\n    // check file type\n    switch (fileType) {\n      case '.xml':\n        parsedContent = await this.parseXML(content, optionalHeaders);\n        break;\n      case '.json':\n        parsedContent = JSON.parse(content);\n        break;\n      default:\n        Logger.getInstance().error(`Unsupported file type: ${file}`);\n    }\n\n    return parsedContent;\n  }\n\n  public async parseXML(\n    content: string,\n    optionalHeaders: Array<string>,\n  ): Promise<ParsedFile> {\n    try {\n      const data = await xml2js.parseStringPromise(content, {\n        explicitArray: false,\n      });\n      return this.xmlOptions(data, optionalHeaders);\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (error: any) {\n      throw new Error(`Error parsing XML content: ${error.message}`);\n    }\n  }\n\n  public async parseCSV(\n    content: Buffer,\n    optionalHeaders: Array<string>,\n    optionalSettings?: {\n      [key: string]: unknown;\n    },\n  ): Promise<ParsedFile> {\n    try {\n      const stream = Readable.from(content);\n      let noHeader = true;\n      const optionalSettingsKeys = Object.keys(optionalSettings ?? {});\n      if (optionalSettingsKeys.includes('noHeader')) {\n        noHeader = (optionalSettings ?? {})['noHeader'] === true;\n      }\n\n      // const csvOptions = this.csvOptions(content, optionalHeaders); TODO if needed specific csv header options.\n      return csvtojson({\n        delimiter: this.#delimiter ?? ',',\n        noheader: noHeader,\n      }).fromStream(stream) as unknown as ParsedFile;\n    } catch (error: any) {\n      this.#logger.error(`Error parsing CSV: ${error.message}`);\n      throw new Error(`Error parsing CSV content: ${error.message}`);\n    }\n  }\n\n  private xmlOptions(\n    content: object,\n    headersRequiredAsArray: Array<string>,\n  ): ParsedFile {\n    const processElement = (element: { [key: string]: any }): ParsedFile => {\n      if (typeof element === 'object') {\n        // eslint-disable-next-line no-restricted-syntax\n        for (const key of Object.keys(element)) {\n          const value = element[key];\n\n          // Check if the current key matches any of the optional headers\n          if (headersRequiredAsArray.includes(key)) {\n            if (!Array.isArray(value)) {\n              // If it's not an array, convert it to an array with one element\n              // eslint-disable-next-line no-param-reassign\n              element[key] = [value];\n            }\n          } else if (key !== '_text') {\n            // Recursively process other elements, excluding _text\n            // eslint-disable-next-line no-param-reassign\n            element[key] = processElement(value);\n          }\n        }\n      }\n\n      return element as ParsedFile;\n    };\n\n    // Process the content starting from the root\n    return processElement(content);\n  }\n\n  private csvOptions(content: string, optionalHeaders: Array<string>): object {\n    // TODO: headers met cijfers etc te kunnen filteren voor indien het nodig is. Voor nu gebruiken we dit niet.\n    let option: object;\n\n    if (Array.isArray(optionalHeaders) && optionalHeaders.length > 0) {\n      option = { headers: optionalHeaders };\n    } else {\n      const lines = content.split('\\n');\n\n      const firstLine = lines[0].trim();\n      const headers = firstLine.split(',');\n\n      option = headers.length > 1 ? { headers: true } : { noheader: true };\n    }\n\n    return option;\n  }\n\n  public stringify(destination: string): string {\n    return JSON.stringify(destination, null, 2);\n  }\n\n  public static getPath(file: string): string {\n    return path.dirname(file);\n  }\n\n  public static getFileName(file: string): string {\n    return path.basename(file);\n  }\n\n  public static getExtension(file: string): string {\n    return path.extname(file).toLowerCase();\n  }\n}\n"],
  "mappings": "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",
  "names": ["xml2js", "csvtojson"]
}
