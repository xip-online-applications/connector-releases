{
  "version": 3,
  "sources": ["../../../../../../../../libs/connector-runner-file-source/src/lib/filesource-processor/filesource-processor.service.ts"],
  "sourcesContent": ["// Disable some ESLinting to ensure sequential handling of data.\n// DO NOT PROCESS FILES IN PARALLEL!\n/* eslint-disable no-await-in-loop */\n/* eslint-disable no-continue */\n/* eslint-disable no-restricted-syntax */\nimport { FileHandler, ParsedFile } from '@xip-online-data/file-handler';\nimport { FileInfo } from 'ssh2-sftp-client';\nimport { interval, Subscription } from 'rxjs';\nimport {\n  BaseConnectorConfig,\n  FileActionType,\n  FileRegex,\n  XodSourceMessageType,\n  XodSourcePayloadType,\n} from '@xip-online-data/types';\nimport { handleError } from '@xip-online-data/handle-error';\nimport { KafkaSourceInterface } from '@xip-online-data/kafka-base-service';\nimport { v4 as uuidv4 } from 'uuid';\nimport { Logger } from '@transai/logger';\nimport { SftpInterface } from '@xip-online-data/sftp-client';\nimport {\n  generateCollectionName,\n  generateKafkaTopic,\n} from '../helper.functions';\nimport { FileSourceConfig, FileSourceProcessConfig } from '../types';\n\nexport class FilesourceProcessorService {\n  #processing = false;\n\n  #numberOfImportedFilesPerSession = 0;\n\n  readonly #fileHandler: FileHandler;\n\n  readonly #fileSourceConfig: FileSourceConfig;\n\n  readonly #config: FileSourceProcessConfig & BaseConnectorConfig;\n\n  readonly #kafkaService: KafkaSourceInterface;\n\n  readonly #sftpClient: SftpInterface;\n\n  readonly #logger: Logger;\n\n  #subscription?: Subscription;\n\n  constructor(\n    fileSourceConfig: FileSourceConfig,\n    config: FileSourceProcessConfig & BaseConnectorConfig,\n    kafkaService: KafkaSourceInterface,\n    sftpClient: SftpInterface,\n  ) {\n    this.#fileSourceConfig = fileSourceConfig;\n    this.#config = config;\n    this.#kafkaService = kafkaService;\n    this.#sftpClient = sftpClient;\n    this.#fileHandler = new FileHandler(this.#fileSourceConfig.delimiter);\n    this.#logger = Logger.getInstance();\n  }\n\n  public async init(): Promise<void> {\n    this.#subscription = interval(\n      this.#fileSourceConfig.interval * 1000,\n    ).subscribe(async () => {\n      await this.process().catch((error) => {\n        this.#logger.error(\n          `Error while processing files from filesource processor service ${error.message}`,\n        );\n      });\n    });\n  }\n\n  stop() {\n    this.#subscription?.unsubscribe();\n  }\n\n  public async process(): Promise<void> {\n    if (this.#processing) {\n      this.#logger.debug(\n        `Filesource processor service is already processing: ${this.#fileSourceConfig.ftpIdentifier}`,\n      );\n      return;\n    }\n\n    this.#numberOfImportedFilesPerSession = 0;\n    this.#processing = true;\n\n    try {\n      let dir = this.#fileSourceConfig.root;\n      if (!dir.endsWith('/')) {\n        dir += '/';\n      }\n\n      await this.processDirectory(\n        `${dir}${this.#fileSourceConfig.directory}`,\n        this.#fileSourceConfig.fileSelector,\n      );\n    } catch (error) {\n      if (error instanceof Error) {\n        Logger.getInstance().error(error.message);\n      } else {\n        Logger.getInstance().error(\n          `Error while processing files ${JSON.stringify(error)}`,\n        );\n      }\n    } finally {\n      this.#processing = false;\n    }\n  }\n\n  private async processDirectory(\n    directory: string,\n    fileSelector?: FileRegex,\n  ): Promise<void> {\n    this.#logger.debug(\n      `Processing directory: ${directory} with ${fileSelector?.pattern}`,\n    );\n    let files = await this.#sftpClient.list(directory);\n    this.#logger.debug(\n      `Number Files in directory ${directory}: ${files.map((f) => f.name).join(', ')}`,\n    );\n\n    if (fileSelector) {\n      const regex = new RegExp(fileSelector.pattern, fileSelector.flags);\n      files = files.filter((f) => regex.test(f.name) || f.type === 'd');\n      this.#logger.debug(\n        `Number Files in directory after regex filtering: ${files.length}`,\n      );\n    }\n\n    await this.processFile(directory, files, fileSelector).catch((error) => {\n      handleError('Error while initializing the app', error);\n    });\n  }\n\n  private async processFile(\n    directory: string,\n    files: Array<FileInfo>,\n    fileSelector?: FileRegex,\n  ): Promise<void> {\n    for (const file of files) {\n      const path = `${directory}/${file.name}`;\n\n      if (this.#fileSourceConfig.recursive === true) {\n        if (file.type === 'd') {\n          await this.processDirectory(path, fileSelector);\n          continue;\n        }\n      }\n\n      if (file.type === 'l') {\n        continue;\n      }\n\n      if (file.type === '-') {\n        this.#logger.debug(`Processing file: ${path}`);\n        this.#numberOfImportedFilesPerSession += 1;\n\n        // Read file content\n        const contentBuffer = await this.#sftpClient.readFile(path);\n        this.#logger.debug(`File ${path} read successfully`);\n\n        // Parse file to JSON using FileHandler based on file type\n        const parsedContent = await this.#fileHandler.handleBuffer(\n          path,\n          contentBuffer,\n          this.#fileSourceConfig.optionalHeaders ?? [],\n          this.#fileSourceConfig.optionalSettings,\n        );\n\n        this.#logger.debug(`File ${path} Parsed successfully`);\n\n        if (!parsedContent) {\n          continue;\n        }\n\n        if (this.#fileSourceConfig.type === 'metric') {\n          await this.sendMetricsToKafka(parsedContent, path);\n        } else {\n          await this.sendDocumentsToKafka(parsedContent, path);\n        }\n\n        // move or remove base file\n        await this.handleAction(\n          this.#fileSourceConfig.action,\n          path,\n          file,\n          `${this.#fileSourceConfig.root}/${this.#fileSourceConfig.processedDirectory}`,\n        );\n      }\n    }\n  }\n\n  public async handleAction(\n    action: FileActionType,\n    filePath: string,\n    file: FileInfo,\n    destinationPath: string,\n  ): Promise<void> {\n    switch (action) {\n      case FileActionType.ACTION_NOTHING:\n        return Promise.resolve();\n      case FileActionType.ACTION_MOVE:\n        return this.#sftpClient.moveFile(filePath, file, destinationPath);\n      case FileActionType.ACTION_DELETE:\n        return this.#sftpClient.deleteFile(filePath);\n      default:\n        throw new Error('Unknown action');\n    }\n  }\n\n  private sendMetricsToKafka = async (\n    contents: ParsedFile | Array<ParsedFile>,\n    path: string,\n  ): Promise<void> => {\n    let kafkaPayload: Array<XodSourceMessageType>;\n\n    if (Array.isArray(contents)) {\n      kafkaPayload = contents.map((content) => ({\n        type: 'SOURCE',\n        eventId: uuidv4(),\n        eventType: 'event.metric',\n        created: Date.now(),\n        ttl: 3600000, // 1 month\n        tenantIdentifier: this.#config.tenantIdentifier,\n        payload: this.buildPayload(content, path),\n      }));\n    } else {\n      kafkaPayload = [\n        {\n          type: 'SOURCE',\n          eventId: uuidv4(),\n          eventType: 'event.metric',\n          created: Date.now(),\n          ttl: 3600000, // 1 month\n          tenantIdentifier: this.#config.tenantIdentifier,\n          payload: this.buildPayload(contents, path),\n        },\n      ];\n    }\n\n    // Send JSON data to Kafka\n    await this.#kafkaService.send(\n      kafkaPayload,\n      generateKafkaTopic(this.#config, this.#fileSourceConfig),\n    );\n  };\n\n  private sendDocumentsToKafka = async (\n    parsedContent: ParsedFile,\n    path: string,\n  ): Promise<void> => {\n    const kafkaPayload: XodSourceMessageType = {\n      type: 'SOURCE',\n      eventId: uuidv4(),\n      eventType: `${this.#config.tenantIdentifier}_SOURCE_${this.#fileSourceConfig.ftpIdentifier}`,\n      created: Date.now(),\n      ttl: 3600000, // 1 month\n      tenantIdentifier: this.#config.tenantIdentifier,\n      payload: this.buildPayload(parsedContent, path),\n    };\n\n    // Send JSON data to Kafka\n    await this.#kafkaService.send(\n      [kafkaPayload],\n      generateKafkaTopic(this.#config, this.#fileSourceConfig),\n    );\n  };\n\n  private buildPayload = (\n    parsedContent: ParsedFile,\n    path: string,\n  ): XodSourcePayloadType => {\n    return {\n      body: {\n        ...parsedContent,\n        _filename: FileHandler.getFileName(path),\n      },\n      keyField: '_filename',\n      indexes: this.#fileSourceConfig.indexes ?? [],\n      incrementalField: '',\n      collection: generateCollectionName(this.#config, this.#fileSourceConfig),\n    };\n  };\n}\n"],
  "mappings": "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",
  "names": ["uuidv4"]
}
