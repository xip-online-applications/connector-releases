{
  "version": 3,
  "sources": ["../../../../../../../libs/kafka-base-service/src/lib/abstract.message-monitor.ts"],
  "sourcesContent": ["import {\n  BaseConnectorConfig,\n  KafkaCallbackResponse,\n  XodBaseMessageType,\n} from '@xip-online-data/types';\nimport { Logger } from '@transai/logger';\nimport { BadRequest } from './factories';\nimport { MessageMonitorInterface } from './message-monitor.interface';\n\nexport abstract class AbstractMessageMonitor\n  implements MessageMonitorInterface\n{\n  constructor(protected readonly baseConfig: BaseConnectorConfig) {}\n\n  protected abstract isProcessed(message: XodBaseMessageType): Promise<boolean>;\n\n  protected abstract addProcessedMessage(\n    message: XodBaseMessageType,\n  ): Promise<void>;\n\n  public processMessage(\n    callbackFunction: (\n      message: XodBaseMessageType,\n    ) => Promise<KafkaCallbackResponse>,\n  ): (message: XodBaseMessageType | any) => Promise<KafkaCallbackResponse> {\n    return async (message: XodBaseMessageType) => {\n      /**\n       * Check if message has already been processed\n       *\n       * Potential race-condition here if two messages with the same eventId are processed at the same time\n       * This is a known issue and is acceptable for the current use-case since the messages will arrive\n       * with a few seconds to a few minutes delay (minimal delay found was 10 seconds).\n       *\n       * Async is required for the Redis implementation to work\n       *\n       */\n      if (await this.isProcessed(message)) {\n        if (this.baseConfig.debug) {\n          Logger.getInstance().debug(\n            `Message ${message.eventId} already processed`,\n          );\n        }\n        return BadRequest(`Message ${message.eventId} already processed`)(\n          message,\n        );\n      }\n      if (this.baseConfig.debug) {\n        Logger.getInstance().debug(`Processing message ${message.eventId}`);\n      }\n\n      const result = await callbackFunction(message);\n\n      if (result.success) {\n        await this.addProcessedMessage(message);\n      } else if (this.baseConfig.debug)\n        Logger.getInstance().debug(\n          `Message ${message.eventId} FAILED to process: ${result.message}. Not storing in processed messages list.`,\n        );\n\n      return result;\n    };\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA,oBAAuB;AACvB,uBAA2B;AAGpB,MAAe,uBAEtB;AAAA,EACE,YAA+B,YAAiC;AAAjC;AAAA,EAAkC;AAAA,EAQ1D,eACL,kBAGuE;AACvE,WAAO,OAAO,YAAgC;AAW5C,UAAI,MAAM,KAAK,YAAY,OAAO,GAAG;AACnC,YAAI,KAAK,WAAW,OAAO;AACzB,+BAAO,YAAY,EAAE;AAAA,YACnB,WAAW,QAAQ,OAAO;AAAA,UAC5B;AAAA,QACF;AACA,mBAAO,6BAAW,WAAW,QAAQ,OAAO,oBAAoB;AAAA,UAC9D;AAAA,QACF;AAAA,MACF;AACA,UAAI,KAAK,WAAW,OAAO;AACzB,6BAAO,YAAY,EAAE,MAAM,sBAAsB,QAAQ,OAAO,EAAE;AAAA,MACpE;AAEA,YAAM,SAAS,MAAM,iBAAiB,OAAO;AAE7C,UAAI,OAAO,SAAS;AAClB,cAAM,KAAK,oBAAoB,OAAO;AAAA,MACxC,WAAW,KAAK,WAAW;AACzB,6BAAO,YAAY,EAAE;AAAA,UACnB,WAAW,QAAQ,OAAO,uBAAuB,OAAO,OAAO;AAAA,QACjE;AAEF,aAAO;AAAA,IACT;AAAA,EACF;AACF;",
  "names": []
}
