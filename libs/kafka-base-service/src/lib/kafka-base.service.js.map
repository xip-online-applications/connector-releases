{
  "version": 3,
  "sources": ["../../../../../../../libs/kafka-base-service/src/lib/kafka-base.service.ts"],
  "sourcesContent": ["import { Logger } from '@transai/logger';\nimport {\n  isTopicRegex,\n  isXodBaseMessageType,\n  KafkaCallbackResponse,\n  XodBaseMessageType,\n} from '@xip-online-data/types';\nimport { EachMessagePayload } from 'kafkajs';\n\nimport { AbstractKafkaService } from './abstract-kafka-service';\nimport { KafkaCallbackWrapper } from './types';\n\nexport class KafkaBaseService extends AbstractKafkaService {\n  private callbackWrappers = new Map<string, Array<KafkaCallbackWrapper>>();\n\n  protected initialized = false;\n\n  public setCallbackFunction(\n    callbackFunction: (\n      message: XodBaseMessageType,\n    ) => Promise<KafkaCallbackResponse>,\n    eventType: string = KafkaBaseService.DEFAULT_CALLBACK_EVENT_TYPE,\n    identifier = '',\n  ): void {\n    if (!this.callbackWrappers.has(eventType)) {\n      this.callbackWrappers.set(eventType, []);\n    }\n\n    let callback = callbackFunction;\n\n    if (this.messageMonitor !== undefined) {\n      callback = this.messageMonitor.processMessage(callback);\n    }\n\n    this.callbackWrappers.get(eventType)!.push({\n      callback,\n      identifier:\n        eventType === KafkaBaseService.DEFAULT_CALLBACK_EVENT_TYPE\n          ? this.baseYamlConfig.processIdentifier\n          : identifier,\n    });\n  }\n\n  public init = async (): Promise<void> => {\n    if (!this.initialized) {\n      await this.producer.connect();\n    }\n\n    const topics = this.baseYamlConfig.kafka.consumerTopics ?? [];\n    if (this.connectorTopic) {\n      Logger.getInstance().info(\n        `Default connector topic: ${this.connectorTopic}`,\n      );\n      topics.push(this.connectorTopic);\n    }\n    if (topics.length > 0) {\n      for (const topic of topics) {\n        if (isTopicRegex(topic)) {\n          await this.consumer.subscribe({\n            topic: new RegExp(topic.pattern, topic.flags),\n            fromBeginning: true,\n          });\n        } else if (typeof topic === 'string') {\n          await this.consumer.subscribe({ topic, fromBeginning: true });\n        } else {\n          throw new Error('Invalid topic type');\n        }\n      }\n\n      await this.consumer.run({\n        partitionsConsumedConcurrently:\n          this.baseYamlConfig.kafka.partitionsConsumedConcurrently ?? 1,\n        autoCommitInterval: this.baseYamlConfig.kafka.autoCommitInterval,\n        autoCommitThreshold: this.baseYamlConfig.kafka.autoCommitThreshold,\n        eachMessage: this.consume,\n      });\n    }\n\n    this.initialized = true;\n  };\n\n  private consume: (kafkaMessage: EachMessagePayload) => Promise<void> = async (\n    kafkaMessage: EachMessagePayload,\n  ) => {\n    const message = JSON.parse(kafkaMessage.message?.value?.toString() || '{}');\n\n    if (isXodBaseMessageType(message)) {\n      const interval = setInterval(() => {\n        kafkaMessage.heartbeat();\n      }, 5000);\n\n      try {\n        let callbackIdentifier = `${message.tenantIdentifier}_${message.eventType}`;\n\n        Logger.getInstance().verbose(\n          `Received message from topic ${callbackIdentifier}: ${JSON.stringify(message)}`,\n        );\n\n        if (!this.callbackWrappers.has(callbackIdentifier)) {\n          callbackIdentifier = KafkaBaseService.DEFAULT_CALLBACK_EVENT_TYPE;\n        }\n\n        const callbackWrapper = this.callbackWrappers.get(callbackIdentifier);\n\n        if (!callbackWrapper) {\n          Logger.getInstance().verbose(\n            `Callback function for topic ${callbackIdentifier} not set`,\n          );\n          return;\n        }\n\n        for (const callback of callbackWrapper) {\n          const result = await callback.callback(message);\n          await this.reportResult(message, result, callback.identifier);\n        }\n      } catch (error: any) {\n        Logger.getInstance().debug(\n          `Error processing message: ${error.message}`,\n        );\n      } finally {\n        clearInterval(interval);\n      }\n    } else {\n      Logger.getInstance().debug(\n        `Message nr ${kafkaMessage.message.offset} is not a valid XodActionType`,\n      );\n    }\n  };\n\n  private reportResult = async (\n    message: XodBaseMessageType,\n    result: KafkaCallbackResponse,\n    responseSource: string,\n  ): Promise<void> => {\n    if (this.disableLogs) {\n      Logger.getInstance().debug(\n        'Skipping report result due to disableLogs flag',\n      );\n      return;\n    }\n\n    const returnMessage = {\n      type: message.type,\n      message,\n      result,\n      responseSource,\n      timestamp: new Date().getTime(),\n    };\n\n    const topic = `${message.tenantIdentifier}${this.processedTopic}`;\n\n    Logger.getInstance().debug(\n      `Sending message to logs topic ${topic} ${JSON.stringify(returnMessage)}`,\n    );\n\n    await this.producer.send({\n      topic,\n      messages: [\n        {\n          value: JSON.stringify(returnMessage),\n        },\n      ],\n    });\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
