{
  "version": 3,
  "sources": ["../../../../../../../libs/kafka-base-service/src/lib/kafka-bulk-listener.service.ts"],
  "sourcesContent": ["import {\n  BaseConnectorConfig,\n  isTopicRegex,\n  XodBaseMessageType,\n} from '@xip-online-data/types';\nimport { EachBatchPayload, KafkaMessage } from 'kafkajs';\nimport { Logger } from '@transai/logger';\nimport { AbstractKafkaService } from './abstract-kafka-service';\n\nexport class KafkaBulkListenerService extends AbstractKafkaService {\n  public constructor(\n    baseYamlConfig: BaseConnectorConfig,\n    private readonly callbackFunction: (\n      messages: Array<XodBaseMessageType>,\n    ) => Promise<void>,\n    private readonly bulkApplicable: (\n      messages: Array<XodBaseMessageType>,\n    ) => boolean = () => true,\n  ) {\n    super(baseYamlConfig);\n  }\n\n  public init = async (): Promise<void> => {\n    // eslint-disable-next-line no-restricted-syntax\n    for (const topic of this.baseYamlConfig.kafka.consumerTopics ?? []) {\n      if (isTopicRegex(topic)) {\n        // eslint-disable-next-line no-await-in-loop\n        await this.consumer.subscribe({\n          topic: new RegExp(topic.pattern, topic.flags),\n          fromBeginning: true,\n        });\n      } else if (typeof topic === 'string') {\n        // eslint-disable-next-line no-await-in-loop\n        await this.consumer.subscribe({ topic, fromBeginning: true });\n      } else {\n        throw new Error('Invalid topic type');\n      }\n    }\n\n    await this.consumer.run({\n      partitionsConsumedConcurrently:\n        this.baseYamlConfig.kafka.partitionsConsumedConcurrently ?? 1,\n      autoCommitInterval: this.baseYamlConfig.kafka.autoCommitInterval,\n      autoCommitThreshold: this.baseYamlConfig.kafka.autoCommitThreshold,\n      eachBatchAutoResolve: true,\n      eachBatch: this.consumeBatch,\n    });\n  };\n\n  private consumeBatch = async ({ batch, resolveOffset }: EachBatchPayload) => {\n    const messages = batch.messages\n      .filter((message) => message.value !== null)\n      .map((message: KafkaMessage) => {\n        if (message.value === null) {\n          // unreachable code but typescript does not know that\n          return {};\n        }\n        const m = message.value;\n        return JSON.parse(m.toString());\n      });\n    Logger.getInstance().debug(\n      'Received batch of messages',\n      messages.length,\n      batch.topic,\n    );\n\n    if (this.bulkApplicable(messages)) {\n      try {\n        await this.callbackFunction(messages);\n        const { offset } = batch.messages[batch.messages.length - 1];\n        resolveOffset(offset);\n      } catch (error) {\n        Logger.getInstance().error(\n          'Error in callback function. Continue as single batch',\n          error,\n        );\n        await this.consumeBatchAsSingle(batch.messages, resolveOffset);\n      }\n    } else {\n      Logger.getInstance().debug(\n        'Batch processing not applicable. Continue as single batch',\n      );\n      await this.consumeBatchAsSingle(batch.messages, resolveOffset);\n    }\n  };\n\n  private consumeBatchAsSingle = async (\n    messages: Array<KafkaMessage>,\n    resolveOffset: (offset: string) => void,\n  ) => {\n    // eslint-disable-next-line no-restricted-syntax\n    for (const message of messages) {\n      if (message.value === null) {\n        Logger.getInstance().error('Received null message');\n        resolveOffset(message.offset);\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      try {\n        const parsedMessage = JSON.parse(message.value?.toString() ?? '{}');\n        // eslint-disable-next-line no-await-in-loop\n        await this.callbackFunction([parsedMessage]);\n        resolveOffset(message.offset);\n      } catch (error) {\n        Logger.getInstance().error('Error in callback function', error);\n        resolveOffset(message.offset);\n      }\n    }\n  };\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAIO;AAEP,oBAAuB;AACvB,oCAAqC;AAE9B,MAAM,iCAAiC,mDAAqB;AAAA,EAC1D,YACL,gBACiB,kBAGA,iBAEF,MAAM,MACrB;AACA,UAAM,cAAc;AAPH;AAGA;AAOnB,SAAO,OAAO,YAA2B;AAEvC,iBAAW,SAAS,KAAK,eAAe,MAAM,kBAAkB,CAAC,GAAG;AAClE,gBAAI,2BAAa,KAAK,GAAG;AAEvB,gBAAM,KAAK,SAAS,UAAU;AAAA,YAC5B,OAAO,IAAI,OAAO,MAAM,SAAS,MAAM,KAAK;AAAA,YAC5C,eAAe;AAAA,UACjB,CAAC;AAAA,QACH,WAAW,OAAO,UAAU,UAAU;AAEpC,gBAAM,KAAK,SAAS,UAAU,EAAE,OAAO,eAAe,KAAK,CAAC;AAAA,QAC9D,OAAO;AACL,gBAAM,IAAI,MAAM,oBAAoB;AAAA,QACtC;AAAA,MACF;AAEA,YAAM,KAAK,SAAS,IAAI;AAAA,QACtB,gCACE,KAAK,eAAe,MAAM,kCAAkC;AAAA,QAC9D,oBAAoB,KAAK,eAAe,MAAM;AAAA,QAC9C,qBAAqB,KAAK,eAAe,MAAM;AAAA,QAC/C,sBAAsB;AAAA,QACtB,WAAW,KAAK;AAAA,MAClB,CAAC;AAAA,IACH;AAEA,SAAQ,eAAe,OAAO,EAAE,OAAO,cAAc,MAAwB;AAC3E,YAAM,WAAW,MAAM,SACpB,OAAO,CAAC,YAAY,QAAQ,UAAU,IAAI,EAC1C,IAAI,CAAC,YAA0B;AAC9B,YAAI,QAAQ,UAAU,MAAM;AAE1B,iBAAO,CAAC;AAAA,QACV;AACA,cAAM,IAAI,QAAQ;AAClB,eAAO,KAAK,MAAM,EAAE,SAAS,CAAC;AAAA,MAChC,CAAC;AACH,2BAAO,YAAY,EAAE;AAAA,QACnB;AAAA,QACA,SAAS;AAAA,QACT,MAAM;AAAA,MACR;AAEA,UAAI,KAAK,eAAe,QAAQ,GAAG;AACjC,YAAI;AACF,gBAAM,KAAK,iBAAiB,QAAQ;AACpC,gBAAM,EAAE,OAAO,IAAI,MAAM,SAAS,MAAM,SAAS,SAAS,CAAC;AAC3D,wBAAc,MAAM;AAAA,QACtB,SAAS,OAAO;AACd,+BAAO,YAAY,EAAE;AAAA,YACnB;AAAA,YACA;AAAA,UACF;AACA,gBAAM,KAAK,qBAAqB,MAAM,UAAU,aAAa;AAAA,QAC/D;AAAA,MACF,OAAO;AACL,6BAAO,YAAY,EAAE;AAAA,UACnB;AAAA,QACF;AACA,cAAM,KAAK,qBAAqB,MAAM,UAAU,aAAa;AAAA,MAC/D;AAAA,IACF;AAEA,SAAQ,uBAAuB,OAC7B,UACA,kBACG;AAEH,iBAAW,WAAW,UAAU;AAC9B,YAAI,QAAQ,UAAU,MAAM;AAC1B,+BAAO,YAAY,EAAE,MAAM,uBAAuB;AAClD,wBAAc,QAAQ,MAAM;AAE5B;AAAA,QACF;AAEA,YAAI;AACF,gBAAM,gBAAgB,KAAK,MAAM,QAAQ,OAAO,SAAS,KAAK,IAAI;AAElE,gBAAM,KAAK,iBAAiB,CAAC,aAAa,CAAC;AAC3C,wBAAc,QAAQ,MAAM;AAAA,QAC9B,SAAS,OAAO;AACd,+BAAO,YAAY,EAAE,MAAM,8BAA8B,KAAK;AAC9D,wBAAc,QAAQ,MAAM;AAAA,QAC9B;AAAA,MACF;AAAA,IACF;AAAA,EAzFA;AA0FF;",
  "names": []
}
