{
  "version": 3,
  "sources": ["../../../../../../../libs/parse-yaml/src/lib/parse-yaml.ts"],
  "sourcesContent": ["import * as yaml from 'js-yaml';\nimport * as ejs from 'ejs';\nimport {readFileSync} from 'fs';\nimport {handleError} from \"@xip-online-data/handle-error\";\n\nexport function parseYaml<T>(\n    argv: Array<string>,\n    validateFunction: (config: T) => boolean = () => true,\n    argPosition = 2\n): T {\n  if (argv.length !== (argPosition + 1)) {\n    handleError('Please provide the path to the config file as the first argument');\n  }\n\n  const configPath = argv[argPosition];\n  let config: T = undefined as T;\n\n  try {\n    const configTemplate = readFileSync(configPath, 'utf8');\n    const configString = ejs.render(configTemplate);\n    config = yaml.load(configString) as T;\n  } catch (e) {\n    handleError('Error while reading config file', e);\n  }\n\n  if (config === undefined) {\n    handleError('Config file is not valid');\n    return undefined as T; // This is unreachable code, but TypeScript doesn't know that\n  }\n  \n  if (!validateFunction(config)) {\n    handleError('Config file is not valid');\n    return undefined as T; // This is unreachable code, but TypeScript doesn't know that\n  }\n\n  console.debug('Config file is valid');\n  return config;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAsB;AACtB,UAAqB;AACrB,gBAA2B;AAC3B,0BAA0B;AAEnB,SAAS,UACZ,MACA,mBAA2C,MAAM,MACjD,cAAc,GACb;AACH,MAAI,KAAK,WAAY,cAAc,GAAI;AACrC,yCAAY,kEAAkE;AAAA,EAChF;AAEA,QAAM,aAAa,KAAK,WAAW;AACnC,MAAI,SAAY;AAEhB,MAAI;AACF,UAAM,qBAAiB,wBAAa,YAAY,MAAM;AACtD,UAAM,eAAe,IAAI,OAAO,cAAc;AAC9C,aAAS,KAAK,KAAK,YAAY;AAAA,EACjC,SAAS,GAAG;AACV,yCAAY,mCAAmC,CAAC;AAAA,EAClD;AAEA,MAAI,WAAW,QAAW;AACxB,yCAAY,0BAA0B;AACtC,WAAO;AAAA,EACT;AAEA,MAAI,CAAC,iBAAiB,MAAM,GAAG;AAC7B,yCAAY,0BAA0B;AACtC,WAAO;AAAA,EACT;AAEA,UAAQ,MAAM,sBAAsB;AACpC,SAAO;AACT;",
  "names": []
}
