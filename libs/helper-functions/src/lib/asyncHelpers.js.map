{
  "version": 3,
  "sources": ["../../../../../../../libs/helper-functions/src/lib/asyncHelpers.ts"],
  "sourcesContent": ["// libs/helper-functions/src/lib/wrapAsync.ts\nimport Handlebars from 'handlebars';\n\ntype AnyFn = (...args: Array<any>) => any;\n\ninterface RenderCtx {\n  promises: Array<Promise<unknown>>;\n}\n\nexport function wrapAsync(hbs: typeof Handlebars = Handlebars, debug = false) {\n  const P = Promise;\n  const MARK = '\\u0001'; // unlikely marker\n\n  (hbs as any).__ASYNC_WRAPPED__ = true;\n\n  const origCompile = hbs.compile.bind(hbs);\n  const origTemplate = (hbs as any).template?.bind(hbs);\n  const origRegisterHelper = hbs.registerHelper.bind(hbs);\n  const origCreate = (hbs as any).create?.bind(hbs);\n\n  if (debug) console.log('[wrapAsync] patching Handlebars\u2026');\n\n  /** Wrap a helper so it can return Promise */\n  function wrapHelper(fn: AnyFn): AnyFn {\n    return function wrappedHelper(this: any, ...args: Array<any>) {\n      const val = fn.apply(this, args);\n      const isThenable = !!val && typeof (val as any).then === 'function';\n      if (!isThenable) return val;\n\n      const maybeOpts = args[args.length - 1];\n      const ctx: RenderCtx | undefined =\n        maybeOpts && typeof maybeOpts === 'object' && maybeOpts.data\n          ? (maybeOpts.data as any).__ASYNC_CTX__\n          : undefined;\n\n      if (!ctx) {\n        if (debug) console.warn('[wrapAsync] async helper without ctx');\n        return String(val);\n      }\n\n      const id = String(ctx.promises.length);\n      ctx.promises.push(P.resolve(val));\n      return `${MARK}${id}${MARK}`;\n    };\n  }\n\n  /** Support both overloads of registerHelper */\n  (hbs as any).registerHelper = (\n    nameOrMap: string | Record<string, AnyFn>,\n    helper?: AnyFn,\n  ) => {\n    if (typeof nameOrMap === 'string' && helper) {\n      if (debug) console.log(`[wrapAsync] wrapping helper \"${nameOrMap}\"`);\n      origRegisterHelper(nameOrMap, wrapHelper(helper));\n      return;\n    }\n    if (typeof nameOrMap === 'object' && !helper) {\n      const map = nameOrMap as Record<string, AnyFn>;\n      const wrapped: Record<string, AnyFn> = {};\n      for (const [n, fn] of Object.entries(map)) {\n        if (debug) console.log(`[wrapAsync] wrapping helper \"${n}\" (map)`);\n        wrapped[n] = wrapHelper(fn);\n      }\n      origRegisterHelper(wrapped);\n      return;\n    }\n    throw new Error('Unsupported registerHelper call signature');\n  };\n\n  /** Run template, substitute async placeholders */\n  function renderWithAsync(fn: AnyFn, data: any): Promise<string> {\n    const ctx: RenderCtx = { promises: [] };\n\n    const hbsData = Handlebars.createFrame((data && data.data) || {});\n    (hbsData as any).__ASYNC_CTX__ = ctx;\n\n    // First pass: may return string OR Promise<string>\n    const out0 = fn(data, { data: hbsData });\n\n    const toPromise = (v: any) =>\n      v && typeof v.then === 'function'\n        ? Promise.resolve(v)\n        : Promise.resolve(v);\n\n    return toPromise(out0).then((out1) => {\n      if (ctx.promises.length === 0) {\n        if (debug) console.log('[wrapAsync] no async helpers, returning out1');\n        return String(out1);\n      }\n\n      if (debug) {\n        console.log('[wrapAsync] awaiting', ctx.promises.length, 'promises');\n        console.log('[wrapAsync] first pass out (raw):', String(out1));\n      }\n\n      return Promise.all(ctx.promises).then((results) => {\n        let s = String(out1);\n        s = s.replace(/\\u0001(\\d+)\\u0001/g, (_m, idxStr) => {\n          const r = results[Number(idxStr)];\n          if (r && r.constructor === (hbs as any).SafeString)\n            return r.toString();\n          return String(r ?? '');\n        });\n        if (debug) console.log('[wrapAsync] after replace:', s);\n        return s;\n      });\n    });\n  }\n\n  /** Patch compile so compiled templates return Promise<string> */\n  (hbs as any).compile = function (...args: Array<any>) {\n    // @ts-ignore\n    const tmpl = origCompile(...args);\n    if (debug) console.log('[wrapAsync] compile patched');\n    return (data: any) => renderWithAsync(tmpl, data);\n  };\n\n  /** Patch template() for precompiled/runtime usage */\n  if (origTemplate) {\n    (hbs as any).template = function (...args: Array<any>) {\n      const tmpl = origTemplate!(...args);\n      if (debug) console.log('[wrapAsync] template patched');\n      return (data: any) => renderWithAsync(tmpl, data);\n    };\n  }\n\n  /** Ensure create() also returns wrapped instances */\n  if (origCreate) {\n    (hbs as any).create = function (...args: Array<any>) {\n      const inst = origCreate!(...args);\n      return wrapAsync(inst, debug);\n    };\n  }\n\n  return hbs;\n}\n"],
  "mappings": "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",
  "names": ["Handlebars"]
}
