{
  "version": 3,
  "sources": ["../../../../../../../libs/connector-runner-microsoft-office365-email/src/lib/actions-handler.ts"],
  "sourcesContent": ["import {\n  CompileDelegate,\n  ConnectorSDKInterface,\n} from '@transai/connector-runtime-sdk';\n// eslint-disable-next-line @nx/enforce-module-boundaries\nimport { MailClientInterface } from '@xip-online-data/microsoft-office365-mail-client';\nimport {\n  KafkaCallbackResponse,\n  XodActionType,\n  XodBaseMessageType,\n  XodJobType,\n} from '@xip-online-data/types';\n\nexport class ActionsHandler {\n  readonly #connectorSDK: ConnectorSDKInterface;\n\n  readonly #mailClient: MailClientInterface;\n\n  constructor(\n    connectorSDK: ConnectorSDKInterface,\n    mailClient: MailClientInterface,\n  ) {\n    this.#connectorSDK = connectorSDK;\n    this.#mailClient = mailClient;\n  }\n\n  get callbackFunctionChain(): (\n    m: XodBaseMessageType,\n  ) => Promise<KafkaCallbackResponse> {\n    return this.#jobCallbackFunction(\n      this.#actionCallbackFunction(\n        this.#connectorSDK.receiver.emitEventType(\n          this.#connectorSDK.receiver.responses.created(),\n        ),\n      ),\n    );\n  }\n\n  #jobCallbackFunction(\n    callbackFunction: (\n      message: XodBaseMessageType,\n    ) => Promise<KafkaCallbackResponse>,\n  ) {\n    return async (m: XodBaseMessageType): Promise<KafkaCallbackResponse> => {\n      if (m.type !== 'JOB') {\n        return callbackFunction(m);\n      }\n\n      const message = m as XodJobType;\n      const action = this.#connectorSDK.receiver.getActionConfig(message);\n      if (!action) {\n        return this.#connectorSDK.receiver.responses.badRequest(\n          'Action configuration not found',\n        )(message);\n      }\n\n      try {\n        this.#connectorSDK.logger.debug(\n          `Apply templates on payload: ${JSON.stringify(message.payload)}, action: ${JSON.stringify(action)}`,\n        );\n\n        const handleBars = action.config['parsedTemplates'] as {\n          action: CompileDelegate;\n          params: CompileDelegate;\n        };\n\n        const parsedAction = handleBars\n          .action({\n            inputs: message.payload,\n          })\n          .trim();\n\n        const parsedParams = handleBars\n          .params({\n            inputs: message.payload,\n          })\n          .trim();\n\n        if (message.testRun) {\n          this.#connectorSDK.logger.info(\n            `Test run for ${message.eventId} with payload ${parsedParams} to action ${parsedAction}`,\n          );\n          return callbackFunction(message);\n        }\n\n        this.#connectorSDK.logger.debug(\n          `Parsed action: ${parsedAction}, parameters: ${parsedParams}`,\n        );\n\n        const parsedParamsJson = JSON.parse(parsedParams);\n        this.#connectorSDK.logger.debug(\n          `Parsed params json: ${JSON.stringify(parsedParamsJson)}`,\n        );\n\n        switch (parsedAction) {\n          case 'REPLY':\n            await this.#mailClient.reply(\n              parsedParamsJson.messageId,\n              parsedParamsJson.from,\n              parsedParamsJson.mailBody,\n              true,\n            );\n            break;\n          case 'FORWARD':\n            // this.#mailClient.forward(parsedParams);\n            break;\n          case 'SEND':\n            // this.#mailClient.send(parsedParams);\n            break;\n          case 'CATEGORY_ADD':\n            await this.#mailClient.addCategory(\n              parsedParamsJson.messageId,\n              parsedParamsJson.category,\n            );\n            break;\n          case 'CATEGORY_REMOVE':\n            await this.#mailClient.removeCategory(\n              parsedParamsJson.messageId,\n              parsedParamsJson.category,\n            );\n            break;\n          default:\n            this.#connectorSDK.logger.error(\n              `Unknown action type: ${parsedAction} in message ${message.eventId}`,\n            );\n        }\n\n        return callbackFunction(message);\n      } catch (error: unknown) {\n        return this.#connectorSDK.receiver.responses.internalServerError(\n          error instanceof Error ? error.message : 'Unknown error occurred',\n        )(message);\n      }\n    };\n  }\n\n  #actionCallbackFunction(\n    callbackFunction: (\n      message: XodBaseMessageType,\n    ) => Promise<KafkaCallbackResponse>,\n  ) {\n    return async (m: XodBaseMessageType): Promise<KafkaCallbackResponse> => {\n      if (m.type !== 'ACTION') {\n        return callbackFunction(m);\n      }\n\n      const message = m as XodActionType;\n      try {\n        if (!message.payload.destination || !message.payload.content) {\n          return this.#connectorSDK.receiver.responses.badRequest(\n            'Destination or content not found',\n          )(message);\n        }\n\n        // her comes the action handling logic\n        const result = { success: true, data: 'Not implemented yet' };\n\n        if (result.success) {\n          return callbackFunction(message);\n        }\n\n        return this.#connectorSDK.receiver.responses.internalServerError(\n          result.data,\n        )(message);\n      } catch (error) {\n        return this.#connectorSDK.receiver.responses.internalServerError(\n          error instanceof Error ? error.message : 'Unknown error occurred',\n        )(message);\n      }\n    };\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAaO,MAAM,eAAe;AAAA,EACjB;AAAA,EAEA;AAAA,EAET,YACE,cACA,YACA;AACA,SAAK,gBAAgB;AACrB,SAAK,cAAc;AAAA,EACrB;AAAA,EAEA,IAAI,wBAEgC;AAClC,WAAO,KAAK;AAAA,MACV,KAAK;AAAA,QACH,KAAK,cAAc,SAAS;AAAA,UAC1B,KAAK,cAAc,SAAS,UAAU,QAAQ;AAAA,QAChD;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EAEA,qBACE,kBAGA;AACA,WAAO,OAAO,MAA0D;AACtE,UAAI,EAAE,SAAS,OAAO;AACpB,eAAO,iBAAiB,CAAC;AAAA,MAC3B;AAEA,YAAM,UAAU;AAChB,YAAM,SAAS,KAAK,cAAc,SAAS,gBAAgB,OAAO;AAClE,UAAI,CAAC,QAAQ;AACX,eAAO,KAAK,cAAc,SAAS,UAAU;AAAA,UAC3C;AAAA,QACF,EAAE,OAAO;AAAA,MACX;AAEA,UAAI;AACF,aAAK,cAAc,OAAO;AAAA,UACxB,+BAA+B,KAAK,UAAU,QAAQ,OAAO,CAAC,aAAa,KAAK,UAAU,MAAM,CAAC;AAAA,QACnG;AAEA,cAAM,aAAa,OAAO,OAAO,iBAAiB;AAKlD,cAAM,eAAe,WAClB,OAAO;AAAA,UACN,QAAQ,QAAQ;AAAA,QAClB,CAAC,EACA,KAAK;AAER,cAAM,eAAe,WAClB,OAAO;AAAA,UACN,QAAQ,QAAQ;AAAA,QAClB,CAAC,EACA,KAAK;AAER,YAAI,QAAQ,SAAS;AACnB,eAAK,cAAc,OAAO;AAAA,YACxB,gBAAgB,QAAQ,OAAO,iBAAiB,YAAY,cAAc,YAAY;AAAA,UACxF;AACA,iBAAO,iBAAiB,OAAO;AAAA,QACjC;AAEA,aAAK,cAAc,OAAO;AAAA,UACxB,kBAAkB,YAAY,iBAAiB,YAAY;AAAA,QAC7D;AAEA,cAAM,mBAAmB,KAAK,MAAM,YAAY;AAChD,aAAK,cAAc,OAAO;AAAA,UACxB,uBAAuB,KAAK,UAAU,gBAAgB,CAAC;AAAA,QACzD;AAEA,gBAAQ,cAAc;AAAA,UACpB,KAAK;AACH,kBAAM,KAAK,YAAY;AAAA,cACrB,iBAAiB;AAAA,cACjB,iBAAiB;AAAA,cACjB,iBAAiB;AAAA,cACjB;AAAA,YACF;AACA;AAAA,UACF,KAAK;AAEH;AAAA,UACF,KAAK;AAEH;AAAA,UACF,KAAK;AACH,kBAAM,KAAK,YAAY;AAAA,cACrB,iBAAiB;AAAA,cACjB,iBAAiB;AAAA,YACnB;AACA;AAAA,UACF,KAAK;AACH,kBAAM,KAAK,YAAY;AAAA,cACrB,iBAAiB;AAAA,cACjB,iBAAiB;AAAA,YACnB;AACA;AAAA,UACF;AACE,iBAAK,cAAc,OAAO;AAAA,cACxB,wBAAwB,YAAY,eAAe,QAAQ,OAAO;AAAA,YACpE;AAAA,QACJ;AAEA,eAAO,iBAAiB,OAAO;AAAA,MACjC,SAAS,OAAgB;AACvB,eAAO,KAAK,cAAc,SAAS,UAAU;AAAA,UAC3C,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QAC3C,EAAE,OAAO;AAAA,MACX;AAAA,IACF;AAAA,EACF;AAAA,EAEA,wBACE,kBAGA;AACA,WAAO,OAAO,MAA0D;AACtE,UAAI,EAAE,SAAS,UAAU;AACvB,eAAO,iBAAiB,CAAC;AAAA,MAC3B;AAEA,YAAM,UAAU;AAChB,UAAI;AACF,YAAI,CAAC,QAAQ,QAAQ,eAAe,CAAC,QAAQ,QAAQ,SAAS;AAC5D,iBAAO,KAAK,cAAc,SAAS,UAAU;AAAA,YAC3C;AAAA,UACF,EAAE,OAAO;AAAA,QACX;AAGA,cAAM,SAAS,EAAE,SAAS,MAAM,MAAM,sBAAsB;AAE5D,YAAI,OAAO,SAAS;AAClB,iBAAO,iBAAiB,OAAO;AAAA,QACjC;AAEA,eAAO,KAAK,cAAc,SAAS,UAAU;AAAA,UAC3C,OAAO;AAAA,QACT,EAAE,OAAO;AAAA,MACX,SAAS,OAAO;AACd,eAAO,KAAK,cAAc,SAAS,UAAU;AAAA,UAC3C,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QAC3C,EAAE,OAAO;AAAA,MACX;AAAA,IACF;AAAA,EACF;AACF;",
  "names": []
}
