{
  "version": 3,
  "sources": ["../../../../../../../../libs/connector-runner-samba-source/src/lib/filesource-processor/samba-filesource-processor.service.ts"],
  "sourcesContent": ["import { filter, interval, Subscription } from 'rxjs';\nimport {\n  ListMetaData,\n  SambaClient,\n  SambaConfig,\n} from '@xip-online-data/samba-client';\nimport * as fs from 'fs';\nimport { FileHandler } from '@xip-online-data/file-handler';\nimport {\n  BaseConnectorConfig,\n  FileActionType,\n  FileRegex,\n  XodSourceMessageType,\n  XodSourcePayloadType,\n} from '@xip-online-data/types';\nimport { KafkaSourceInterface } from '@xip-online-data/kafka-base-service';\nimport { v4 as uuidv4 } from 'uuid';\nimport { Logger } from '@transai/logger';\nimport {\n  generateCollectionName,\n  generateKafkaTopic,\n} from '../helper.functions';\nimport { SambaSourceConfig, SambaSourceConnectorConfig } from '../types';\n\nexport class SambaFilesourceProcessorService {\n  #sambaClientInstance: SambaClient | undefined;\n\n  get #sambaClient(): SambaClient {\n    if (!this.#sambaClientInstance) {\n      throw new Error('Samba client is not initialized');\n    }\n    return this.#sambaClientInstance;\n  }\n\n  readonly #sambaConfig: SambaConfig;\n\n  readonly #fileHandler = new FileHandler();\n\n  readonly #sambaSourceConfig: SambaSourceConfig;\n\n  readonly #kafkaService: KafkaSourceInterface;\n\n  readonly #config: SambaSourceConnectorConfig & BaseConnectorConfig;\n\n  readonly #logger: Logger;\n\n  #processing = false;\n\n  #numberOfImportedFilesPerSession = 0;\n\n  #subscription?: Subscription;\n\n  constructor(\n    config: SambaSourceConnectorConfig & BaseConnectorConfig,\n    sambaSourceConfig: SambaSourceConfig,\n    kafkaService: KafkaSourceInterface,\n  ) {\n    this.#config = config;\n    this.#sambaSourceConfig = sambaSourceConfig;\n    this.#kafkaService = kafkaService;\n    this.#sambaConfig = config.samba;\n    this.#logger = Logger.getInstance();\n  }\n\n  public async init(): Promise<void> {\n    this.#sambaClientInstance = new SambaClient(this.#sambaConfig);\n    this.setInterval();\n  }\n\n  stop() {\n    this.#subscription?.unsubscribe();\n  }\n\n  private setInterval(): void {\n    this.#subscription = interval(this.#sambaSourceConfig.interval * 1000)\n      .pipe(filter(() => !this.#processing))\n      .subscribe(async () => {\n        await this.process().catch((error) => {\n          throw new Error(\n            `Error while processing files from filesource processor service ${error.message}`,\n          );\n        });\n      });\n  }\n\n  public async process(): Promise<void> {\n    if (this.#processing) {\n      Logger.getInstance().info(\n        'Filesource processor service is already processing: ',\n        this.#sambaConfig.address,\n      );\n      return;\n    }\n\n    this.#numberOfImportedFilesPerSession = 0;\n    this.#processing = true;\n\n    try {\n      this.#numberOfImportedFilesPerSession = await this.listDirectory(\n        this.#sambaSourceConfig.directory,\n        this.#sambaSourceConfig.fileSelector!,\n      ).catch((error) => {\n        Logger.getInstance().error(\n          `Error while listing directory ${this.#sambaSourceConfig.directory}: ${error.message}`,\n        );\n        throw error;\n      });\n      Logger.getInstance().verbose(\n        `Imported ${this.#numberOfImportedFilesPerSession} files from ${this.#sambaConfig.address}`,\n      );\n    } catch (error) {\n      Logger.getInstance().debug(JSON.stringify(error));\n    } finally {\n      this.#processing = false;\n    }\n  }\n\n  private async listDirectory(\n    location: string,\n    fileSelector: FileRegex,\n  ): Promise<number> {\n    let imported = 0;\n\n    const listResult = await this.#sambaClient.list(location);\n    let files = listResult.filter((r) => r.type === 'A');\n\n    this.#logger.debug(\n      `Total files in ${location}: ${files.map((f) => f.name).join(', ')}`,\n    );\n\n    if (fileSelector) {\n      const regex = new RegExp(fileSelector.pattern, fileSelector.flags);\n      files = files.filter((f) => regex.test(f.name));\n      this.#logger.debug(\n        `Files in ${location} after regex filter: ${files.map((f) => f.name).join(', ')}`,\n      );\n    }\n\n    // eslint-disable-next-line no-restricted-syntax\n    for (const f of files) {\n      // eslint-disable-next-line no-await-in-loop\n      const success = await this.getFile(f, location);\n      if (success) {\n        imported += 1;\n      }\n    }\n\n    const directories = listResult.filter(\n      (r) => r.type === 'D' && r.name !== '.' && r.name !== '..',\n    );\n\n    if (this.#sambaSourceConfig.recursive === true) {\n      // eslint-disable-next-line no-restricted-syntax\n      for (const d of directories) {\n        // eslint-disable-next-line no-await-in-loop\n        const subImport = await this.listDirectory(\n          `${location + d.name}/`,\n          fileSelector,\n        );\n        imported += subImport;\n      }\n    }\n\n    return imported;\n  }\n\n  private async getFile(\n    file: ListMetaData,\n    location: string,\n  ): Promise<boolean> {\n    const remoteFile = `${location}${file.name}`;\n    const localFile = `${this.#sambaConfig.tmpDirectory}/${file.name}`;\n\n    let success = false;\n    try {\n      await this.#sambaClient.getFile(remoteFile, localFile).catch((error) => {\n        Logger.getInstance().error(\n          `Error while getting file ${remoteFile}: ${error.message}`,\n        );\n        throw error;\n      });\n      success = await this.handleLocalFile(file, localFile);\n      if (this.#sambaSourceConfig.action !== FileActionType.ACTION_NOTHING) {\n        await this.deleteRemoteFile(remoteFile);\n        if (this.#sambaSourceConfig.action === FileActionType.ACTION_MOVE) {\n          await this.moveFileToRemoteLocation(localFile, file);\n        }\n      }\n      this.#deleteLocalFile(localFile);\n    } catch (e) {\n      Logger.getInstance().error(JSON.stringify(e));\n      return false;\n    }\n\n    return success;\n  }\n\n  private async deleteRemoteFile(remoteFile: string): Promise<boolean> {\n    try {\n      const feedback = await this.#sambaClient.deleteFile(remoteFile);\n      Logger.getInstance().debug(feedback);\n    } catch (e) {\n      Logger.getInstance().error(JSON.stringify(e));\n      return false;\n    }\n\n    return true;\n  }\n\n  private async moveFileToRemoteLocation(\n    localFile: string,\n    file: ListMetaData,\n  ): Promise<void> {\n    try {\n      const remotePath = this.#sambaSourceConfig.processedDirectory!;\n\n      if (!(await this.#sambaClient.fileExists(remotePath))) {\n        await this.#sambaClient.mkdir(remotePath);\n      }\n\n      const feedback = await this.#sambaClient.sendFile(\n        localFile,\n        `${remotePath}${file.name}`,\n      );\n      Logger.getInstance().debug(feedback);\n    } catch (e) {\n      Logger.getInstance().error(JSON.stringify(e));\n    }\n  }\n\n  private async handleLocalFile(\n    file: ListMetaData,\n    location: string,\n  ): Promise<boolean> {\n    try {\n      const content = fs.readFileSync(location, 'utf-8');\n      const parsedContent = await this.#fileHandler.handle(\n        file.name,\n        content,\n        this.#sambaSourceConfig.optionalHeaders ?? [],\n      );\n\n      const payload: XodSourcePayloadType = {\n        body: {\n          ...parsedContent,\n          _filename: file.name,\n        },\n        keyField: '_filename',\n        indexes: this.#sambaSourceConfig.indexes ?? [],\n        incrementalField: '',\n        collection: generateCollectionName(\n          this.#config,\n          this.#sambaSourceConfig,\n        ),\n      };\n\n      const parsedRecords: Array<XodSourceMessageType> = [\n        {\n          type: 'SOURCE',\n          eventId: uuidv4(),\n          eventType: `${this.#config.tenantIdentifier}_SOURCE_${this.#sambaSourceConfig.sambaIdentifier}`,\n          created: Date.now(),\n          ttl: 3600000, // 1 month\n          tenantIdentifier: this.#config.tenantIdentifier,\n          payload,\n        },\n      ];\n\n      const topic = generateKafkaTopic(this.#config, this.#sambaSourceConfig);\n\n      await this.#kafkaService.send(parsedRecords, topic);\n      return true;\n    } catch (e) {\n      Logger.getInstance().error(JSON.stringify(e));\n      return false;\n    }\n  }\n\n  #deleteLocalFile(location: string): boolean {\n    let success = false;\n    fs.unlink(location, (err) => {\n      success = err === null;\n    });\n    return success;\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAA+C;AAC/C,0BAIO;AACP,SAAoB;AACpB,0BAA4B;AAC5B,mBAMO;AAEP,kBAA6B;AAC7B,oBAAuB;AACvB,oBAGO;AAGA,MAAM,gCAAgC;AAAA,EAC3C;AAAA,EAEA,IAAI,eAA4B;AAC9B,QAAI,CAAC,KAAK,sBAAsB;AAC9B,YAAM,IAAI,MAAM,iCAAiC;AAAA,IACnD;AACA,WAAO,KAAK;AAAA,EACd;AAAA,EAES;AAAA,EAEA,eAAe,IAAI,gCAAY;AAAA,EAE/B;AAAA,EAEA;AAAA,EAEA;AAAA,EAEA;AAAA,EAET,cAAc;AAAA,EAEd,mCAAmC;AAAA,EAEnC;AAAA,EAEA,YACE,QACA,mBACA,cACA;AACA,SAAK,UAAU;AACf,SAAK,qBAAqB;AAC1B,SAAK,gBAAgB;AACrB,SAAK,eAAe,OAAO;AAC3B,SAAK,UAAU,qBAAO,YAAY;AAAA,EACpC;AAAA,EAEA,MAAa,OAAsB;AACjC,SAAK,uBAAuB,IAAI,gCAAY,KAAK,YAAY;AAC7D,SAAK,YAAY;AAAA,EACnB;AAAA,EAEA,OAAO;AACL,SAAK,eAAe,YAAY;AAAA,EAClC;AAAA,EAEQ,cAAoB;AAC1B,SAAK,oBAAgB,sBAAS,KAAK,mBAAmB,WAAW,GAAI,EAClE,SAAK,oBAAO,MAAM,CAAC,KAAK,WAAW,CAAC,EACpC,UAAU,YAAY;AACrB,YAAM,KAAK,QAAQ,EAAE,MAAM,CAAC,UAAU;AACpC,cAAM,IAAI;AAAA,UACR,kEAAkE,MAAM,OAAO;AAAA,QACjF;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACL;AAAA,EAEA,MAAa,UAAyB;AACpC,QAAI,KAAK,aAAa;AACpB,2BAAO,YAAY,EAAE;AAAA,QACnB;AAAA,QACA,KAAK,aAAa;AAAA,MACpB;AACA;AAAA,IACF;AAEA,SAAK,mCAAmC;AACxC,SAAK,cAAc;AAEnB,QAAI;AACF,WAAK,mCAAmC,MAAM,KAAK;AAAA,QACjD,KAAK,mBAAmB;AAAA,QACxB,KAAK,mBAAmB;AAAA,MAC1B,EAAE,MAAM,CAAC,UAAU;AACjB,6BAAO,YAAY,EAAE;AAAA,UACnB,iCAAiC,KAAK,mBAAmB,SAAS,KAAK,MAAM,OAAO;AAAA,QACtF;AACA,cAAM;AAAA,MACR,CAAC;AACD,2BAAO,YAAY,EAAE;AAAA,QACnB,YAAY,KAAK,gCAAgC,eAAe,KAAK,aAAa,OAAO;AAAA,MAC3F;AAAA,IACF,SAAS,OAAO;AACd,2BAAO,YAAY,EAAE,MAAM,KAAK,UAAU,KAAK,CAAC;AAAA,IAClD,UAAE;AACA,WAAK,cAAc;AAAA,IACrB;AAAA,EACF;AAAA,EAEA,MAAc,cACZ,UACA,cACiB;AACjB,QAAI,WAAW;AAEf,UAAM,aAAa,MAAM,KAAK,aAAa,KAAK,QAAQ;AACxD,QAAI,QAAQ,WAAW,OAAO,CAAC,MAAM,EAAE,SAAS,GAAG;AAEnD,SAAK,QAAQ;AAAA,MACX,kBAAkB,QAAQ,KAAK,MAAM,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,IAAI,CAAC;AAAA,IACpE;AAEA,QAAI,cAAc;AAChB,YAAM,QAAQ,IAAI,OAAO,aAAa,SAAS,aAAa,KAAK;AACjE,cAAQ,MAAM,OAAO,CAAC,MAAM,MAAM,KAAK,EAAE,IAAI,CAAC;AAC9C,WAAK,QAAQ;AAAA,QACX,YAAY,QAAQ,wBAAwB,MAAM,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,IAAI,CAAC;AAAA,MACjF;AAAA,IACF;AAGA,eAAW,KAAK,OAAO;AAErB,YAAM,UAAU,MAAM,KAAK,QAAQ,GAAG,QAAQ;AAC9C,UAAI,SAAS;AACX,oBAAY;AAAA,MACd;AAAA,IACF;AAEA,UAAM,cAAc,WAAW;AAAA,MAC7B,CAAC,MAAM,EAAE,SAAS,OAAO,EAAE,SAAS,OAAO,EAAE,SAAS;AAAA,IACxD;AAEA,QAAI,KAAK,mBAAmB,cAAc,MAAM;AAE9C,iBAAW,KAAK,aAAa;AAE3B,cAAM,YAAY,MAAM,KAAK;AAAA,UAC3B,GAAG,WAAW,EAAE,IAAI;AAAA,UACpB;AAAA,QACF;AACA,oBAAY;AAAA,MACd;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,MAAc,QACZ,MACA,UACkB;AAClB,UAAM,aAAa,GAAG,QAAQ,GAAG,KAAK,IAAI;AAC1C,UAAM,YAAY,GAAG,KAAK,aAAa,YAAY,IAAI,KAAK,IAAI;AAEhE,QAAI,UAAU;AACd,QAAI;AACF,YAAM,KAAK,aAAa,QAAQ,YAAY,SAAS,EAAE,MAAM,CAAC,UAAU;AACtE,6BAAO,YAAY,EAAE;AAAA,UACnB,4BAA4B,UAAU,KAAK,MAAM,OAAO;AAAA,QAC1D;AACA,cAAM;AAAA,MACR,CAAC;AACD,gBAAU,MAAM,KAAK,gBAAgB,MAAM,SAAS;AACpD,UAAI,KAAK,mBAAmB,WAAW,4BAAe,gBAAgB;AACpE,cAAM,KAAK,iBAAiB,UAAU;AACtC,YAAI,KAAK,mBAAmB,WAAW,4BAAe,aAAa;AACjE,gBAAM,KAAK,yBAAyB,WAAW,IAAI;AAAA,QACrD;AAAA,MACF;AACA,WAAK,iBAAiB,SAAS;AAAA,IACjC,SAAS,GAAG;AACV,2BAAO,YAAY,EAAE,MAAM,KAAK,UAAU,CAAC,CAAC;AAC5C,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,MAAc,iBAAiB,YAAsC;AACnE,QAAI;AACF,YAAM,WAAW,MAAM,KAAK,aAAa,WAAW,UAAU;AAC9D,2BAAO,YAAY,EAAE,MAAM,QAAQ;AAAA,IACrC,SAAS,GAAG;AACV,2BAAO,YAAY,EAAE,MAAM,KAAK,UAAU,CAAC,CAAC;AAC5C,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,MAAc,yBACZ,WACA,MACe;AACf,QAAI;AACF,YAAM,aAAa,KAAK,mBAAmB;AAE3C,UAAI,CAAE,MAAM,KAAK,aAAa,WAAW,UAAU,GAAI;AACrD,cAAM,KAAK,aAAa,MAAM,UAAU;AAAA,MAC1C;AAEA,YAAM,WAAW,MAAM,KAAK,aAAa;AAAA,QACvC;AAAA,QACA,GAAG,UAAU,GAAG,KAAK,IAAI;AAAA,MAC3B;AACA,2BAAO,YAAY,EAAE,MAAM,QAAQ;AAAA,IACrC,SAAS,GAAG;AACV,2BAAO,YAAY,EAAE,MAAM,KAAK,UAAU,CAAC,CAAC;AAAA,IAC9C;AAAA,EACF;AAAA,EAEA,MAAc,gBACZ,MACA,UACkB;AAClB,QAAI;AACF,YAAM,UAAU,GAAG,aAAa,UAAU,OAAO;AACjD,YAAM,gBAAgB,MAAM,KAAK,aAAa;AAAA,QAC5C,KAAK;AAAA,QACL;AAAA,QACA,KAAK,mBAAmB,mBAAmB,CAAC;AAAA,MAC9C;AAEA,YAAM,UAAgC;AAAA,QACpC,MAAM;AAAA,UACJ,GAAG;AAAA,UACH,WAAW,KAAK;AAAA,QAClB;AAAA,QACA,UAAU;AAAA,QACV,SAAS,KAAK,mBAAmB,WAAW,CAAC;AAAA,QAC7C,kBAAkB;AAAA,QAClB,gBAAY;AAAA,UACV,KAAK;AAAA,UACL,KAAK;AAAA,QACP;AAAA,MACF;AAEA,YAAM,gBAA6C;AAAA,QACjD;AAAA,UACE,MAAM;AAAA,UACN,aAAS,YAAAA,IAAO;AAAA,UAChB,WAAW,GAAG,KAAK,QAAQ,gBAAgB,WAAW,KAAK,mBAAmB,eAAe;AAAA,UAC7F,SAAS,KAAK,IAAI;AAAA,UAClB,KAAK;AAAA;AAAA,UACL,kBAAkB,KAAK,QAAQ;AAAA,UAC/B;AAAA,QACF;AAAA,MACF;AAEA,YAAM,YAAQ,kCAAmB,KAAK,SAAS,KAAK,kBAAkB;AAEtE,YAAM,KAAK,cAAc,KAAK,eAAe,KAAK;AAClD,aAAO;AAAA,IACT,SAAS,GAAG;AACV,2BAAO,YAAY,EAAE,MAAM,KAAK,UAAU,CAAC,CAAC;AAC5C,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EAEA,iBAAiB,UAA2B;AAC1C,QAAI,UAAU;AACd,OAAG,OAAO,UAAU,CAAC,QAAQ;AAC3B,gBAAU,QAAQ;AAAA,IACpB,CAAC;AACD,WAAO;AAAA,EACT;AACF;",
  "names": ["uuidv4"]
}
