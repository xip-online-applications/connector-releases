{
  "version": 3,
  "sources": ["../../../../../../../../libs/connector-runner-mail-source/src/lib/mail-processor/mailsource-processor.service.ts"],
  "sourcesContent": ["import { interval, Subscription } from 'rxjs';\nimport {\n  BaseConnectorConfig,\n  XodSourceMessageType,\n  XodSourcePayloadType,\n} from '@xip-online-data/types';\nimport { KafkaSourceInterface } from '@xip-online-data/kafka-base-service';\nimport { v4 as uuidv4 } from 'uuid';\nimport { Logger } from '@transai/logger';\nimport { PersistentOffsetStoreInterface } from '@transai/connector-runtime';\nimport { MailClient, MailMessage } from '@xip-online-data/mail-client';\nimport {\n  generateCollectionName,\n  generateKafkaTopic,\n  generateOffsetIdentifier,\n} from '../helper.functions';\nimport { MailboxConfig, MailSourceProcessConfig } from '../types';\nimport { htmlToText } from 'html-to-text';\n\nexport class MailsourceProcessorService {\n  #processing = false;\n\n  readonly #mailboxConfig: MailboxConfig;\n\n  readonly #mailSourceConfig: MailSourceProcessConfig & BaseConnectorConfig;\n\n  readonly #kafkaService: KafkaSourceInterface;\n\n  readonly #mailClient: MailClient;\n\n  readonly #logger: Logger;\n\n  #subscription?: Subscription;\n\n  #offsetStore: PersistentOffsetStoreInterface;\n\n  constructor(\n    mailSourceConfig: MailSourceProcessConfig,\n    config: MailboxConfig,\n    kafkaService: KafkaSourceInterface,\n    mailClient: MailClient,\n    offsetStore: PersistentOffsetStoreInterface,\n  ) {\n    this.#mailSourceConfig = mailSourceConfig;\n    this.#mailboxConfig = config;\n    this.#kafkaService = kafkaService;\n    this.#mailClient = mailClient;\n    this.#logger = Logger.getInstance();\n    this.#offsetStore = offsetStore;\n  }\n\n  public async init(): Promise<void> {\n    this.#subscription = interval(\n      this.#mailboxConfig.interval * 1000,\n    ).subscribe(async () => {\n      await this.process().catch((error) => {\n        this.#logger.error(\n          `Error while processing message from mailsource processor service ${error.message}`,\n        );\n      });\n    });\n  }\n\n  stop() {\n    this.#subscription?.unsubscribe();\n  }\n\n  public async process(): Promise<void> {\n    if (this.#processing) {\n      this.#logger.debug(\n        `Mailsource processor service is already processing: ${this.#mailboxConfig.mailboxIdentifier} ${this.#mailboxConfig.mailbox}`,\n      );\n      return;\n    }\n\n    this.#processing = true;\n\n    try {\n      await this.processMailbox(this.#mailboxConfig);\n    } finally {\n      this.#processing = false;\n    }\n  }\n\n  private async processMailbox(config: MailboxConfig): Promise<void> {\n    this.#logger.debug(\n      `Processing mailbox: ${this.#mailboxConfig.mailboxIdentifier} ${this.#mailboxConfig.mailbox}`,\n    );\n\n    const lastOffset = await this.#offsetStore.getOffset(\n      generateOffsetIdentifier(this.#mailboxConfig),\n    );\n\n    const lastMessageId = (lastOffset?.id as number) || 0;\n\n    this.#logger.info('Last message ID', lastMessageId);\n    const messages = await this.#mailClient.readMail(\n      config.mailbox,\n      lastMessageId,\n    );\n    if (this.#mailboxConfig.type === 'metric') {\n      await this.sendMetricsToKafka(messages);\n    } else {\n      await this.sendDocumentsToKafka(messages);\n    }\n\n    if (messages.length === 0) {\n      this.#logger.debug(\n        `No new messages found for mailbox: ${this.#mailboxConfig.mailboxIdentifier} ${this.#mailboxConfig.mailbox}`,\n      );\n      return;\n    }\n\n    this.#logger.info('New last message ID', messages[messages.length - 1].uid);\n    this.storeId(messages[messages.length - 1].uid ?? 0);\n  }\n\n  private storeId(id: number) {\n    this.#offsetStore.setOffset(\n      { timestamp: 0, id, rawTimestamp: 0 },\n      generateOffsetIdentifier(this.#mailboxConfig),\n    );\n  }\n\n  private sendMetricsToKafka = async (\n    contents: MailMessage | Array<MailMessage>,\n  ): Promise<void> => {\n    let kafkaPayload: Array<XodSourceMessageType>;\n\n    if (Array.isArray(contents)) {\n      kafkaPayload = contents.map((content) => ({\n        type: 'SOURCE',\n        eventId: uuidv4(),\n        eventType: 'event.metric',\n        created: Date.now(),\n        ttl: 3600000, // 1 month\n        tenantIdentifier: this.#mailSourceConfig.tenantIdentifier,\n        payload: this.buildPayload(content),\n      }));\n    } else {\n      kafkaPayload = [\n        {\n          type: 'SOURCE',\n          eventId: uuidv4(),\n          eventType: 'event.metric',\n          created: Date.now(),\n          ttl: 3600000, // 1 month\n          tenantIdentifier: this.#mailSourceConfig.tenantIdentifier,\n          payload: this.buildPayload(contents),\n        },\n      ];\n    }\n\n    // Send JSON data to Kafka\n    await this.#kafkaService.send(\n      kafkaPayload,\n      generateKafkaTopic(this.#mailSourceConfig, this.#mailboxConfig),\n    );\n  };\n\n  private sendDocumentsToKafka = async (\n    contents: MailMessage | Array<MailMessage>,\n  ): Promise<void> => {\n    let kafkaPayload: Array<XodSourceMessageType>;\n\n    if (Array.isArray(contents)) {\n      kafkaPayload = contents.map((content) => ({\n        type: 'SOURCE',\n        eventId: uuidv4(),\n        eventType: `${this.#mailSourceConfig.tenantIdentifier}_SOURCE_${this.#mailboxConfig.mailboxIdentifier}`,\n        created: Date.now(),\n        ttl: 3600000, // 1 month\n        tenantIdentifier: this.#mailSourceConfig.tenantIdentifier,\n        payload: this.buildPayload(content),\n      }));\n    } else {\n      kafkaPayload = [\n        {\n          type: 'SOURCE',\n          eventId: uuidv4(),\n          eventType: `${this.#mailSourceConfig.tenantIdentifier}_SOURCE_${this.#mailboxConfig.mailboxIdentifier}`,\n          created: Date.now(),\n          ttl: 3600000, // 1 month\n          tenantIdentifier: this.#mailSourceConfig.tenantIdentifier,\n          payload: this.buildPayload(contents),\n        },\n      ];\n    }\n\n    this.#logger.info('payload', JSON.stringify(kafkaPayload, null, 2));\n\n    // Send JSON data to Kafka\n    await this.#kafkaService.send(\n      kafkaPayload,\n      generateKafkaTopic(this.#mailSourceConfig, this.#mailboxConfig),\n    );\n  };\n\n  private buildPayload = (parsedContent: MailMessage): XodSourcePayloadType => {\n    return {\n      keyField: 'messageId',\n      body: {\n        ...parsedContent,\n      },\n      collection: generateCollectionName(\n        this.#mailSourceConfig,\n        this.#mailboxConfig,\n      ),\n    };\n  };\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAAuC;AAOvC,kBAA6B;AAC7B,oBAAuB;AAGvB,oBAIO;AAIA,MAAM,2BAA2B;AAAA,EAiBtC,YACE,kBACA,QACA,cACA,YACA,aACA;AAtBF,uBAAc;AAwGd,SAAQ,qBAAqB,OAC3B,aACkB;AAClB,UAAI;AAEJ,UAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,uBAAe,SAAS,IAAI,CAAC,aAAa;AAAA,UACxC,MAAM;AAAA,UACN,aAAS,YAAAA,IAAO;AAAA,UAChB,WAAW;AAAA,UACX,SAAS,KAAK,IAAI;AAAA,UAClB,KAAK;AAAA;AAAA,UACL,kBAAkB,KAAK,kBAAkB;AAAA,UACzC,SAAS,KAAK,aAAa,OAAO;AAAA,QACpC,EAAE;AAAA,MACJ,OAAO;AACL,uBAAe;AAAA,UACb;AAAA,YACE,MAAM;AAAA,YACN,aAAS,YAAAA,IAAO;AAAA,YAChB,WAAW;AAAA,YACX,SAAS,KAAK,IAAI;AAAA,YAClB,KAAK;AAAA;AAAA,YACL,kBAAkB,KAAK,kBAAkB;AAAA,YACzC,SAAS,KAAK,aAAa,QAAQ;AAAA,UACrC;AAAA,QACF;AAAA,MACF;AAGA,YAAM,KAAK,cAAc;AAAA,QACvB;AAAA,YACA,kCAAmB,KAAK,mBAAmB,KAAK,cAAc;AAAA,MAChE;AAAA,IACF;AAEA,SAAQ,uBAAuB,OAC7B,aACkB;AAClB,UAAI;AAEJ,UAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,uBAAe,SAAS,IAAI,CAAC,aAAa;AAAA,UACxC,MAAM;AAAA,UACN,aAAS,YAAAA,IAAO;AAAA,UAChB,WAAW,GAAG,KAAK,kBAAkB,gBAAgB,WAAW,KAAK,eAAe,iBAAiB;AAAA,UACrG,SAAS,KAAK,IAAI;AAAA,UAClB,KAAK;AAAA;AAAA,UACL,kBAAkB,KAAK,kBAAkB;AAAA,UACzC,SAAS,KAAK,aAAa,OAAO;AAAA,QACpC,EAAE;AAAA,MACJ,OAAO;AACL,uBAAe;AAAA,UACb;AAAA,YACE,MAAM;AAAA,YACN,aAAS,YAAAA,IAAO;AAAA,YAChB,WAAW,GAAG,KAAK,kBAAkB,gBAAgB,WAAW,KAAK,eAAe,iBAAiB;AAAA,YACrG,SAAS,KAAK,IAAI;AAAA,YAClB,KAAK;AAAA;AAAA,YACL,kBAAkB,KAAK,kBAAkB;AAAA,YACzC,SAAS,KAAK,aAAa,QAAQ;AAAA,UACrC;AAAA,QACF;AAAA,MACF;AAEA,WAAK,QAAQ,KAAK,WAAW,KAAK,UAAU,cAAc,MAAM,CAAC,CAAC;AAGlE,YAAM,KAAK,cAAc;AAAA,QACvB;AAAA,YACA,kCAAmB,KAAK,mBAAmB,KAAK,cAAc;AAAA,MAChE;AAAA,IACF;AAEA,SAAQ,eAAe,CAAC,kBAAqD;AAC3E,aAAO;AAAA,QACL,UAAU;AAAA,QACV,MAAM;AAAA,UACJ,GAAG;AAAA,QACL;AAAA,QACA,gBAAY;AAAA,UACV,KAAK;AAAA,UACL,KAAK;AAAA,QACP;AAAA,MACF;AAAA,IACF;AAtKE,SAAK,oBAAoB;AACzB,SAAK,iBAAiB;AACtB,SAAK,gBAAgB;AACrB,SAAK,cAAc;AACnB,SAAK,UAAU,qBAAO,YAAY;AAClC,SAAK,eAAe;AAAA,EACtB;AAAA,EA7BA;AAAA,EAES;AAAA,EAEA;AAAA,EAEA;AAAA,EAEA;AAAA,EAEA;AAAA,EAET;AAAA,EAEA;AAAA,EAiBA,MAAa,OAAsB;AACjC,SAAK,oBAAgB;AAAA,MACnB,KAAK,eAAe,WAAW;AAAA,IACjC,EAAE,UAAU,YAAY;AACtB,YAAM,KAAK,QAAQ,EAAE,MAAM,CAAC,UAAU;AACpC,aAAK,QAAQ;AAAA,UACX,oEAAoE,MAAM,OAAO;AAAA,QACnF;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,OAAO;AACL,SAAK,eAAe,YAAY;AAAA,EAClC;AAAA,EAEA,MAAa,UAAyB;AACpC,QAAI,KAAK,aAAa;AACpB,WAAK,QAAQ;AAAA,QACX,uDAAuD,KAAK,eAAe,iBAAiB,IAAI,KAAK,eAAe,OAAO;AAAA,MAC7H;AACA;AAAA,IACF;AAEA,SAAK,cAAc;AAEnB,QAAI;AACF,YAAM,KAAK,eAAe,KAAK,cAAc;AAAA,IAC/C,UAAE;AACA,WAAK,cAAc;AAAA,IACrB;AAAA,EACF;AAAA,EAEA,MAAc,eAAe,QAAsC;AACjE,SAAK,QAAQ;AAAA,MACX,uBAAuB,KAAK,eAAe,iBAAiB,IAAI,KAAK,eAAe,OAAO;AAAA,IAC7F;AAEA,UAAM,aAAa,MAAM,KAAK,aAAa;AAAA,UACzC,wCAAyB,KAAK,cAAc;AAAA,IAC9C;AAEA,UAAM,gBAAiB,YAAY,MAAiB;AAEpD,SAAK,QAAQ,KAAK,mBAAmB,aAAa;AAClD,UAAM,WAAW,MAAM,KAAK,YAAY;AAAA,MACtC,OAAO;AAAA,MACP;AAAA,IACF;AACA,QAAI,KAAK,eAAe,SAAS,UAAU;AACzC,YAAM,KAAK,mBAAmB,QAAQ;AAAA,IACxC,OAAO;AACL,YAAM,KAAK,qBAAqB,QAAQ;AAAA,IAC1C;AAEA,QAAI,SAAS,WAAW,GAAG;AACzB,WAAK,QAAQ;AAAA,QACX,sCAAsC,KAAK,eAAe,iBAAiB,IAAI,KAAK,eAAe,OAAO;AAAA,MAC5G;AACA;AAAA,IACF;AAEA,SAAK,QAAQ,KAAK,uBAAuB,SAAS,SAAS,SAAS,CAAC,EAAE,GAAG;AAC1E,SAAK,QAAQ,SAAS,SAAS,SAAS,CAAC,EAAE,OAAO,CAAC;AAAA,EACrD;AAAA,EAEQ,QAAQ,IAAY;AAC1B,SAAK,aAAa;AAAA,MAChB,EAAE,WAAW,GAAG,IAAI,cAAc,EAAE;AAAA,UACpC,wCAAyB,KAAK,cAAc;AAAA,IAC9C;AAAA,EACF;AAwFF;",
  "names": ["uuidv4"]
}
