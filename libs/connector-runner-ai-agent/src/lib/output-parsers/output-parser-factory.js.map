{
  "version": 3,
  "sources": ["../../../../../../../../libs/connector-runner-ai-agent/src/lib/output-parsers/output-parser-factory.ts"],
  "sourcesContent": ["import { z } from 'zod';\n\n/**\n * Example usage of parseParametersToZod:\n * \n * const productReviewSchemaObject = {\n *   \"rating\": {\n *     \"type\": [\"integer\", \"null\"],\n *     \"description\": \"The rating of the product (1-5)\",\n *     \"minimum\": 1,\n *     \"maximum\": 5,\n *   },\n *   \"sentiment\": {\n *     \"type\": \"string\",\n *     \"enum\": [\"positive\", \"negative\"],\n *     \"description\": \"The sentiment of the review\",\n *     \"required\": true\n *   },\n *   \"key_points\": {\n *     \"type\": \"array\",\n *     \"items\": {\"type\": \"string\"},\n *     \"description\": \"The key points of the review\",\n *     \"required\": true\n *   }\n * };\n * \n * const ProductReviewSchema = parseParametersToZod(productReviewSchemaObject);\n * // Result: z.object({\n * //   rating: z.number().min(1).max(5).optional(),\n * //   sentiment: z.enum([\"positive\", \"negative\"]),\n * //   keyPoints: z.array(z.string()).describe(\"The key points of the review\"),\n * // });\n */\n\nexport const generateOutputParser = (\n  outputParameters: Record<string, any>,\n): object => {\n  const properties: Record<string, any> = {};\n  const required: string[] = [];\n\n  // Process each parameter\n  Object.entries(outputParameters).forEach(([key, value]) => {\n    const { required: isRequired, ...propertySchema } = value;\n    \n    // Add to properties without the 'required' field\n    properties[key] = propertySchema;\n    \n    // Add to required array if marked as required\n    if (isRequired === true) {\n      required.push(key);\n    }\n  });\n\n  return {\n    type: \"object\",\n    properties,\n    required,\n  };\n};\n\nconst toCamelCase = (str: string): string => {\n  return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());\n};\n\nexport const parseSchemaToZod = (schemaObject: any): z.ZodObject<any> => {\n  const { properties = {}, required = [] } = schemaObject;\n  const zodSchema: Record<string, any> = {};\n\n  Object.entries(properties).forEach(([key, property]: [string, any]) => {\n    const camelKey = toCamelCase(key);\n    let zodField;\n\n    // Handle different property types\n    if (property.type === 'string') {\n      if (property.enum) {\n        zodField = z.enum(property.enum as [string, ...string[]]);\n      } else {\n        zodField = z.string();\n      }\n    } else if (property.type === 'number' || property.type === 'integer') {\n      zodField = z.number();\n      if (property.minimum !== undefined) {\n        zodField = zodField.min(property.minimum);\n      }\n      if (property.maximum !== undefined) {\n        zodField = zodField.max(property.maximum);\n      }\n    } else if (property.type === 'array') {\n      if (property.items?.type === 'string') {\n        zodField = z.array(z.string());\n      } else if (property.items?.type === 'number' || property.items?.type === 'integer') {\n        zodField = z.array(z.number());\n      } else {\n        zodField = z.array(z.any());\n      }\n    } else if (Array.isArray(property.type)) {\n      // Handle union types like [\"integer\", \"null\"]\n      if (property.type.includes('null') && property.type.length === 2) {\n        const nonNullType = property.type.find((t: string) => t !== 'null');\n        if (nonNullType === 'integer' || nonNullType === 'number') {\n          zodField = z.number();\n          if (property.minimum !== undefined) {\n            zodField = zodField.min(property.minimum);\n          }\n          if (property.maximum !== undefined) {\n            zodField = zodField.max(property.maximum);\n          }\n        } else if (nonNullType === 'string') {\n          zodField = z.string();\n        } else {\n          zodField = z.any();\n        }\n      } else {\n        zodField = z.any();\n      }\n    } else {\n      zodField = z.any();\n    }\n\n    // Add description if available\n    if (property.description) {\n      zodField = zodField.describe(property.description);\n    }\n\n    // Make optional if not required\n    if (!required.includes(key)) {\n      zodField = zodField.optional();\n    }\n\n    zodSchema[camelKey] = zodField;\n  });\n\n  return z.object(zodSchema);\n};\n\nconst createZodFieldFromSchema = (propertySchema: any): any => {\n  let zodField;\n\n  // Handle different property types\n  if (Array.isArray(propertySchema.type)) {\n    // Handle union types like [\"integer\", \"null\"], [\"string\", \"null\"], etc.\n    if (propertySchema.type.includes('null') && propertySchema.type.length === 2) {\n      const nonNullType = propertySchema.type.find((t: string) => t !== 'null');\n      if (nonNullType === 'integer' || nonNullType === 'number') {\n        zodField = z.number();\n        if (propertySchema.minimum !== undefined) {\n          zodField = zodField.min(propertySchema.minimum);\n        }\n        if (propertySchema.maximum !== undefined) {\n          zodField = zodField.max(propertySchema.maximum);\n        }\n      } else if (nonNullType === 'string') {\n        zodField = z.string();\n      } else {\n        zodField = z.any();\n      }\n      // Make it nullable\n      zodField = zodField.nullable();\n    } else {\n      zodField = z.any();\n    }\n  } else if (propertySchema.type === 'string') {\n    if (propertySchema.enum) {\n      zodField = z.enum(propertySchema.enum as [string, ...string[]]);\n    } else {\n      zodField = z.string();\n    }\n  } else if (propertySchema.type === 'number' || propertySchema.type === 'integer') {\n    zodField = z.number();\n    if (propertySchema.minimum !== undefined) {\n      zodField = zodField.min(propertySchema.minimum);\n    }\n    if (propertySchema.maximum !== undefined) {\n      zodField = zodField.max(propertySchema.maximum);\n    }\n  } else if (propertySchema.type === 'object') {\n    // Handle nested objects\n    if (propertySchema.properties) {\n      const nestedSchema: Record<string, any> = {};\n      Object.entries(propertySchema.properties).forEach(([nestedKey, nestedProperty]: [string, any]) => {\n        const camelNestedKey = toCamelCase(nestedKey);\n        nestedSchema[camelNestedKey] = createZodFieldFromSchema(nestedProperty);\n        \n        // Add description if available\n        if (nestedProperty.description) {\n          nestedSchema[camelNestedKey] = nestedSchema[camelNestedKey].describe(nestedProperty.description);\n        }\n      });\n      zodField = z.object(nestedSchema);\n    } else {\n      zodField = z.object({});\n    }\n  } else if (propertySchema.type === 'array') {\n    if (propertySchema.items?.type === 'string') {\n      zodField = z.array(z.string());\n    } else if (propertySchema.items?.type === 'number' || propertySchema.items?.type === 'integer') {\n      zodField = z.array(z.number());\n    } else if (propertySchema.items?.type === 'object') {\n      // Handle arrays of objects\n      const itemSchema = createZodFieldFromSchema(propertySchema.items);\n      zodField = z.array(itemSchema);\n    } else if (Array.isArray(propertySchema.items?.type)) {\n      // Handle arrays with nullable item types\n      const itemSchema = createZodFieldFromSchema(propertySchema.items);\n      zodField = z.array(itemSchema);\n    } else {\n      zodField = z.array(z.any());\n    }\n  } else {\n    zodField = z.any();\n  }\n\n  return zodField;\n};\n\nexport const parseParametersToZod = (parametersObject: Record<string, any>): z.ZodObject<any> => {\n  const zodSchema: Record<string, any> = {};\n\n  Object.entries(parametersObject).forEach(([key, property]: [string, any]) => {\n    const camelKey = toCamelCase(key);\n    const { required: isRequired, ...propertySchema } = property;\n    \n    let zodField = createZodFieldFromSchema(propertySchema);\n\n    // Add description if available\n    if (propertySchema.description) {\n      zodField = zodField.describe(propertySchema.description);\n    }\n\n    // Make optional if not required\n    if (isRequired !== true) {\n      zodField = zodField.optional();\n    }\n\n    zodSchema[camelKey] = zodField;\n  });\n\n  return z.object(zodSchema);\n};\n"],
  "mappings": "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",
  "names": []
}
