{
  "version": 3,
  "sources": ["../../../../../../../libs/connector-runner-ai-agent/src/lib/connector-runner-ai-agent.ts"],
  "sourcesContent": ["import { ChatPromptTemplate } from '@langchain/core/prompts';\nimport { RunnableSequence } from '@langchain/core/runnables';\nimport { ChatOpenAI } from '@langchain/openai';\nimport {\n  ConnectorRuntimeSDK,\n  ConnectorSDKInterface,\n  LoggerSDKInterface,\n} from '@transai/connector-runtime-sdk';\nimport {\n  ActionInterface,\n  ConnectorInterface,\n  InputParameterInterface,\n  KafkaCallbackResponse,\n  XodBaseMessageType,\n  XodJobType,\n} from '@xip-online-data/types';\n\nimport { generateOutputParser } from './output-parsers';\nimport { AiAgentConfig } from './types';\n\nexport class ConnectorRunnerAiAgent extends ConnectorRuntimeSDK<AiAgentConfig> {\n  readonly CONNECTOR_INSTANCE: string = 'XOD_CONNECTOR_AI_AGENT_CONFIG';\n\n  readonly #logger: LoggerSDKInterface;\n\n  #langchainInstance: ChatOpenAI | undefined;\n\n  private get langchain(): ChatOpenAI {\n    if (this.#langchainInstance === undefined) {\n      throw new Error('Langchain instance not initialized');\n    }\n    return this.#langchainInstance;\n  }\n\n  constructor(\n    connector: ConnectorInterface<AiAgentConfig>,\n    connectorSDK: ConnectorSDKInterface,\n    injectedLangchainInstance?: ChatOpenAI,\n  ) {\n    super(connector, connectorSDK);\n\n    const { openai } = this.connectorSDK.config;\n\n    this.#logger = this.connectorSDK.logger;\n    this.#logger.debug(\n      `Initializing AI Agent Connector Runner with model: ${openai.model}`,\n    );\n\n    this.#langchainInstance =\n      injectedLangchainInstance ??\n      new ChatOpenAI({\n        apiKey: openai.apiKey,\n        model: openai.model || 'gpt-3.5-turbo',\n        temperature: openai.temperature || 0,\n        timeout: openai.timeout || 60000,\n      });\n  }\n\n  override init = async (): Promise<void> => {\n    this.#logger.debug('Initializing AI Agent Connector Runner');\n\n    this.callbackFunction = async (\n      message: XodJobType,\n      action: ActionInterface,\n    ): Promise<KafkaCallbackResponse> => {\n      const systemPrompt = action.config['systemPrompt'] as string;\n      if (!systemPrompt || systemPrompt.trim() === '') {\n        return this.connectorSDK.receiver.responses.unprocessableEntity(\n          'System prompt not found',\n        )(message);\n      }\n\n      const userPrompt = action.config['userPrompt'] as string;\n      if (!userPrompt || userPrompt.trim() === '') {\n        return this.connectorSDK.receiver.responses.unprocessableEntity(\n          'Prompt not found',\n        )(message);\n      }\n\n      const processedPrompt = this.processPromptTemplate(\n        `${systemPrompt}\\n\\n${userPrompt}`,\n        action.inputParameters,\n        message.payload,\n      );\n\n      this.#logger.debug(`Processed prompt: ${processedPrompt}`);\n\n      const { outputParameters } = action;\n      const outputParser = generateOutputParser(outputParameters);\n\n      const processedInstructions = this.escapeFormatInstructions(\n        outputParser.getFormatInstructions(),\n      );\n      this.#logger.debug(\n        `Processed format instructions: ${processedInstructions}`,\n      );\n\n      const chain = RunnableSequence.from([\n        ChatPromptTemplate.fromTemplate(\n          `<system>${processedPrompt}</system>\n            <format>${processedInstructions}</format>\n            <user>{{question}}</user>`,\n        ),\n        this.langchain,\n        outputParser,\n      ]);\n\n      this.#logger.info('Invoking AI agent...');\n      const response = await chain.invoke({\n        question: action.config['question'] || '',\n      });\n      this.#logger.info(`AI response: ${JSON.stringify(response, null, 2)}`);\n\n      const returnPayload: XodBaseMessageType = {\n        ...message,\n        payload: response as Record<string, unknown>,\n      };\n\n      return this.connectorSDK.receiver.responses.ok()(returnPayload);\n    };\n  };\n\n  // Escape single curly braces in format instructions within markdown code blocks\n  private escapeFormatInstructions(instructions: string): string {\n    // Find markdown code blocks and escape single curly braces within them\n    return instructions.replace(\n      /```json\\n([\\s\\S]*?)\\n```/g,\n      (match, jsonContent) => {\n        // Replace single curly braces with double curly braces in the JSON content\n        const escapedJson = jsonContent.replace(/{/g, '{{').replace(/}/g, '}}');\n        return `\\`\\`\\`json\\n${escapedJson}\\n\\`\\`\\``;\n      },\n    );\n  }\n\n  // Template processing with inputParameters\n  private processPromptTemplate(\n    template: string,\n    inputParams: Array<InputParameterInterface>,\n    payload: any,\n  ): string {\n    let processed = template;\n    inputParams.forEach((param) => {\n      const value = payload[param.name];\n      processed = processed.replace(\n        new RegExp(`\\\\{\\\\{inputs\\\\.${param.name}\\\\}\\\\}`, 'g'),\n        value,\n      );\n    });\n    return processed;\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAAmC;AACnC,uBAAiC;AACjC,oBAA2B;AAC3B,mCAIO;AAUP,4BAAqC;AAG9B,MAAM,+BAA+B,iDAAmC;AAAA,EAc7E,YACE,WACA,cACA,2BACA;AACA,UAAM,WAAW,YAAY;AAlB/B,SAAS,qBAA6B;AAqCtC,SAAS,OAAO,YAA2B;AACzC,WAAK,QAAQ,MAAM,wCAAwC;AAE3D,WAAK,mBAAmB,OACtB,SACA,WACmC;AACnC,cAAM,eAAe,OAAO,OAAO,cAAc;AACjD,YAAI,CAAC,gBAAgB,aAAa,KAAK,MAAM,IAAI;AAC/C,iBAAO,KAAK,aAAa,SAAS,UAAU;AAAA,YAC1C;AAAA,UACF,EAAE,OAAO;AAAA,QACX;AAEA,cAAM,aAAa,OAAO,OAAO,YAAY;AAC7C,YAAI,CAAC,cAAc,WAAW,KAAK,MAAM,IAAI;AAC3C,iBAAO,KAAK,aAAa,SAAS,UAAU;AAAA,YAC1C;AAAA,UACF,EAAE,OAAO;AAAA,QACX;AAEA,cAAM,kBAAkB,KAAK;AAAA,UAC3B,GAAG,YAAY;AAAA;AAAA,EAAO,UAAU;AAAA,UAChC,OAAO;AAAA,UACP,QAAQ;AAAA,QACV;AAEA,aAAK,QAAQ,MAAM,qBAAqB,eAAe,EAAE;AAEzD,cAAM,EAAE,iBAAiB,IAAI;AAC7B,cAAM,mBAAe,4CAAqB,gBAAgB;AAE1D,cAAM,wBAAwB,KAAK;AAAA,UACjC,aAAa,sBAAsB;AAAA,QACrC;AACA,aAAK,QAAQ;AAAA,UACX,kCAAkC,qBAAqB;AAAA,QACzD;AAEA,cAAM,QAAQ,kCAAiB,KAAK;AAAA,UAClC,kCAAmB;AAAA,YACjB,WAAW,eAAe;AAAA,sBACd,qBAAqB;AAAA;AAAA,UAEnC;AAAA,UACA,KAAK;AAAA,UACL;AAAA,QACF,CAAC;AAED,aAAK,QAAQ,KAAK,sBAAsB;AACxC,cAAM,WAAW,MAAM,MAAM,OAAO;AAAA,UAClC,UAAU,OAAO,OAAO,UAAU,KAAK;AAAA,QACzC,CAAC;AACD,aAAK,QAAQ,KAAK,gBAAgB,KAAK,UAAU,UAAU,MAAM,CAAC,CAAC,EAAE;AAErE,cAAM,gBAAoC;AAAA,UACxC,GAAG;AAAA,UACH,SAAS;AAAA,QACX;AAEA,eAAO,KAAK,aAAa,SAAS,UAAU,GAAG,EAAE,aAAa;AAAA,MAChE;AAAA,IACF;AA/EE,UAAM,EAAE,OAAO,IAAI,KAAK,aAAa;AAErC,SAAK,UAAU,KAAK,aAAa;AACjC,SAAK,QAAQ;AAAA,MACX,sDAAsD,OAAO,KAAK;AAAA,IACpE;AAEA,SAAK,qBACH,6BACA,IAAI,yBAAW;AAAA,MACb,QAAQ,OAAO;AAAA,MACf,OAAO,OAAO,SAAS;AAAA,MACvB,aAAa,OAAO,eAAe;AAAA,MACnC,SAAS,OAAO,WAAW;AAAA,IAC7B,CAAC;AAAA,EACL;AAAA,EAjCS;AAAA,EAET;AAAA,EAEA,IAAY,YAAwB;AAClC,QAAI,KAAK,uBAAuB,QAAW;AACzC,YAAM,IAAI,MAAM,oCAAoC;AAAA,IACtD;AACA,WAAO,KAAK;AAAA,EACd;AAAA;AAAA,EA2FQ,yBAAyB,cAA8B;AAE7D,WAAO,aAAa;AAAA,MAClB;AAAA,MACA,CAAC,OAAO,gBAAgB;AAEtB,cAAM,cAAc,YAAY,QAAQ,MAAM,IAAI,EAAE,QAAQ,MAAM,IAAI;AACtE,eAAO;AAAA,EAAe,WAAW;AAAA;AAAA,MACnC;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGQ,sBACN,UACA,aACA,SACQ;AACR,QAAI,YAAY;AAChB,gBAAY,QAAQ,CAAC,UAAU;AAC7B,YAAM,QAAQ,QAAQ,MAAM,IAAI;AAChC,kBAAY,UAAU;AAAA,QACpB,IAAI,OAAO,kBAAkB,MAAM,IAAI,UAAU,GAAG;AAAA,QACpD;AAAA,MACF;AAAA,IACF,CAAC;AACD,WAAO;AAAA,EACT;AACF;",
  "names": []
}
