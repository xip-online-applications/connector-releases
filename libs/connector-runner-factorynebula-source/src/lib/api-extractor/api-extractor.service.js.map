{
  "version": 3,
  "sources": ["../../../../../../../../libs/connector-runner-factorynebula-source/src/lib/api-extractor/api-extractor.service.ts"],
  "sourcesContent": ["import {\n  OffsetStore,\n  PersistentOffsetStoreInterface,\n} from '@transai/connector-runtime';\nimport { Logger } from '@transai/logger';\nimport axios, { AxiosRequestConfig } from 'axios';\nimport Handlebars from 'handlebars';\nimport helpers from 'handlebars-helpers';\nimport { interval, Subscription } from 'rxjs';\n\nimport { ApiResultHandler } from '../api-result.handler';\nimport { generateOffsetIdentifier } from '../helper.functions';\nimport { ApiConfig, ApiSourceConfig } from '../types';\n\nexport class ApiExtractorService {\n  readonly #config: ApiSourceConfig;\n\n  readonly #apiConfig: ApiConfig;\n\n  readonly #apiResultHandler: ApiResultHandler;\n\n  readonly #offsetStore: PersistentOffsetStoreInterface;\n\n  readonly #handlebarsTemplate: HandlebarsTemplateDelegate | undefined;\n\n  readonly #urlTemplate: HandlebarsTemplateDelegate;\n\n  #processing = false;\n\n  readonly #handlebarsInstance: typeof Handlebars | undefined;\n\n  #logger: Logger;\n\n  #subscription?: Subscription;\n\n  constructor(\n    config: ApiSourceConfig,\n    apiConfig: ApiConfig,\n    apiResultHandler: ApiResultHandler,\n    offsetStore: PersistentOffsetStoreInterface,\n  ) {\n    this.#config = config;\n    this.#apiConfig = apiConfig;\n    this.#apiResultHandler = apiResultHandler;\n    this.#offsetStore = offsetStore;\n\n    if (!apiConfig.url) {\n      throw new Error('URL is not defined in apiConfig');\n    }\n\n    this.#logger = Logger.getInstance();\n    this.#logger.debug(\n      `Api source service initialized: ${this.#apiConfig.name} with interval of ${this.#apiConfig.interval} seconds`,\n    );\n\n    this.#handlebarsInstance = Handlebars.create();\n    helpers({ handlebars: this.#handlebarsInstance });\n    this.#handlebarsInstance.registerHelper(\n      'formatISODate',\n      function (timestamp, timezone: string) {\n        const date = new Date(timestamp);\n        return date.toISOString();\n      },\n    );\n\n    if (apiConfig.body) {\n      this.#handlebarsTemplate = this.#handlebarsInstance.compile(\n        apiConfig.body,\n        { strict: true },\n      );\n      this.validateTemplate();\n    }\n\n    this.#urlTemplate = this.#handlebarsInstance.compile(apiConfig.url, {\n      strict: true,\n    });\n\n    this.#subscription = interval(this.#apiConfig.interval * 1000).subscribe(\n      async () => {\n        await this.extract();\n      },\n    );\n  }\n\n  stop() {\n    this.#subscription?.unsubscribe();\n  }\n\n  private async extract(): Promise<void> {\n    if (this.#processing) {\n      this.#logger.debug(\n        'Api source service is already processing: ',\n        this.#apiConfig.name,\n      );\n      return;\n    }\n\n    this.#processing = true;\n    try {\n      await this.executeApi().catch((error) => {\n        throw new Error(\n          `Error while extracting data from api source service ${error.message}`,\n        );\n      });\n    } catch (error) {\n      Logger.getInstance().debug(JSON.stringify(error));\n    } finally {\n      this.#processing = false;\n    }\n  }\n\n  private async executeApi(): Promise<void> {\n    const latestOffset = await this.#offsetStore.getOffset(\n      generateOffsetIdentifier(this.#apiConfig),\n    );\n    Logger.getInstance().debug(\n      `Latest offset for ${this.#apiConfig.name}: ${JSON.stringify(latestOffset)}`,\n    );\n    const body = this.getBody(latestOffset, this.#apiConfig.batchSize ?? 10);\n    const url = this.getUrl(latestOffset, this.#apiConfig.batchSize ?? 10);\n\n    Logger.getInstance().debug(\n      `Executing ${this.#apiConfig.method} request to ${url} with body ${body}`,\n    );\n    const contentType: string = this.#apiConfig.format ?? 'text';\n    const headers: { 'Content-Type': string; Authorization?: string } = {\n      'Content-Type': contentType,\n    };\n\n    if (this.#apiConfig.authorization) {\n      // add authorization header from authorization from apiConfig if set\n      headers['Authorization'] = this.#apiConfig.authorization;\n    }\n\n    const config: AxiosRequestConfig = {\n      responseType: 'text',\n      headers,\n    };\n\n    try {\n      let result;\n\n      switch (this.#apiConfig.method) {\n        case 'POST':\n          result = await axios.post(url, body, config);\n          break;\n        case 'GET':\n          result = await axios.get(url, config);\n          break;\n        default:\n          throw new Error(`Unsupported method ${this.#apiConfig.method}`);\n      }\n\n      await this.#apiResultHandler.handleResult(result, this.#apiConfig);\n    } catch (error) {\n      this.#logger.debug(\n        `Error while extracting data from api source service: ${JSON.stringify(error)}`,\n      );\n    }\n  }\n\n  private getBody(offset: OffsetStore, limit: number): string {\n    if (!this.#handlebarsTemplate) {\n      return '';\n    }\n\n    return this.#handlebarsTemplate({\n      ...offset,\n      limit,\n    });\n  }\n\n  private getUrl(offset: OffsetStore, limit: number): string {\n    return this.#urlTemplate({\n      ...offset,\n      limit,\n    });\n  }\n\n  private validateTemplate(): void {\n    this.getBody({ timestamp: 0, id: 0, rawTimestamp: 0 }, 0);\n  }\n}\n"],
  "mappings": "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",
  "names": ["Handlebars", "helpers", "axios"]
}
