{
  "version": 3,
  "sources": ["../../../../../../../../libs/connector-runtime/src/lib/offset-store/offset-store.service.ts"],
  "sourcesContent": ["import { promises as fs } from 'fs';\n\nimport {\n  ExtendedOffsetStore,\n  PersistentOffsetStoreInterface,\n} from '@transai/connector-runtime';\nimport { Logger } from '@transai/logger';\nimport { BaseConnectorConfig, OffsetInterface } from '@xip-online-data/types';\nimport { catchError, from, interval, of, switchMap } from 'rxjs';\n\nimport { isOffsetStoreType, OffsetStore } from './types';\n\nexport class OffsetStoreService implements PersistentOffsetStoreInterface {\n  readonly #offsetDirectory: string;\n\n  readonly #offsetCache: Map<string, ExtendedOffsetStore> = new Map();\n\n  readonly #cloudOffsetCache: Map<string, ExtendedOffsetStore> = new Map();\n\n  readonly #log = Logger.getInstance();\n\n  readonly #connectorConfig: BaseConnectorConfig;\n\n  get offsetValues(): Array<string> {\n    return Array.from(this.#offsetCache.keys());\n  }\n\n  constructor(offsetDirectory: string, connectorConfig: BaseConnectorConfig) {\n    this.#offsetDirectory = offsetDirectory;\n    this.#connectorConfig = connectorConfig;\n  }\n\n  public async init(): Promise<void> {\n    let locExist = true;\n    await fs.stat(this.#offsetDirectory).catch((error) => {\n      if (error.code === 'ENOENT') {\n        locExist = false;\n      } else {\n        throw error;\n      }\n    });\n    if (!locExist) {\n      this.#log.debug(`OffsetStore create ${this.#offsetDirectory}`);\n      await fs.mkdir(this.#offsetDirectory);\n    }\n\n    this.#startStoreInterval();\n  }\n\n  public async deInit(): Promise<void> {\n    await this.#storeOffsetFileSystem();\n  }\n\n  public async getOffset(identifier: string): Promise<OffsetStore> {\n    // prio 1. memory cache\n    if (this.#offsetCache.has(identifier)) {\n      return this.#offsetCache.get(identifier) as OffsetStore;\n    }\n\n    this.#log.debug(\n      `${identifier} Does not have a memory offset. Use disk cache instead.`,\n    );\n\n    try {\n      // prio 2. disk cache, new identifier naming\n      const offsetFile = await fs\n        .readFile(this.#getOffsetFilePath(identifier), 'utf8')\n        .catch((error) => {\n          if (error.code === 'ENOENT') {\n            this.#log.debug(\n              `OffsetStore: ${this.#getOffsetFilePath(\n                identifier,\n              )} does not exist. continue to deprecated offsets.`,\n            );\n          } else {\n            this.#log.error(\n              `OffsetStore: Error reading offset file ${this.#getOffsetFilePath(\n                identifier,\n              )}: ${error}, continue to deprecated offsets.`,\n            );\n          }\n          return '{}';\n        });\n\n      const offsetStore = JSON.parse(offsetFile);\n      const isValidOffset = isOffsetStoreType(offsetStore);\n\n      if (isValidOffset) {\n        return offsetStore;\n      }\n\n      // prio 3. disk cache, old identifier naming\n      const offsetFileDeprecated = await fs\n        .readFile(this.#getOffsetFilePathDeprecated(identifier), 'utf8')\n        .catch((error) => {\n          if (error.code === 'ENOENT') {\n            this.#log.debug(\n              `OffsetStore: ${this.#getOffsetFilePathDeprecated(\n                identifier,\n              )} does not exist. continue to check api offsets.`,\n            );\n          } else {\n            this.#log.error(\n              `OffsetStore: Error reading offset file ${this.#getOffsetFilePathDeprecated(\n                identifier,\n              )}: ${error}, continue to check api offsets.`,\n            );\n          }\n          return '{}';\n        });\n\n      const offsetStoreDeprecated = JSON.parse(offsetFileDeprecated);\n      const isValidOffsetDeprecated = isOffsetStoreType(offsetStoreDeprecated);\n\n      if (isValidOffsetDeprecated) {\n        this.#log.warn(\n          `OffsetStore: read file from deprecated location. Leave connector on for a while so it will be migrated to the new location automatically :).`,\n        );\n        return offsetStoreDeprecated;\n      }\n\n      this.#log.debug(\n        `${identifier} OffsetStore: ${this.#getOffsetFilePath(\n          identifier,\n        )} is not valid. Gotten ${offsetFile}. Try to use api offset.`,\n      );\n\n      // prio 3. API cloud cache (no user overwrite)\n      if (this.#cloudOffsetCache.has(identifier)) {\n        return this.#cloudOffsetCache.get(identifier) as OffsetStore;\n      }\n\n      // fallback. Current date.\n      const date = new Date();\n      const timestamp = date.getTime();\n      const rawTimestamp = date.toISOString();\n\n      const defaultOffset = {\n        id: 0,\n        timestamp,\n        rawTimestamp,\n        isoDate: rawTimestamp,\n      };\n\n      this.#log.debug(\n        `${identifier} Does not have a offset. Use default offset instead. setting offset to ${JSON.stringify(defaultOffset)}`,\n      );\n\n      // Store the default offset in the cache, so new records are found when they are created\n      this.setOffset(defaultOffset, identifier);\n      await this.#storeOffsetFileSystem();\n\n      return defaultOffset;\n    } catch (error) {\n      const date = new Date();\n      const timestamp = date.getTime();\n      const rawTimestamp = date.toISOString();\n\n      return {\n        id: 0,\n        timestamp,\n        rawTimestamp,\n        isoDate: rawTimestamp,\n      };\n    }\n  }\n\n  public setOffset(offset: OffsetStore, identifier: string): void {\n    // TODO: Rene change so it does not need to be parsed.\n    this.#offsetCache.set(identifier, offset as ExtendedOffsetStore);\n    this.#log.debug(\n      `storing offset for ${identifier} in cache, ${JSON.stringify(offset)}`,\n    );\n  }\n\n  public writeFile(\n    fileName: string,\n    data: { [key: string]: string },\n  ): Promise<void> {\n    return fs.writeFile(\n      this.#getOffsetFilePath(fileName),\n      JSON.stringify(data),\n    );\n  }\n\n  public initCloudOffsets(offsets: Array<OffsetInterface>): void {\n    offsets.forEach((o) => {\n      const { identifier, offset } = o;\n      this.#log.debug(`Initializing offset for ${identifier}`);\n      this.#cloudOffsetCache.set(identifier, offset);\n      if (offset['userOverwrite']) {\n        this.#offsetCache.set(identifier, offset);\n      }\n    });\n  }\n\n  #startStoreInterval(): void {\n    interval(60 * 1000)\n      .pipe(\n        switchMap(() => {\n          return from(this.#storeOffsetFileSystem());\n        }),\n        catchError((error) => {\n          this.#log.error(`Error storing offsets: ${JSON.stringify(error)}`);\n          return of(null);\n        }),\n      )\n      .subscribe((v) => {\n        if (v !== null) {\n          this.#log.verbose('Offsets stored on disk completed.');\n        }\n      });\n  }\n\n  #storeOffsetFileSystem(): Promise<Array<void>> {\n    const keys = Array.from(this.#offsetCache.keys());\n    this.#log.verbose(\n      `storing offset for ${keys.length} in filesystem, ${keys.join(', ')}`,\n    );\n\n    return Promise.all(\n      keys.map((key: string) => {\n        const offset = this.#offsetCache.get(key);\n        return fs.writeFile(\n          this.#getOffsetFilePath(key),\n          JSON.stringify(offset),\n        );\n      }),\n    );\n  }\n\n  #getOffsetFilePath(identifier: string): string {\n    return `${this.#offsetDirectory}/${this.#connectorConfig.datasourceIdentifier}-${identifier}.json`;\n  }\n\n  #getOffsetFilePathDeprecated(identifier: string): string {\n    return `${this.#offsetDirectory}/${identifier}.json`;\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_types", "fs"]
}
