{
  "version": 3,
  "sources": ["../../../../../../../libs/connector-runtime/src/lib/connector-runtime.ts"],
  "sourcesContent": ["import Handlebars, { Exception } from 'handlebars';\nimport helpers from 'handlebars-helpers';\nimport { handleError, waitTillRestart } from '@xip-online-data/handle-error';\nimport {\n  KafkaCallbackResponse,\n  BaseConnectorConfig,\n  XodBaseMessageType,\n  ActionInterface,\n  XodJobType,\n  ConnectorInterface,\n} from '@xip-online-data/types';\nimport { parseYaml } from '@xip-online-data/parse-yaml';\nimport {\n  buildConnectorTopic,\n  expirationValidatorInLine,\n} from '@xip-online-data/helper-functions';\nimport * as process from 'node:process';\nimport { bufferTime, filter, map, Observable, Subject } from 'rxjs';\nimport {\n  KafkaSourceInterface,\n  KafkaSourceService,\n  RdKafkaSourceService,\n} from '@xip-online-data/kafka-base-service';\nimport { Logger, LogLevels } from '@transai/logger';\nimport moment from 'moment-timezone';\nimport { PersistentOffsetStoreInterface } from './offset-store';\nimport { OffsetStoreService } from './offset-store/offset-store.service';\nimport { CloudOffsetStoreService } from './offset-store/cloud-offset-store.service';\nimport { ConnectorRuntimeInterface } from './connector-runtime.interface';\n\nexport interface IpcMessage {\n  cmd: string;\n  message: string;\n}\n\nexport abstract class ConnectorRuntime<T> implements ConnectorRuntimeInterface {\n  public readonly IPC_CHANNEL = 'connector-runtime';\n\n  protected abstract readonly CONNECTOR_INSTANCE: string;\n\n  protected readonly offsetStoreInstance:\n    | PersistentOffsetStoreInterface\n    | undefined = undefined;\n\n  public get offsetStore(): PersistentOffsetStoreInterface {\n    if (this.offsetStoreInstance === undefined) {\n      throw new Error('Offset service not initialized');\n    }\n\n    return this.offsetStoreInstance;\n  }\n\n  protected readonly CONNECTOR_IDENTIFIER: string;\n\n  protected readonly log: Logger;\n\n  protected kafkaServiceInstance?: KafkaSourceInterface;\n\n  public get kafkaService(): KafkaSourceInterface {\n    if (this.kafkaServiceInstance === undefined) {\n      throw new Error('Kafka service not initialized');\n    }\n\n    return this.kafkaServiceInstance;\n  }\n\n  protected callbackFunction:\n    | ((message: XodBaseMessageType) => Promise<KafkaCallbackResponse>)\n    | undefined = undefined;\n\n  public getCallbackFunction(): (\n    message: XodBaseMessageType,\n  ) => Promise<KafkaCallbackResponse> {\n    if (this.callbackFunction === undefined) {\n      throw new Error(`Callback function not defined`);\n    }\n\n    return this.callbackFunction;\n  }\n\n  protected isValidConfig: (config: T & BaseConnectorConfig) => boolean = () =>\n    true;\n\n  protected init: () => Promise<void> = () => Promise.resolve();\n\n  protected exit: () => Promise<void> = () => Promise.resolve();\n\n  private connectorConfig?: T & BaseConnectorConfig = undefined;\n\n  protected get config(): T & BaseConnectorConfig {\n    if (this.connectorConfig === undefined) {\n      throw new Error('No connector config provided');\n    }\n\n    return this.connectorConfig;\n  }\n\n  private readonly messageSubject = new Subject<string>();\n\n  public get messageObservable(): Observable<Array<string>> {\n    return this.messageSubject.asObservable().pipe(\n      // Group all messages in a timespan of 100\n      bufferTime(100),\n      // Filterout the empty arrays\n      filter((values) => values.length > 0),\n      // Only send the unique values in the array\n      map((values) => Array.from(new Set(values))),\n    );\n  }\n\n  protected getActionConfig(message: XodJobType): ActionInterface {\n    if (message.actionVersion === undefined) {\n      throw new Error('Action version is not defined');\n    }\n\n    if (message.actionVersion === 'latest') {\n      return this.getLatestActionConfig(message);\n    }\n\n    return this.getSpecificActionConfig(message);\n  }\n\n  protected getLatestActionConfig(message: XodJobType): ActionInterface {\n    const actions = this.actionConfigs.filter(\n      (action) => action.identifier === message.actionIdentifier,\n    );\n\n    if (actions.length === 0) {\n      throw new Error(\n        `Action ${message.eventType} has ${actions.length} configurations. Expected 1`,\n      );\n    }\n\n    return actions.sort((a, b) => {\n      return a.createdAt > b.createdAt ? -1 : 1;\n    })[0];\n  }\n\n  protected getSpecificActionConfig(message: XodJobType): ActionInterface {\n    const actions = this.actionConfigs.filter((action) => {\n      return (\n        action.identifier === message.actionIdentifier &&\n        action.version === message.actionVersion\n      );\n    });\n\n    if (actions.length !== 1) {\n      throw new Error(\n        `Action ${message.eventType} has ${actions.length} configurations. Expected 1`,\n      );\n    }\n    return actions[0];\n  }\n\n  constructor(\n    protected readonly connector: ConnectorInterface,\n    private readonly apiConfig: T & BaseConnectorConfig,\n    private readonly actionConfigs: Array<ActionInterface>,\n  ) {\n    this.CONNECTOR_IDENTIFIER = connector.identifier;\n    this.log = Logger.getInstance(\n      connector.identifier,\n      apiConfig.debug ? LogLevels.debug : LogLevels.info,\n    );\n\n    const tmpdir = process.env['TRANSAI_TMP_DIR'];\n    if (tmpdir) {\n      this.log.debug(\n        `Connector ID: ${connector.identifier} - ${tmpdir}, using offset store ${process.env['USE_MANAGEMENT_API_OFFSET'] === 'true' ? 'API' : 'FILE'}`,\n      );\n      const offsetStore: PersistentOffsetStoreInterface =\n        process.env['USE_MANAGEMENT_API_OFFSET'] === 'true'\n          ? new CloudOffsetStoreService(\n              tmpdir,\n              apiConfig,\n              this.CONNECTOR_IDENTIFIER,\n            )\n          : new OffsetStoreService(tmpdir, apiConfig);\n\n      offsetStore\n        .init()\n        .then(() => {\n          this.log.debug('Offset store initialized. write start time');\n          offsetStore\n            .writeFile(this.CONNECTOR_IDENTIFIER, {\n              start: new Date().toISOString(),\n            })\n            .then(() => {\n              this.log.debug('Start time written');\n            })\n            .catch((err) => {\n              this.log.error('Error writing start time');\n              throw err;\n            });\n        })\n        .catch((err) => {\n          this.log.error('Error init offset store');\n          throw err;\n        });\n\n      this.offsetStoreInstance = offsetStore;\n    }\n\n    if (process.on) {\n      process.on('message', (message: IpcMessage) => {\n        if (message.cmd === this.IPC_CHANNEL) {\n          this.messageSubject.next(message.message);\n        }\n      });\n    } else {\n      this.log.warn('IPC channel is not available. process.on is undefined.');\n    }\n\n    if (!process.send) {\n      // Check if process.send is available\n      this.log.warn('IPC channel is not available. process.send is undefined.');\n    }\n\n    this.messageSubject.subscribe((message: string) => {\n      this.log.verbose(\n        `${process.pid} Received message from parent process:`,\n        message,\n      );\n    });\n\n    helpers();\n    Handlebars.registerHelper('getFirst', function (inputString, delimiter) {\n      if (typeof inputString !== 'string' || typeof delimiter !== 'string') {\n        return inputString;\n      }\n\n      if (inputString.includes(delimiter)) {\n        return inputString.split(delimiter)[0];\n      }\n\n      return inputString;\n    });\n    Handlebars.registerHelper(\n      'formatDateInTimezone',\n      (datetimeString, timezone, format) => {\n        // Check if the format parameter is actually a Handlebars options object, which happens if no format is provided\n        if (typeof format === 'object') {\n          // If so, use moment's default format by not specifying a format string\n          format = undefined; // This will make moment use its default ISO 8601 format\n        }\n\n        if (datetimeString === 'now') {\n          return moment().tz(timezone).format(format);\n        }\n\n        return moment(datetimeString).tz(timezone).format(format);\n      },\n    );\n    Handlebars.registerHelper(\n      'datetimeToDecimalHours',\n      function (datetimeString) {\n        // Parse the datetime string into a Moment.js object, assuming UTC\n        const datetime = moment.parseZone(datetimeString);\n\n        // Calculate decimal hours\n        const hours = datetime.hours();\n        const minutes = datetime.minutes();\n        const seconds = datetime.seconds();\n        const decimalHours = hours + minutes / 60 + seconds / 3600;\n\n        // Return formatted decimal hours\n        return decimalHours.toFixed(2);\n      },\n    );\n    Handlebars.registerHelper('isFalse', function (value) {\n      return value === false || value === 'false';\n    });\n    Handlebars.registerHelper('isTrue', function (value) {\n      return value === true || value === 'true';\n    });\n\n    // eslint-disable-next-line no-restricted-syntax\n    for (const action of this.actionConfigs) {\n      if (action.config['templates'] !== undefined) {\n        const templates = action.config['templates'] as {\n          [key: string]: string;\n        };\n        const containers = {} as {\n          [key: string]: HandlebarsTemplateDelegate<unknown>;\n        };\n        const templateKeys = Object.keys(templates);\n        templateKeys.forEach((key: string) => {\n          try {\n            const template = templates[key];\n            const handlebars = Handlebars.compile(template);\n            containers[key] = handlebars;\n          } catch (error: unknown) {\n            this.log.error(\n              `Error compiling template ${key} for action ${action.identifier}`,\n            );\n            if (error instanceof Exception) {\n              this.log.error(error.message);\n            }\n          }\n        });\n        action.config['parsedTemplates'] = containers;\n      }\n    }\n  }\n\n  public async start() {\n    this.connectorConfig = await this.getConfig();\n    this.kafkaServiceInstance = this.connectorConfig.kafka.useConfluentLibrary\n      ? new RdKafkaSourceService(\n          this.config,\n          buildConnectorTopic(this.connector),\n        )\n      : new KafkaSourceService(\n          this.config,\n          buildConnectorTopic(this.connector),\n        );\n    await this.init();\n\n    if (this.callbackFunction !== undefined) {\n      this.kafkaServiceInstance.setCallbackFunction(\n        expirationValidatorInLine(\n          this.config.action?.timeSensitive === true,\n          this.callbackFunction,\n        ),\n      );\n    }\n\n    await this.kafkaServiceInstance.init();\n  }\n\n  public async stop() {\n    await this.offsetStoreInstance?.deInit();\n\n    const processesToExit = [this.exit()];\n    if (this.kafkaServiceInstance !== undefined) {\n      processesToExit.push(this.kafkaServiceInstance.exitProcess('stop'));\n    }\n    await Promise.all(processesToExit);\n  }\n\n  protected async getConfig(): Promise<T & BaseConnectorConfig> {\n    let config: T & BaseConnectorConfig;\n    const configSource =\n      process.env['TRANSAI_CONFIG_SOURCE'] || process.env['XOD_CONFIG_SOURCE'];\n\n    if (configSource === 'json') {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      config = JSON.parse(process.env[this.CONNECTOR_INSTANCE!]!) as T &\n        BaseConnectorConfig;\n\n      if (!this.checkConfig(config)) {\n        await waitTillRestart('Config file is not valid');\n      }\n\n      return config;\n    }\n    if (configSource === 'api') {\n      config = this.apiConfig;\n    } else {\n      config = parseYaml(process.argv) as T & BaseConnectorConfig;\n    }\n\n    if (!this.checkConfig(config)) {\n      handleError('Config file is not valid, Not starting. Have to restart');\n    }\n\n    return config;\n  }\n\n  private checkConfig(config: T & BaseConnectorConfig): boolean {\n    // check if config is valid Base Connector Config;\n    return true; // this.isValidConfig(config) && isBaseConnectorConfigType(config);\n  }\n\n  protected emitEventType(\n    callbackFunction: (\n      message: XodBaseMessageType,\n    ) => Promise<KafkaCallbackResponse>,\n  ): (message: XodBaseMessageType) => Promise<KafkaCallbackResponse> {\n    return (message: XodBaseMessageType) => {\n      this.emit(message.eventType);\n      return callbackFunction(message);\n    };\n  }\n\n  private emit(message: string): void {\n    const processMessage: IpcMessage = {\n      cmd: this.IPC_CHANNEL,\n      message,\n    };\n    if (process.send) {\n      // Ensure process.send exists before sending\n      process.send(processMessage);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_offset_store", "helpers", "Handlebars", "moment"]
}
