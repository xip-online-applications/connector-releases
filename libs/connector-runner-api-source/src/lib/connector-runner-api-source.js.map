{
  "version": 3,
  "sources": ["../../../../../../../libs/connector-runner-api-source/src/lib/connector-runner-api-source.ts"],
  "sourcesContent": ["import { ConnectorRuntime } from '@transai/connector-runtime';\nimport { ApiResultHandler } from './api-result.handler';\nimport { ApiExtractorService } from './api-extractor/api-extractor.service';\nimport { ApiSourceConfig, isApiSourceConfigType } from './types';\nimport { KafkaService } from './kafka/kafka.service';\nimport { TokenManager } from './token-manager/token-manager';\nimport { JsessionManager } from './jsession-manager/jsession-manager';\nimport { Api } from './api/api';\n\nexport class ConnectorRunnerApiSource extends ConnectorRuntime<ApiSourceConfig> {\n  readonly CONNECTOR_INSTANCE: string = 'XOD_CONNECTOR_API_SOURCE_CONFIG';\n\n  private kafkaWrapper: KafkaService | undefined = undefined;\n\n  #apiExtractorServices: Array<ApiExtractorService> = [];\n\n  override init = async (): Promise<void> => {\n    const store = this.offsetStoreInstance;\n    if (!store) {\n      throw new Error(\n        'Offset store is not defined. Please provide an temp location for the offset store.',\n      );\n    }\n\n    const config = this.config!;\n\n    this.kafkaWrapper = new KafkaService(this.kafkaService!);\n\n    const apiResultHandler = new ApiResultHandler(\n      config,\n      this.kafkaWrapper,\n      store,\n    );\n\n    let tokenManager: TokenManager | undefined;\n    let sessionManager: JsessionManager | undefined;\n\n    if (config.tokenUrl && config.clientId && config.clientSecret) {\n      tokenManager = new TokenManager(\n        config.tokenUrl,\n        config.clientId,\n        config.clientSecret,\n      );\n    }\n\n    if (config.sessionUrl && config.sessionUsername && config.sessionPassword) {\n      sessionManager = new JsessionManager(\n        config.sessionUrl,\n        config.sessionUsername,\n        config.sessionPassword,\n      );\n    }\n\n    this.#apiExtractorServices = config.apiCalls.map((apiConfig) => {\n      const api = new Api(config, tokenManager, sessionManager);\n      return new ApiExtractorService(\n        config,\n        apiConfig,\n        api,\n        apiResultHandler,\n        store,\n      );\n    });\n  };\n\n  override exit = async () => {\n    this.#apiExtractorServices.forEach((service) => service.stop());\n    this.#apiExtractorServices = [];\n  };\n\n  override isValidConfig = (config: ApiSourceConfig): boolean => {\n    return isApiSourceConfigType(config);\n  };\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAAiC;AACjC,wBAAiC;AACjC,2BAAoC;AACpC,mBAAuD;AACvD,mBAA6B;AAC7B,2BAA6B;AAC7B,8BAAgC;AAChC,iBAAoB;AAEb,MAAM,iCAAiC,0CAAkC;AAAA,EAAzE;AAAA;AACL,SAAS,qBAA6B;AAEtC,SAAQ,eAAyC;AAEjD,iCAAoD,CAAC;AAErD,SAAS,OAAO,YAA2B;AACzC,YAAM,QAAQ,KAAK;AACnB,UAAI,CAAC,OAAO;AACV,cAAM,IAAI;AAAA,UACR;AAAA,QACF;AAAA,MACF;AAEA,YAAM,SAAS,KAAK;AAEpB,WAAK,eAAe,IAAI,0BAAa,KAAK,YAAa;AAEvD,YAAM,mBAAmB,IAAI;AAAA,QAC3B;AAAA,QACA,KAAK;AAAA,QACL;AAAA,MACF;AAEA,UAAI;AACJ,UAAI;AAEJ,UAAI,OAAO,YAAY,OAAO,YAAY,OAAO,cAAc;AAC7D,uBAAe,IAAI;AAAA,UACjB,OAAO;AAAA,UACP,OAAO;AAAA,UACP,OAAO;AAAA,QACT;AAAA,MACF;AAEA,UAAI,OAAO,cAAc,OAAO,mBAAmB,OAAO,iBAAiB;AACzE,yBAAiB,IAAI;AAAA,UACnB,OAAO;AAAA,UACP,OAAO;AAAA,UACP,OAAO;AAAA,QACT;AAAA,MACF;AAEA,WAAK,wBAAwB,OAAO,SAAS,IAAI,CAAC,cAAc;AAC9D,cAAM,MAAM,IAAI,eAAI,QAAQ,cAAc,cAAc;AACxD,eAAO,IAAI;AAAA,UACT;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AAEA,SAAS,OAAO,YAAY;AAC1B,WAAK,sBAAsB,QAAQ,CAAC,YAAY,QAAQ,KAAK,CAAC;AAC9D,WAAK,wBAAwB,CAAC;AAAA,IAChC;AAEA,SAAS,gBAAgB,CAAC,WAAqC;AAC7D,iBAAO,oCAAsB,MAAM;AAAA,IACrC;AAAA;AAAA,EA1DA;AA2DF;",
  "names": []
}
