{
  "version": 3,
  "sources": ["../../../../../../../../libs/connector-runner-api-source/src/lib/api-extractor/api-extractor.service.ts"],
  "sourcesContent": ["import { interval, Subscription } from 'rxjs';\nimport axios, { AxiosRequestConfig } from 'axios';\nimport Handlebars from 'handlebars';\nimport helpers from 'handlebars-helpers';\nimport {\n  OffsetStore,\n  PersistentOffsetStoreInterface,\n} from '@transai/connector-runtime';\nimport { Logger } from '@transai/logger';\nimport { generateOffsetIdentifier } from '../helper.functions';\nimport { ApiResultHandler } from '../api-result.handler';\nimport { ApiConfig, ApiSourceConfig } from '../types';\nimport { TokenManager } from '../token-manager/token-manager';\n\nexport class ApiExtractorService {\n  readonly #config: ApiSourceConfig;\n\n  readonly #apiConfig: ApiConfig;\n\n  readonly #apiResultHandler: ApiResultHandler;\n\n  readonly #offsetStore: PersistentOffsetStoreInterface;\n\n  readonly #handlebarsTemplate: HandlebarsTemplateDelegate | undefined;\n\n  readonly #urlTemplate: HandlebarsTemplateDelegate;\n\n  #processing = false;\n\n  readonly #handlebarsInstance: typeof Handlebars | undefined;\n\n  #logger: Logger;\n\n  #token: string | undefined;\n\n  #tokenExpiresAt: number | undefined;\n\n  #tokenManager: TokenManager | undefined;\n\n  #subscription?: Subscription;\n\n  constructor(\n    config: ApiSourceConfig,\n    apiConfig: ApiConfig,\n    apiResultHandler: ApiResultHandler,\n    offsetStore: PersistentOffsetStoreInterface,\n    tokenManager?: TokenManager,\n  ) {\n    this.#config = config;\n    this.#apiConfig = apiConfig;\n    this.#apiResultHandler = apiResultHandler;\n    this.#offsetStore = offsetStore;\n    this.#tokenManager = tokenManager;\n\n    if (!apiConfig.url) {\n      throw new Error('URL is not defined in apiConfig');\n    }\n\n    this.#logger = Logger.getInstance();\n    this.#logger.debug(\n      `Api source service initialized: ${this.#apiConfig.name} with interval of ${this.#apiConfig.interval} seconds`,\n    );\n\n    this.#handlebarsInstance = Handlebars.create();\n    helpers({ handlebars: this.#handlebarsInstance });\n    this.#handlebarsInstance.registerHelper(\n      'formatISODate',\n      function (timestamp, timezone: string) {\n        const date = new Date(timestamp);\n        return date.toISOString();\n      },\n    );\n\n    if (apiConfig.body) {\n      this.#handlebarsTemplate = this.#handlebarsInstance.compile(\n        apiConfig.body,\n        { strict: true },\n      );\n      this.validateTemplate();\n    }\n\n    this.#urlTemplate = this.#handlebarsInstance.compile(apiConfig.url, {\n      strict: true,\n    });\n\n    if (this.#apiConfig.tokenUrl) {\n      this.getAccessToken()\n        .then((token) => {\n          if (token) {\n            this.#logger.debug(\n              `Access token retrieved successfully for ${this.#apiConfig.name}`,\n            );\n          } else {\n            this.#logger.error(\n              `Failed to retrieve access token for ${this.#apiConfig.name}`,\n            );\n          }\n        })\n        .catch((error) => {\n          this.#logger.error(\n            `Error retrieving access token for ${this.#apiConfig.name}: ${error}`,\n          );\n        });\n    }\n\n    this.#subscription = interval(this.#apiConfig.interval * 1000).subscribe(\n      async () => {\n        await this.extract();\n      },\n    );\n  }\n\n  stop() {\n    this.#subscription?.unsubscribe();\n  }\n\n  private async extract(): Promise<void> {\n    if (this.#processing) {\n      this.#logger.debug(\n        'Api source service is already processing: ',\n        this.#apiConfig.name,\n      );\n      return;\n    }\n\n    this.#processing = true;\n    try {\n      await this.executeApi().catch((error) => {\n        throw new Error(\n          `Error while extracting data from api source service ${error.message}`,\n        );\n      });\n    } catch (error) {\n      Logger.getInstance().debug(JSON.stringify(error));\n    } finally {\n      this.#processing = false;\n    }\n  }\n\n  private async executeApi(): Promise<void> {\n    const latestOffset = await this.#offsetStore.getOffset(\n      generateOffsetIdentifier(this.#apiConfig),\n    );\n    if (this.#config.debug)\n      Logger.getInstance().debug(\n        `Latest offset for ${this.#apiConfig.name}: ${JSON.stringify(latestOffset)}`,\n      );\n    const body = this.getBody(latestOffset, this.#apiConfig.batchSize ?? 10);\n    const url = this.getUrl(latestOffset, this.#apiConfig.batchSize ?? 10);\n\n    Logger.getInstance().debug(\n      `Executing ${this.#apiConfig.method} request to ${url} with body ${body}`,\n    );\n    const contentType: string = this.#apiConfig.format ?? 'text';\n    const headers: { 'Content-Type': string; Authorization?: string } = {\n      'Content-Type': contentType,\n    };\n\n    if (this.#apiConfig.tokenUrl) {\n      const token = await this.getAccessToken();\n      if (token) {\n        headers['Authorization'] = `Bearer ${token}`;\n      }\n    }\n\n    if (this.#tokenManager) {\n      const token = await this.#tokenManager.getAccessToken();\n      if (token) {\n        headers['Authorization'] = `Bearer ${token}`;\n      }\n    }\n\n    if (this.#apiConfig.authorization) {\n      // add authorization header from authorization from apiConfig if set\n      headers['Authorization'] = this.#apiConfig.authorization;\n    }\n\n    const config: AxiosRequestConfig = {\n      responseType: 'text',\n      headers,\n    };\n\n    try {\n      let result;\n\n      switch (this.#apiConfig.method) {\n        case 'POST':\n          result = await axios.post(url, body, config);\n          break;\n        case 'GET':\n          result = await axios.get(url, config);\n          break;\n        default:\n          throw new Error(`Unsupported method ${this.#apiConfig.method}`);\n      }\n\n      await this.#apiResultHandler.handleResult(result, this.#apiConfig);\n    } catch (error) {\n      this.#logger.debug(\n        `Error while extracting data from api source service: ${JSON.stringify(error)}`,\n      );\n    }\n  }\n\n  private getBody(offset: OffsetStore, limit: number): string {\n    if (!this.#handlebarsTemplate) {\n      return '';\n    }\n\n    return this.#handlebarsTemplate({\n      ...offset,\n      limit,\n    });\n  }\n\n  private getUrl(offset: OffsetStore, limit: number): string {\n    return this.#urlTemplate({\n      ...offset,\n      limit,\n    });\n  }\n\n  private validateTemplate(): void {\n    this.getBody({ timestamp: 0, id: 0, rawTimestamp: 0 }, 0);\n  }\n\n  private async getAccessToken(): Promise<string | undefined> {\n    const { tokenUrl, clientId, clientSecret } = this.#apiConfig;\n\n    if (!tokenUrl || !clientId || !clientSecret) return undefined;\n\n    const now = Date.now();\n    if (this.#token && this.#tokenExpiresAt && now < this.#tokenExpiresAt) {\n      return this.#token;\n    }\n\n    try {\n      const response = await axios.post(tokenUrl, null, {\n        params: {\n          grant_type: 'client_credentials',\n          client_id: clientId,\n          client_secret: clientSecret,\n        },\n      });\n\n      const { access_token: accesToken, expires_in: expiresIn } = response.data;\n      const expiresInMiliseconds = expiresIn * 1000;\n\n      this.#token = accesToken;\n      this.#tokenExpiresAt = now + expiresInMiliseconds - 10000; // subtract 10s buffer\n      return this.#token;\n    } catch (error) {\n      this.#logger.error(`Failed to retrieve access token: ${error}`);\n      return undefined;\n    }\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAAuC;AACvC,mBAA0C;AAC1C,wBAAuB;AACvB,gCAAoB;AAKpB,oBAAuB;AACvB,oBAAyC;AAKlC,MAAM,oBAAoB;AAAA,EACtB;AAAA,EAEA;AAAA,EAEA;AAAA,EAEA;AAAA,EAEA;AAAA,EAEA;AAAA,EAET,cAAc;AAAA,EAEL;AAAA,EAET;AAAA,EAEA;AAAA,EAEA;AAAA,EAEA;AAAA,EAEA;AAAA,EAEA,YACE,QACA,WACA,kBACA,aACA,cACA;AACA,SAAK,UAAU;AACf,SAAK,aAAa;AAClB,SAAK,oBAAoB;AACzB,SAAK,eAAe;AACpB,SAAK,gBAAgB;AAErB,QAAI,CAAC,UAAU,KAAK;AAClB,YAAM,IAAI,MAAM,iCAAiC;AAAA,IACnD;AAEA,SAAK,UAAU,qBAAO,YAAY;AAClC,SAAK,QAAQ;AAAA,MACX,mCAAmC,KAAK,WAAW,IAAI,qBAAqB,KAAK,WAAW,QAAQ;AAAA,IACtG;AAEA,SAAK,sBAAsB,kBAAAA,QAAW,OAAO;AAC7C,kCAAAC,SAAQ,EAAE,YAAY,KAAK,oBAAoB,CAAC;AAChD,SAAK,oBAAoB;AAAA,MACvB;AAAA,MACA,SAAU,WAAW,UAAkB;AACrC,cAAM,OAAO,IAAI,KAAK,SAAS;AAC/B,eAAO,KAAK,YAAY;AAAA,MAC1B;AAAA,IACF;AAEA,QAAI,UAAU,MAAM;AAClB,WAAK,sBAAsB,KAAK,oBAAoB;AAAA,QAClD,UAAU;AAAA,QACV,EAAE,QAAQ,KAAK;AAAA,MACjB;AACA,WAAK,iBAAiB;AAAA,IACxB;AAEA,SAAK,eAAe,KAAK,oBAAoB,QAAQ,UAAU,KAAK;AAAA,MAClE,QAAQ;AAAA,IACV,CAAC;AAED,QAAI,KAAK,WAAW,UAAU;AAC5B,WAAK,eAAe,EACjB,KAAK,CAAC,UAAU;AACf,YAAI,OAAO;AACT,eAAK,QAAQ;AAAA,YACX,2CAA2C,KAAK,WAAW,IAAI;AAAA,UACjE;AAAA,QACF,OAAO;AACL,eAAK,QAAQ;AAAA,YACX,uCAAuC,KAAK,WAAW,IAAI;AAAA,UAC7D;AAAA,QACF;AAAA,MACF,CAAC,EACA,MAAM,CAAC,UAAU;AAChB,aAAK,QAAQ;AAAA,UACX,qCAAqC,KAAK,WAAW,IAAI,KAAK,KAAK;AAAA,QACrE;AAAA,MACF,CAAC;AAAA,IACL;AAEA,SAAK,oBAAgB,sBAAS,KAAK,WAAW,WAAW,GAAI,EAAE;AAAA,MAC7D,YAAY;AACV,cAAM,KAAK,QAAQ;AAAA,MACrB;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAO;AACL,SAAK,eAAe,YAAY;AAAA,EAClC;AAAA,EAEA,MAAc,UAAyB;AACrC,QAAI,KAAK,aAAa;AACpB,WAAK,QAAQ;AAAA,QACX;AAAA,QACA,KAAK,WAAW;AAAA,MAClB;AACA;AAAA,IACF;AAEA,SAAK,cAAc;AACnB,QAAI;AACF,YAAM,KAAK,WAAW,EAAE,MAAM,CAAC,UAAU;AACvC,cAAM,IAAI;AAAA,UACR,uDAAuD,MAAM,OAAO;AAAA,QACtE;AAAA,MACF,CAAC;AAAA,IACH,SAAS,OAAO;AACd,2BAAO,YAAY,EAAE,MAAM,KAAK,UAAU,KAAK,CAAC;AAAA,IAClD,UAAE;AACA,WAAK,cAAc;AAAA,IACrB;AAAA,EACF;AAAA,EAEA,MAAc,aAA4B;AACxC,UAAM,eAAe,MAAM,KAAK,aAAa;AAAA,UAC3C,wCAAyB,KAAK,UAAU;AAAA,IAC1C;AACA,QAAI,KAAK,QAAQ;AACf,2BAAO,YAAY,EAAE;AAAA,QACnB,qBAAqB,KAAK,WAAW,IAAI,KAAK,KAAK,UAAU,YAAY,CAAC;AAAA,MAC5E;AACF,UAAM,OAAO,KAAK,QAAQ,cAAc,KAAK,WAAW,aAAa,EAAE;AACvE,UAAM,MAAM,KAAK,OAAO,cAAc,KAAK,WAAW,aAAa,EAAE;AAErE,yBAAO,YAAY,EAAE;AAAA,MACnB,aAAa,KAAK,WAAW,MAAM,eAAe,GAAG,cAAc,IAAI;AAAA,IACzE;AACA,UAAM,cAAsB,KAAK,WAAW,UAAU;AACtD,UAAM,UAA8D;AAAA,MAClE,gBAAgB;AAAA,IAClB;AAEA,QAAI,KAAK,WAAW,UAAU;AAC5B,YAAM,QAAQ,MAAM,KAAK,eAAe;AACxC,UAAI,OAAO;AACT,gBAAQ,eAAe,IAAI,UAAU,KAAK;AAAA,MAC5C;AAAA,IACF;AAEA,QAAI,KAAK,eAAe;AACtB,YAAM,QAAQ,MAAM,KAAK,cAAc,eAAe;AACtD,UAAI,OAAO;AACT,gBAAQ,eAAe,IAAI,UAAU,KAAK;AAAA,MAC5C;AAAA,IACF;AAEA,QAAI,KAAK,WAAW,eAAe;AAEjC,cAAQ,eAAe,IAAI,KAAK,WAAW;AAAA,IAC7C;AAEA,UAAM,SAA6B;AAAA,MACjC,cAAc;AAAA,MACd;AAAA,IACF;AAEA,QAAI;AACF,UAAI;AAEJ,cAAQ,KAAK,WAAW,QAAQ;AAAA,QAC9B,KAAK;AACH,mBAAS,MAAM,aAAAC,QAAM,KAAK,KAAK,MAAM,MAAM;AAC3C;AAAA,QACF,KAAK;AACH,mBAAS,MAAM,aAAAA,QAAM,IAAI,KAAK,MAAM;AACpC;AAAA,QACF;AACE,gBAAM,IAAI,MAAM,sBAAsB,KAAK,WAAW,MAAM,EAAE;AAAA,MAClE;AAEA,YAAM,KAAK,kBAAkB,aAAa,QAAQ,KAAK,UAAU;AAAA,IACnE,SAAS,OAAO;AACd,WAAK,QAAQ;AAAA,QACX,wDAAwD,KAAK,UAAU,KAAK,CAAC;AAAA,MAC/E;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,QAAQ,QAAqB,OAAuB;AAC1D,QAAI,CAAC,KAAK,qBAAqB;AAC7B,aAAO;AAAA,IACT;AAEA,WAAO,KAAK,oBAAoB;AAAA,MAC9B,GAAG;AAAA,MACH;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEQ,OAAO,QAAqB,OAAuB;AACzD,WAAO,KAAK,aAAa;AAAA,MACvB,GAAG;AAAA,MACH;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEQ,mBAAyB;AAC/B,SAAK,QAAQ,EAAE,WAAW,GAAG,IAAI,GAAG,cAAc,EAAE,GAAG,CAAC;AAAA,EAC1D;AAAA,EAEA,MAAc,iBAA8C;AAC1D,UAAM,EAAE,UAAU,UAAU,aAAa,IAAI,KAAK;AAElD,QAAI,CAAC,YAAY,CAAC,YAAY,CAAC;AAAc,aAAO;AAEpD,UAAM,MAAM,KAAK,IAAI;AACrB,QAAI,KAAK,UAAU,KAAK,mBAAmB,MAAM,KAAK,iBAAiB;AACrE,aAAO,KAAK;AAAA,IACd;AAEA,QAAI;AACF,YAAM,WAAW,MAAM,aAAAA,QAAM,KAAK,UAAU,MAAM;AAAA,QAChD,QAAQ;AAAA,UACN,YAAY;AAAA,UACZ,WAAW;AAAA,UACX,eAAe;AAAA,QACjB;AAAA,MACF,CAAC;AAED,YAAM,EAAE,cAAc,YAAY,YAAY,UAAU,IAAI,SAAS;AACrE,YAAM,uBAAuB,YAAY;AAEzC,WAAK,SAAS;AACd,WAAK,kBAAkB,MAAM,uBAAuB;AACpD,aAAO,KAAK;AAAA,IACd,SAAS,OAAO;AACd,WAAK,QAAQ,MAAM,oCAAoC,KAAK,EAAE;AAC9D,aAAO;AAAA,IACT;AAAA,EACF;AACF;",
  "names": ["Handlebars", "helpers", "axios"]
}
