{
  "version": 3,
  "sources": ["../../../../../../../libs/connector-runner-api-source/src/lib/api-result.handler.ts"],
  "sourcesContent": ["import { AxiosResponse } from 'axios';\nimport { decode } from 'html-entities';\nimport { PersistentOffsetStoreInterface } from '@transai/connector-runtime';\nimport { Logger } from '@transai/logger';\nimport { generateOffsetIdentifier } from './helper.functions';\nimport { ApiConfig, ApiSourceConfig } from './types';\nimport { KafkaService } from './kafka/kafka.service';\n\nexport class ApiResultHandler {\n  constructor(\n    private readonly config: ApiSourceConfig,\n    private readonly kafkaService: KafkaService,\n    private readonly offsetStore: PersistentOffsetStoreInterface,\n  ) {}\n\n  public async handleResult(\n    result: AxiosResponse,\n    apiConfig: ApiConfig,\n  ): Promise<void> {\n    const parsedContent = JSON.parse(decode(result.data));\n    const keys = Object.keys(parsedContent);\n\n    if (keys.length === 0) {\n      return;\n    }\n\n    if (keys.length === 1) {\n      // Old method to handle Betech. We have to refactor this in the future.\n      Logger.getInstance().debug('Handling Betech way', apiConfig.name, keys);\n      await this.handleBetechWay(result, apiConfig);\n    } else if (apiConfig.listField) {\n      await this.sendBatch(parsedContent, apiConfig);\n    } else {\n      await this.handleSingleRecord(parsedContent, apiConfig);\n    }\n  }\n\n  private async handleBetechWay(result: AxiosResponse, apiConfig: ApiConfig) {\n    const parsedContent = JSON.parse(decode(result.data));\n    const keys = Object.keys(parsedContent);\n\n    const metadata = {\n      machine: apiConfig.name,\n      cnc: keys[0],\n    };\n\n    let success = false;\n    // check only for document, to ensure backwards compatibility with old code.\n    // Default fallback to metric since it is the previous default.\n    if (apiConfig.type === 'document') {\n      success = await this.kafkaService.sendDocuments(\n        [parsedContent[keys[0]]],\n        this.config,\n        apiConfig,\n        metadata,\n      );\n    } else {\n      success = await this.kafkaService.sendMetric(\n        [parsedContent[keys[0]]],\n        this.config,\n        apiConfig,\n        metadata,\n      );\n    }\n\n    if (!success) {\n      Logger.getInstance().debug(\n        'Error while sending record to Kafka: ',\n        parsedContent,\n      );\n    }\n  }\n\n  private async sendBatch(parsedContent: any, apiConfig: ApiConfig) {\n    const list = parsedContent[apiConfig.listField ?? ''];\n\n    if (list && Array.isArray(list)) {\n      Logger.getInstance().debug(\n        `Found ${list.length} records in list field ${apiConfig.listField}`,\n      );\n\n      // check only for metric, to ensure backwards compatibility with old code.\n      // Default fallback to document since it is the previous default.\n      if (apiConfig.type === 'metric') {\n        await this.kafkaService.sendMetric(list, this.config, apiConfig);\n      } else {\n        await this.kafkaService.sendDocuments(list, this.config, apiConfig);\n      }\n\n      const item = list[list.length - 1];\n      this.storeTimestamp(\n        apiConfig.incrementalField\n          ? new Date(item[apiConfig.incrementalField])\n          : new Date(),\n        apiConfig,\n      );\n    } else {\n      Logger.getInstance().debug(\n        `No records found in list field ${apiConfig.listField}, skipping. ${JSON.stringify(parsedContent)}`,\n      );\n    }\n  }\n\n  private async handleSingleRecord(parsedContent: any, apiConfig: ApiConfig) {\n    let success = false;\n\n    // check only for metric, to ensure backwards compatibility with old code.\n    // Default fallback to document since it is the previous default.\n    if (apiConfig.type === 'metric') {\n      success = await this.kafkaService.sendMetric(\n        [parsedContent],\n        this.config,\n        apiConfig,\n      );\n    } else {\n      success = await this.kafkaService.sendDocuments(\n        [parsedContent],\n        this.config,\n        apiConfig,\n      );\n    }\n\n    if (!success) {\n      Logger.getInstance().debug(\n        'Error while sending record to Kafka: ',\n        parsedContent,\n      );\n    }\n\n    if (success) {\n      this.storeTimestamp(new Date(), apiConfig);\n    }\n  }\n\n  private storeTimestamp(timestamp: Date, apiConfig: ApiConfig) {\n    this.offsetStore.setOffset(\n      { timestamp: timestamp.getTime(), id: 0, rawTimestamp: 0 },\n      generateOffsetIdentifier(apiConfig),\n    );\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
