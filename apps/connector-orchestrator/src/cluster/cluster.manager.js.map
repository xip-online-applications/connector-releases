{
  "version": 3,
  "sources": ["../../../../../../../apps/connector-orchestrator/src/cluster/cluster.manager.ts"],
  "sourcesContent": ["import { Logger } from '@transai/logger';\nimport { ConnectorApiClient } from '@transai/management-api-client';\nimport { ConnectorInterface } from '@xip-online-data/types';\nimport { IpcMessage } from '@transai/connector-runtime';\nimport { catchError, of, tap, timer } from 'rxjs';\nimport { NodeWrapperInterface } from '../util/node-wrapper';\nimport { checkTwoArrays } from '../util/check-two-arrays';\nimport { getLogLevel } from '../util/log-level';\nimport { StartedConnectorProcess } from './started-process.interface';\n\nexport class ClusterManager {\n  readonly #node: NodeWrapperInterface;\n\n  readonly #managementApiClient: ConnectorApiClient;\n\n  readonly #logger: Logger;\n\n  #lastUpdatedTimestamp: string | undefined;\n\n  #enabledConnectors: Array<ConnectorInterface> = [];\n\n  #startedConnectorProcesses: Array<StartedConnectorProcess> = [];\n\n  constructor(\n    node: NodeWrapperInterface,\n    managementApiClient: ConnectorApiClient,\n  ) {\n    this.#node = node;\n    this.#managementApiClient = managementApiClient;\n    this.#logger = Logger.getInstance(\n      'connector-orchestrator',\n      getLogLevel(this.#node),\n    );\n  }\n\n  readonly start = () => {\n    const broadcastMessage = (message: IpcMessage) => {\n      Object.values(this.#node.cluster.workers ?? {}).forEach((worker) => {\n        worker.send(message);\n      });\n    };\n\n    const startProcess = (connector: ConnectorInterface) => {\n      this.#logger.info(\n        `Starting process type: ${connector.connectorType}, Identifier: ${connector.identifier}`,\n      );\n      const newProcess = this.#node.cluster.fork({\n        CONNECTOR: JSON.stringify(connector),\n      });\n\n      newProcess.on('message', (message: IpcMessage) => {\n        broadcastMessage(message);\n      });\n\n      newProcess.on('exit', (code, signal) => {\n        this.#logger.info(\n          `Connector ${connector.connectorType} - ${connector.identifier} - pid ${newProcess.process.pid} process exited`,\n        );\n        const processStats = this.#startedConnectorProcesses.find(\n          (p) => p.pid === newProcess.process.pid,\n        );\n        const startedOn = processStats ? processStats.startedOn : new Date();\n\n        const processIndex = this.#startedConnectorProcesses.findIndex(\n          (p) => p.pid === newProcess.process.pid,\n        );\n        if (processIndex !== -1) {\n          this.#logger.debug(\n            `Removing process for connector ${connector.identifier}, ${connector.connectorType}`,\n          );\n          this.#startedConnectorProcesses.splice(processIndex, 1);\n        }\n\n        if (code !== 0) {\n          this.#logger.warn(\n            `Worker ${newProcess.process.pid} died with code ${code} and signal ${signal}`,\n          );\n        } else {\n          this.#logger.debug(\n            `Worker ${newProcess.process.pid} exited with code ${code} and signal ${signal}`,\n          );\n        }\n\n        const runtime = new Date().getTime() - startedOn.getTime();\n        const timeoutTime = Math.max(100, 60000 - runtime);\n        this.#logger.debug(\n          `Runtime of process ${runtime}, Restarting process for connector ${connector.identifier}, ${connector.connectorType} in ${timeoutTime} ms`,\n        );\n\n        setTimeout(() => {\n          const isAlreadyStarted = this.#startedConnectorProcesses.some(\n            (p) =>\n              p.connectorType === connector.connectorType &&\n              p.identifier === connector.identifier,\n          );\n          if (isAlreadyStarted) {\n            this.#logger.info(\n              `There is already a connector running with ${connector.identifier}, ${connector.connectorType}. Do not start this again.`,\n            );\n            return;\n          }\n\n          const connectorEnabled = this.#enabledConnectors.some(\n            (c) =>\n              c.connectorType === connector.connectorType &&\n              c.identifier === connector.identifier,\n          );\n          if (!connectorEnabled) {\n            this.#logger.info(\n              `Could not find connector ${connector.identifier}, ${connector.connectorType}. Not enabled so not restarting.`,\n            );\n          } else {\n            this.#logger.info(\n              `Restarting process FROM EXIT LOOP for connector ${connector.identifier}, ${connector.connectorType}, ${newProcess.process.pid}`,\n            );\n            startProcess(connector);\n          }\n        }, timeoutTime);\n      });\n\n      this.#startedConnectorProcesses.push({\n        connectorType: connector.connectorType,\n        identifier: connector.identifier,\n        pid: newProcess.process.pid,\n        worker: newProcess,\n        startedOn: new Date(),\n      });\n    };\n\n    const stopProcess = (connector: ConnectorInterface) => {\n      this.#logger.info(\n        `Stopping process for connector ${connector.identifier}, ${connector.connectorType}`,\n      );\n      const process = this.#startedConnectorProcesses.find(\n        (p) =>\n          p.connectorType === connector.connectorType &&\n          p.identifier === connector.identifier,\n      );\n      if (process) {\n        try {\n          process.worker.kill();\n          this.#logger.info(\n            `${connector.identifier} - ${connector.connectorType} Process killed`,\n          );\n        } catch (error) {\n          this.#logger.error(\n            `Error while killing process for connector ${connector.identifier}, ${connector.connectorType} ${JSON.stringify(error)}`,\n          );\n        }\n      } else {\n        this.#logger.error(\n          `Could not find process for connector ${connector.identifier}`,\n        );\n      }\n    };\n\n    const checkConnectors = async () => {\n      const test = Object.entries(this.#node.cluster.workers).length;\n\n      if (test !== this.#enabledConnectors.length) {\n        this.#logger.error(\n          `Number of workers: ${test}, Number of configured workers ${this.#enabledConnectors.length}, number of started workers ${this.#startedConnectorProcesses.length}`,\n        );\n      } else {\n        this.#logger.info(\n          `Number of workers: ${test}, Number of configured workers ${this.#enabledConnectors.length}, number of started workers ${this.#startedConnectorProcesses.length}`,\n        );\n      }\n\n      const newLastUpdatedTimestamp = await this.#managementApiClient\n        .getLastUpdatedTimestamp()\n        .catch((error) => {\n          this.#logger.error(\n            'Error while getting last updated timestamp',\n            error,\n          );\n          return this.#lastUpdatedTimestamp;\n        });\n\n      if (newLastUpdatedTimestamp === this.#lastUpdatedTimestamp) {\n        this.#logger.debug(\n          'Last updated timestamp has not changed. No need to check for new or changed connectors',\n        );\n        return;\n      }\n\n      this.#logger.info(\n        'Last updated timestamp has changed. Check for new or changed connectors',\n      );\n\n      const newEnabledConnectors = await this.#managementApiClient\n        .getActiveConnectors()\n        .catch((error) => {\n          this.#logger.error('Error while getting active connectors', error);\n          return this.#enabledConnectors;\n        });\n\n      this.#logger.info(\n        `received ${newEnabledConnectors.length} enabled connectors`,\n      );\n      const comparisonResult = checkTwoArrays(\n        this.#enabledConnectors,\n        newEnabledConnectors,\n      );\n\n      const toRemove = comparisonResult.onlyInA;\n      const toAdd = comparisonResult.onlyInB;\n\n      toRemove.forEach(stopProcess);\n      toAdd.forEach(startProcess);\n\n      this.#enabledConnectors = [...newEnabledConnectors];\n      this.#lastUpdatedTimestamp = newLastUpdatedTimestamp;\n    };\n\n    let mutex = false;\n    this.#logger.info('Starting process to check connectors');\n\n    return timer(0, 60 * 1000).pipe(\n      catchError((e?: Error) => {\n        this.#logger.error(`Error while checking connectors ${e?.message}`, e);\n        return of(null);\n      }),\n      tap(() => {\n        try {\n          if (mutex) {\n            this.#logger.error('Mutex is set, skipping check');\n            return;\n          }\n          mutex = true;\n\n          checkConnectors()\n            .then(() => {\n              mutex = false;\n              this.#logger.debug('Checked connectors');\n            })\n            .catch((e) => {\n              mutex = false;\n              this.#logger.error(\n                `Error while checking connectors, ${JSON.parse(e)}`,\n              );\n              return null;\n            });\n        } catch (error) {\n          this.#logger.error('Error while checking connectors', error);\n        }\n      }),\n    );\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
