{
  "version": 3,
  "sources": ["../../../../../../../apps/connector-orchestrator/src/cluster/cluster.manager.ts"],
  "sourcesContent": ["import { IpcMessage } from '@transai/connector-runtime';\nimport { Logger } from '@transai/logger';\nimport { ConnectorApiClient } from '@transai/management-api-client';\nimport {\n  BaseConnectorConfig,\n  ConnectorInterface,\n  ConnectorOrchestratorConfigWithKafkaInterface,\n  ConnectorOrchestratorFullConfigurationInterface,\n  KafkaBrokerConfig,\n} from '@xip-online-data/types';\nimport { catchError, Observable, of, tap, timer } from 'rxjs';\n\nimport { checkTwoArrays } from '../util/check-two-arrays';\nimport { NodeWrapperInterface } from '../util/node-wrapper';\n\nimport { StartedConnectorProcess } from './started-process.interface';\n\nexport class ClusterManager {\n  // As a backup we use eu-west-1 as default region\n  readonly #DEFAULT_AWS_REGION = 'eu-west-1';\n\n  readonly #node: NodeWrapperInterface;\n\n  readonly #managementApiClient: ConnectorApiClient;\n\n  readonly #logger: Logger;\n\n  #lastUpdatedTimestamp: string | undefined;\n\n  #orchestratorConfig?: ConnectorOrchestratorConfigWithKafkaInterface;\n\n  #enabledConnectors: Array<ConnectorInterface> = [];\n\n  #startedConnectorProcesses: Array<StartedConnectorProcess> = [];\n\n  constructor(\n    node: NodeWrapperInterface,\n    managementApiClient: ConnectorApiClient,\n  ) {\n    this.#node = node;\n    this.#managementApiClient = managementApiClient;\n    this.#logger = Logger.getInstance();\n  }\n\n  readonly start = (): Observable<number> => {\n    const broadcastMessage = (message: IpcMessage): void => {\n      Object.values(this.#node.cluster.workers ?? {}).forEach((worker) => {\n        worker.send(message);\n      });\n    };\n\n    const startProcess = (connector: ConnectorInterface): void => {\n      this.#logger.info(\n        `Starting process type: ${connector.connectorType}, Identifier: ${connector.identifier}`,\n      );\n      const newProcess = this.#node.cluster.fork({\n        CONNECTOR: JSON.stringify(connector),\n        ORCHESTRATOR_CONFIG: JSON.stringify(this.#orchestratorConfig),\n      });\n\n      newProcess.on('message', (message: IpcMessage) => {\n        broadcastMessage(message);\n      });\n\n      newProcess.on('exit', (code, signal) => {\n        this.#logger.info(\n          `Connector ${connector.connectorType} - ${connector.identifier} - pid ${newProcess.process.pid} process exited`,\n        );\n        const processStats = this.#startedConnectorProcesses.find(\n          (p) => p.pid === newProcess.process.pid,\n        );\n        const startedOn = processStats ? processStats.startedOn : new Date();\n\n        const processIndex = this.#startedConnectorProcesses.findIndex(\n          (p) => p.pid === newProcess.process.pid,\n        );\n        if (processIndex !== -1) {\n          this.#logger.debug(\n            `Removing process for connector ${connector.identifier}, ${connector.connectorType}`,\n          );\n          this.#startedConnectorProcesses.splice(processIndex, 1);\n        }\n\n        if (code !== 0) {\n          this.#logger.warn(\n            `Worker ${newProcess.process.pid} died with code ${code} and signal ${signal}`,\n          );\n        } else {\n          this.#logger.debug(\n            `Worker ${newProcess.process.pid} exited with code ${code} and signal ${signal}`,\n          );\n        }\n\n        const runtime = new Date().getTime() - startedOn.getTime();\n        const timeoutTime = Math.max(100, 60000 - runtime);\n        this.#logger.debug(\n          `Runtime of process ${runtime}, Restarting process for connector ${connector.identifier}, ${connector.connectorType} in ${timeoutTime} ms`,\n        );\n\n        setTimeout(() => {\n          const isAlreadyStarted = this.#startedConnectorProcesses.some(\n            (p) =>\n              p.connectorType === connector.connectorType &&\n              p.identifier === connector.identifier,\n          );\n          if (isAlreadyStarted) {\n            this.#logger.info(\n              `There is already a connector running with ${connector.identifier}, ${connector.connectorType}. Do not start this again.`,\n            );\n            return;\n          }\n\n          const connectorEnabled = this.#enabledConnectors.some(\n            (c) =>\n              c.connectorType === connector.connectorType &&\n              c.identifier === connector.identifier,\n          );\n          if (!connectorEnabled) {\n            this.#logger.info(\n              `Could not find connector ${connector.identifier}, ${connector.connectorType}. Not enabled so not restarting.`,\n            );\n          } else {\n            this.#logger.info(\n              `Restarting process FROM EXIT LOOP for connector ${connector.identifier}, ${connector.connectorType}, ${newProcess.process.pid}`,\n            );\n            startProcess(connector);\n          }\n        }, timeoutTime);\n      });\n\n      this.#startedConnectorProcesses.push({\n        connectorType: connector.connectorType,\n        identifier: connector.identifier,\n        pid: newProcess.process.pid,\n        worker: newProcess,\n        startedOn: new Date(),\n      });\n    };\n\n    const stopProcess = (connector: ConnectorInterface): void => {\n      this.#logger.info(\n        `Stopping process for connector ${connector.identifier}, ${connector.connectorType}`,\n      );\n      const process = this.#startedConnectorProcesses.find(\n        (p) =>\n          p.connectorType === connector.connectorType &&\n          p.identifier === connector.identifier,\n      );\n      if (process) {\n        try {\n          process.worker.kill();\n          this.#logger.info(\n            `${connector.identifier} - ${connector.connectorType} Process killed`,\n          );\n        } catch (error) {\n          this.#logger.error(\n            `Error while killing process for connector ${connector.identifier}, ${connector.connectorType} ${JSON.stringify(error)}`,\n          );\n        }\n      } else {\n        this.#logger.error(\n          `Could not find process for connector ${connector.identifier}`,\n        );\n      }\n    };\n\n    const checkConnectors = async (): Promise<void> => {\n      const test = Object.entries(this.#node.cluster.workers).length;\n\n      if (test !== this.#enabledConnectors.length) {\n        this.#logger.error(\n          `Number of workers: ${test}, Number of configured workers ${this.#enabledConnectors.length}, number of started workers ${this.#startedConnectorProcesses.length}`,\n        );\n      } else {\n        this.#logger.info(\n          `Number of workers: ${test}, Number of configured workers ${this.#enabledConnectors.length}, number of started workers ${this.#startedConnectorProcesses.length}`,\n        );\n      }\n\n      const newLastUpdatedTimestamp = await this.#managementApiClient\n        .getLastUpdatedTimestamp()\n        .catch((error) => {\n          this.#logger.error(\n            'Error while getting last updated timestamp',\n            error,\n          );\n          return this.#lastUpdatedTimestamp;\n        });\n\n      if (newLastUpdatedTimestamp === this.#lastUpdatedTimestamp) {\n        this.#logger.debug(\n          'Last updated timestamp has not changed. No need to check for new or changed connectors',\n        );\n        return;\n      }\n\n      this.#logger.info(\n        'Last updated timestamp has changed. Check for new or changed connectors',\n      );\n\n      const fullOrchestratorConfig: ConnectorOrchestratorFullConfigurationInterface | null =\n        await this.#managementApiClient.getActiveConnectors().catch((error) => {\n          this.#logger.error('Error while getting active connectors', error);\n          return null;\n        });\n\n      if (fullOrchestratorConfig === null) {\n        return;\n      }\n\n      this.#orchestratorConfig = fullOrchestratorConfig.config;\n\n      if (this.#orchestratorConfig.datadogApiKey) {\n        this.#logger.setDatadogTransport({\n          apiKey: this.#orchestratorConfig.datadogApiKey,\n          service: 'cluster-manager',\n          source: 'connector-orchestrator',\n        });\n      }\n\n      let defaultTenantIdentifier = process.env['TENANT_IDENTIFIER'] ?? null;\n      if (defaultTenantIdentifier === '') {\n        defaultTenantIdentifier = null;\n      }\n\n      const newConnectors = (\n        fullOrchestratorConfig.connectors ?? this.#enabledConnectors\n      ).map((connector) =>\n        this.#buildConnectorConfiguration(\n          connector,\n          fullOrchestratorConfig,\n          defaultTenantIdentifier,\n        ),\n      );\n\n      this.#logger.info(`received ${newConnectors.length} enabled connectors`);\n      const comparisonResult = checkTwoArrays(\n        this.#enabledConnectors,\n        newConnectors,\n      );\n\n      const toRemove = comparisonResult.onlyInA;\n      const toAdd = comparisonResult.onlyInB;\n\n      toRemove.forEach(stopProcess);\n      toAdd.forEach(startProcess);\n\n      this.#enabledConnectors = [...newConnectors];\n      this.#lastUpdatedTimestamp = newLastUpdatedTimestamp;\n    };\n\n    let mutex = false;\n    this.#logger.info('Starting process to check connectors');\n\n    return timer(0, 60 * 1000).pipe(\n      catchError((e?: Error) => {\n        this.#logger.error(`Error while checking connectors ${e?.message}`, e);\n        return of(null);\n      }),\n      tap(() => {\n        try {\n          if (mutex) {\n            this.#logger.error('Mutex is set, skipping check');\n            return;\n          }\n          mutex = true;\n\n          checkConnectors()\n            .then(() => {\n              mutex = false;\n              this.#logger.debug('Checked connectors');\n            })\n            .catch((e) => {\n              mutex = false;\n              this.#logger.error(\n                `Error while checking connectors, ${JSON.parse(e)}`,\n              );\n              return null;\n            });\n        } catch (error) {\n          this.#logger.error('Error while checking connectors', error);\n        }\n      }),\n    );\n  };\n\n  readonly #buildConnectorConfiguration = (\n    connector: ConnectorInterface,\n    fullOrchestratorConfig: ConnectorOrchestratorFullConfigurationInterface,\n    defaultTenantIdentifier?: string,\n  ): ConnectorInterface => {\n    const tenantIdentifier =\n      defaultTenantIdentifier ?? connector.tenantIdentifier;\n\n    const awsAccessKeyId =\n      connector.config.kafka?.sasl?.accessKeyId ??\n      process.env['AWS_ACCESS_KEY_ID'] ??\n      fullOrchestratorConfig.config.awsAccessKeyId;\n\n    const awsSecretAccessKey =\n      connector.config.kafka?.sasl?.secretAccessKey ??\n      process.env['AWS_SECRET_ACCESS_KEY'] ??\n      fullOrchestratorConfig.config.awsSecretAccessKey;\n\n    return {\n      ...connector,\n      tenantIdentifier,\n      config: {\n        ...connector.config,\n        tenantIdentifier,\n        processIdentifier:\n          connector.config.processIdentifier ??\n          `${tenantIdentifier}-${connector.identifier}`,\n        kafka: {\n          ...(connector.config.kafka ?? {}),\n          brokers:\n            connector.config.kafka?.brokers ??\n            fullOrchestratorConfig.config.kafkaBrokers,\n          groupId:\n            connector.config.kafka?.groupId ??\n            `${tenantIdentifier}-${connector.identifier}-group`,\n          clientId:\n            connector.config.kafka?.clientId ??\n            `${tenantIdentifier}-${connector.identifier}-client`,\n          useConfluentLibrary:\n            connector.config.kafka?.useConfluentLibrary ?? true,\n\n          ...(awsAccessKeyId && awsSecretAccessKey\n            ? {\n                sasl: {\n                  region:\n                    connector.config.kafka?.sasl?.region ??\n                    process.env['AWS_REGION'] ??\n                    fullOrchestratorConfig.config.awsRegion ??\n                    this.#DEFAULT_AWS_REGION,\n                  accessKeyId: awsAccessKeyId,\n                  secretAccessKey: awsSecretAccessKey,\n                  mechanism: 'aws',\n                },\n              }\n            : {}),\n        } as KafkaBrokerConfig,\n      } as BaseConnectorConfig,\n    };\n  };\n}\n"],
  "mappings": "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",
  "names": ["process"]
}
